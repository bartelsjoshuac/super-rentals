/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(globalThis["webpackChunk_ember_auto_import_"] = globalThis["webpackChunk_ember_auto_import_"] || []).push([["vendors-node_modules_ember-data_debug_dist_data-adapter_js-node_modules_ember-data_json-api_d-97cbc2"],{

/***/ "./node_modules/@ember-data/debug/dist/data-adapter.js":
/*!*************************************************************!*\
  !*** ./node_modules/@ember-data/debug/dist/data-adapter.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ dataAdapter)\n/* harmony export */ });\n/* harmony import */ var _ember_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ember/array */ \"@ember/array\");\n/* harmony import */ var _ember_array__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ember_array__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ember_debug_data_adapter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ember/debug/data-adapter */ \"@ember/debug/data-adapter\");\n/* harmony import */ var _ember_debug_data_adapter__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_ember_debug_data_adapter__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _ember_object_observers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ember/object/observers */ \"@ember/object/observers\");\n/* harmony import */ var _ember_object_observers__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_ember_object_observers__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _ember_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ember/service */ \"@ember/service\");\n/* harmony import */ var _ember_service__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_ember_service__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _ember_data_request_utils_string__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ember-data/request-utils/string */ \"./node_modules/@ember-data/request-utils/dist/string.js\");\n/* harmony import */ var _ember_data_store__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ember-data/store */ \"./node_modules/@ember-data/store/dist/index.js\");\nvar _InspectorDataAdapter;function _classPrivateFieldInitSpec(e,t,a){_checkPrivateRedeclaration(e,t),t.set(e,a);}function _checkPrivateRedeclaration(e,t){if(t.has(e))throw new TypeError(\"Cannot initialize the same private elements twice on an object\");}var __defProp=Object.defineProperty;var __export=(target,all)=>{for(var name in all)__defProp(target,name,{get:all[name],enumerable:true});};// src/runtime.ts\nvar runtime_exports={};__export(runtime_exports,{c:()=>decorateClass,f:()=>decorateFieldV1,g:()=>decorateFieldV2,i:()=>initializeDeferredDecorator,m:()=>decorateMethodV1,n:()=>decorateMethodV2,p:()=>decoratePOJO});var deferred=/* @__PURE__ */new WeakMap();function deferDecorator(proto,prop,desc){let map=deferred.get(proto);if(!map){map=/* @__PURE__ */new Map();deferred.set(proto,map);}map.set(prop,desc);}function findDeferredDecorator(target,prop){let cursor=target.prototype;while(cursor){let desc=deferred.get(cursor)?.get(prop);if(desc){return desc;}cursor=cursor.prototype;}}function decorateFieldV1(target,prop,decorators,initializer){return decorateFieldV2(target.prototype,prop,decorators,initializer);}function decorateFieldV2(prototype,prop,decorators,initializer){let desc={configurable:true,enumerable:true,writable:true,initializer:null};if(initializer){desc.initializer=initializer;}for(let decorator of decorators){desc=decorator(prototype,prop,desc)||desc;}if(desc.initializer===void 0){Object.defineProperty(prototype,prop,desc);}else{deferDecorator(prototype,prop,desc);}}function decorateMethodV1({prototype},prop,decorators){return decorateMethodV2(prototype,prop,decorators);}function decorateMethodV2(prototype,prop,decorators){const origDesc=Object.getOwnPropertyDescriptor(prototype,prop);let desc={...origDesc};for(let decorator of decorators){desc=decorator(prototype,prop,desc)||desc;}if(desc.initializer!==void 0){desc.value=desc.initializer?desc.initializer.call(prototype):void 0;desc.initializer=void 0;}Object.defineProperty(prototype,prop,desc);}function initializeDeferredDecorator(target,prop){let desc=findDeferredDecorator(target.constructor,prop);if(desc){Object.defineProperty(target,prop,{enumerable:desc.enumerable,configurable:desc.configurable,writable:desc.writable,value:desc.initializer?desc.initializer.call(target):void 0});}}function decorateClass(target,decorators){return decorators.reduce((accum,decorator)=>decorator(accum)||accum,target);}function decoratePOJO(pojo,decorated){for(let[type,prop,decorators]of decorated){if(type===\"field\"){decoratePojoField(pojo,prop,decorators);}else{decorateMethodV2(pojo,prop,decorators);}}return pojo;}function decoratePojoField(pojo,prop,decorators){let desc={configurable:true,enumerable:true,writable:true,initializer:()=>Object.getOwnPropertyDescriptor(pojo,prop)?.value};for(let decorator of decorators){desc=decorator(pojo,prop,desc)||desc;}if(desc.initializer){desc.value=desc.initializer.call(pojo);delete desc.initializer;}Object.defineProperty(pojo,prop,desc);}/**\n  # Overview\n\n  This package provides the `DataAdapter` which the [Ember Inspector](https://github.com/emberjs/ember-inspector)\n  uses to subscribe and retrieve information for the `data` tab in the inspector.\n\n  This package adds roughly .6 KB when minified and compressed to your application in production; however,\n  you can opt out of shipping this addon in production via options in `ember-cli-build.js`\n\n  ```js\n  let app = new EmberApp(defaults, {\n    emberData: {\n      includeDataAdapterInProduction: false\n    }\n  });\n  ```\n\n  When using `ember-data` as a dependency of your app, the default is to ship the inspector support to production.\n\n  When not using `ember-data` as a dependency but instead using EmberData via declaring specific `@ember-data/<package>`\n  dependencies the default is to not ship to production.\n\n  @module @ember-data/debug\n  @main @ember-data/debug\n*/const StoreTypesMap=new WeakMap();function debugInfo(){const relationships={};const expensiveProperties=[];const identifier=(0,_ember_data_store__WEBPACK_IMPORTED_MODULE_5__.recordIdentifierFor)(this);const fields=this.store.schema.fields(identifier);const attrGroup={name:'Attributes',properties:['id'],expand:true};const attributes=attrGroup.properties;const groups=[attrGroup];for(const field of fields.values()){switch(field.kind){case'attribute':attributes.push(field.name);break;case'belongsTo':case'hasMany':{let properties=relationships[field.kind];if(properties===undefined){properties=relationships[field.kind]=[];groups.push({name:field.kind,properties,expand:true});}properties.push(field.name);expensiveProperties.push(field.name);break;}}}groups.push({name:'Flags',properties:['isLoaded','hasDirtyAttributes','isSaving','isDeleted','isError','isNew','isValid'],expand:false});return{propertyInfo:{// include all other mixins / properties (not just the grouped ones)\nincludeOtherProperties:true,groups:groups,// don't pre-calculate unless cached\nexpensiveProperties:expensiveProperties}};}function installDebugInfo(ModelKlass){/**\n   Provides info about the model for debugging purposes\n   by grouping the properties into more semantic groups.\n    Meant to be used by debugging tools such as the Chrome Ember Extension.\n    - Groups all attributes in \"Attributes\" group.\n   - Groups all belongsTo relationships in \"Belongs To\" group.\n   - Groups all hasMany relationships in \"Has Many\" group.\n   - Groups all flags in \"Flags\" group.\n   - Flags relationship CPs as expensive properties.\n    @internal\n   */ModelKlass.prototype._debugInfo=debugInfo;}function typesMapFor(store){let typesMap=StoreTypesMap.get(store);if(typesMap===undefined){typesMap=new Map();StoreTypesMap.set(store,typesMap);}return typesMap;}/**\n  Implements `@ember/debug/data-adapter` with for EmberData\n  integration with the ember-inspector.\n\n  @class InspectorDataAdapter\n  @extends DataAdapter\n  @private\n*/var _store=/*#__PURE__*/new WeakMap();class InspectorDataAdapter extends (_ember_debug_data_adapter__WEBPACK_IMPORTED_MODULE_1___default()){constructor(...args){super(...args);_classPrivateFieldInitSpec(this,_store,(initializeDeferredDecorator(this,\"store\"),void 0));}/**\n    Specifies how records can be filtered based on the state of the record\n    Records returned will need to have a `filterValues`\n    property with a key for every name in the returned array\n     @method getFilters\n    @private\n    @return {Array} List of objects defining filters\n     The object should have a `name` and `desc` property\n  */getFilters(){return[{name:'isNew',desc:'New'},{name:'isModified',desc:'Modified'},{name:'isClean',desc:'Clean'}];}_nameToClass(type){return this.store.modelFor(type);}/**\n    Fetch the model types and observe them for changes.\n    Maintains the list of model types without needing the Model package for detection.\n     @method watchModelTypes\n    @private\n    @param {Function} typesAdded Callback to call to add types.\n    Takes an array of objects containing wrapped types (returned from `wrapModelType`).\n    @param {Function} typesUpdated Callback to call when a type has changed.\n    Takes an array of objects containing wrapped types.\n    @return {Function} Method to call to remove all observers\n  */watchModelTypes(typesAdded,typesUpdated){const{store}=this;const discoveredTypes=typesMapFor(store);const unsub=store.notifications.subscribe('resource',(identifier,notificationType)=>{if(notificationType==='added'){this.watchTypeIfUnseen(store,discoveredTypes,identifier.type,typesAdded,typesUpdated,_releaseMethods);}});const _releaseMethods=[()=>{store.notifications.unsubscribe(unsub);}];Object.keys(store.identifierCache._cache.resourcesByType).forEach(type=>{discoveredTypes.set(type,false);});// Add any models that were added during initialization of the app, before the inspector was opened\ndiscoveredTypes.forEach((_,type)=>{this.watchTypeIfUnseen(store,discoveredTypes,type,typesAdded,typesUpdated,_releaseMethods);});const release=()=>{_releaseMethods.forEach(fn=>fn());// reset the list so the models can be added if the inspector is re-opened\n// the entries are set to false instead of removed, since the models still exist in the app\n// we just need the inspector to become aware of them\ndiscoveredTypes.forEach((value,key)=>{discoveredTypes.set(key,false);});this.releaseMethods.removeObject(release);};this.releaseMethods.pushObject(release);return release;}/**\n   * Loop over the discovered types and use the callbacks from watchModelTypes to notify\n   * the consumer of this adapter about the mdoels.\n   *\n   * @method watchTypeIfUnseen\n   * @param {store} store\n   * @param {Map} discoveredTypes\n   * @param {String} type\n   * @param {Function} typesAdded\n   * @param {Function} typesUpdated\n   * @param {Array} releaseMethods\n   * @private\n   */watchTypeIfUnseen(store,discoveredTypes,type,typesAdded,typesUpdated,releaseMethods){if(discoveredTypes.get(type)!==true){const klass=store.modelFor(type);installDebugInfo(klass);const wrapped=this.wrapModelType(klass,type);releaseMethods.push(this.observeModelType(type,typesUpdated));typesAdded([wrapped]);discoveredTypes.set(type,true);}}/**\n    Creates a human readable string used for column headers\n     @method columnNameToDesc\n    @private\n    @param {String} name The attribute name\n    @return {String} Human readable string based on the attribute name\n  */columnNameToDesc(name){return (0,_ember_data_request_utils_string__WEBPACK_IMPORTED_MODULE_4__.capitalize)((0,_ember_data_request_utils_string__WEBPACK_IMPORTED_MODULE_4__.underscore)(name).replace(/_/g,' ').trim());}/**\n    Get the columns for a given model type\n     @method columnsForType\n    @private\n    @param {Model} typeClass\n    @return {Array} An array of columns of the following format:\n     name: {String} The name of the column\n     desc: {String} Humanized description (what would show in a table column name)\n  */columnsForType(typeClass){const columns=[{name:'id',desc:'Id'}];let count=0;typeClass.attributes.forEach((meta,name)=>{if(count++>this.attributeLimit){return false;}const desc=this.columnNameToDesc(name);columns.push({name:name,desc:desc});});return columns;}/**\n    Fetches all loaded records for a given type\n     @method getRecords\n    @private\n    @param {Model} modelClass of the record\n    @param {String} modelName of the record\n    @return {Array} An array of Model records\n     This array will be observed for changes,\n     so it should update when new records are added/removed\n  */getRecords(modelClass,modelName){if(arguments.length<2){// Legacy Ember.js < 1.13 support\nconst containerKey=modelClass._debugContainerKey;if(containerKey){const match=containerKey.match(/model:(.*)/);if(match!==null){modelName=match[1];}}}(test=>{if(!test){throw new Error('Cannot find model name. Please upgrade to Ember.js >= 1.13 for Ember Inspector support');}})(!!modelName);return this.store.peekAll(modelName);}/**\n    Gets the values for each column\n    This is the attribute values for a given record\n     @method getRecordColumnValues\n    @private\n    @param {Model} record to get values from\n    @return {Object} Keys should match column names defined by the model type\n  */getRecordColumnValues(record){let count=0;const columnValues={id:record.id};record.eachAttribute(key=>{if(count++>this.attributeLimit){return false;}columnValues[key]=record[key];});return columnValues;}/**\n    Returns keywords to match when searching records\n     @method getRecordKeywords\n    @private\n    @param {Model} record\n    @return {Array} Relevant keywords for search based on the record's attribute values\n  */getRecordKeywords(record){const keywords=[record.id];record.eachAttribute(key=>{keywords.push(record[key]);});return (0,_ember_array__WEBPACK_IMPORTED_MODULE_0__.A)(keywords);}/**\n    Returns the values of filters defined by `getFilters`\n    These reflect the state of the record\n     @method getRecordFilterValues\n    @private\n    @param {Model} record\n    @return {Object} The record state filter values\n  */getRecordFilterValues(record){return{isNew:record.isNew,isModified:record.hasDirtyAttributes&&!record.isNew,isClean:!record.hasDirtyAttributes};}/**\n    Returns a color that represents the record's state\n    Possible colors: black, blue, green\n     @method getRecordColor\n    @private\n    @param {Model} record\n    @return {String} The record color\n  */getRecordColor(record){let color='black';if(record.isNew){color='green';}else if(record.hasDirtyAttributes){color='blue';}return color;}/**\n    Observes all relevant properties and re-sends the wrapped record\n    when a change occurs\n     @method observeRecord\n    @private\n    @param {Model} record\n    @param {Function} recordUpdated Callback used to notify changes\n    @return {Function} The function to call to remove all observers\n  */observeRecord(record,recordUpdated){const releaseMethods=[];const keysToObserve=['id','isNew','hasDirtyAttributes'];record.eachAttribute(key=>keysToObserve.push(key));keysToObserve.forEach(key=>{const handler=()=>{recordUpdated(this.wrapRecord(record));};(0,_ember_object_observers__WEBPACK_IMPORTED_MODULE_2__.addObserver)(record,key,handler);releaseMethods.push(function(){(0,_ember_object_observers__WEBPACK_IMPORTED_MODULE_2__.removeObserver)(record,key,handler);});});const release=function(){releaseMethods.forEach(fn=>fn());};return release;}}_InspectorDataAdapter=InspectorDataAdapter;decorateFieldV2(_InspectorDataAdapter.prototype,\"store\",[(0,_ember_service__WEBPACK_IMPORTED_MODULE_3__.inject)('store')]);const dataAdapter=InspectorDataAdapter;\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@ember-data/debug/dist/data-adapter.js?");

/***/ }),

/***/ "./node_modules/@ember-data/graph/dist/-private.js":
/*!*********************************************************!*\
  !*** ./node_modules/@ember-data/graph/dist/-private.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   graphFor: () => (/* binding */ graphFor),\n/* harmony export */   isBelongsTo: () => (/* binding */ isBelongsTo),\n/* harmony export */   peekGraph: () => (/* binding */ peekGraph)\n/* harmony export */ });\n/* harmony import */ var _ember_debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ember/debug */ \"@ember/debug\");\n/* harmony import */ var _ember_debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ember_debug__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ember_data_store_private__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ember-data/store/-private */ \"./node_modules/@ember-data/store/dist/-private.js\");\n/* harmony import */ var _warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @warp-drive/core-types/-private */ \"./node_modules/@warp-drive/core-types/dist/-private.js\");\nfunction coerceId(id){{let normalized;if(id===null||id===undefined||id===''){normalized=null;}else{normalized=String(id);}(0,_ember_debug__WEBPACK_IMPORTED_MODULE_0__.deprecate)(`The resource id '<${typeof id}> ${String(id)} ' is not normalized. Update your application code to use '${JSON.stringify(normalized)}' instead.`,normalized===id,{id:'ember-data:deprecate-non-strict-id',until:'6.0',for:'ember-data',since:{available:'5.3',enabled:'5.3'}});return normalized;}(test=>{if(!test){throw new Error(`Resource IDs must be a non-empty string or null. Received '${String(id)}'.`);}})(id===null||typeof id==='string'&&id.length>0);return id;}function getStore(wrapper){(test=>{if(!test){throw new Error(`expected a private _store property`);}})('_store'in wrapper);return wrapper._store;}function expandingGet(cache,key1,key2){const mainCache=cache[key1]=cache[key1]||Object.create(null);return mainCache[key2];}function expandingSet(cache,key1,key2,value){const mainCache=cache[key1]=cache[key1]||Object.create(null);mainCache[key2]=value;}function assertValidRelationshipPayload(graph,op){const relationship=graph.get(op.record,op.field);(test=>{if(!test){throw new Error(`Cannot update an implicit relationship`);}})(isHasMany(relationship)||isBelongsTo(relationship));const payload=op.value;const{definition,identifier,state}=relationship;const{type}=identifier;const{field}=op;const{isAsync,kind}=definition;if(payload.links){(0,_ember_debug__WEBPACK_IMPORTED_MODULE_0__.warn)(`You pushed a record of type '${type}' with a relationship '${field}' configured as 'async: false'. You've included a link but no primary data, this may be an error in your payload. EmberData will treat this relationship as known-to-be-empty.`,isAsync||!!payload.data||state.hasReceivedData,{id:'ds.store.push-link-for-sync-relationship'});}else if(payload.data){if(kind==='belongsTo'){(test=>{if(!test){throw new Error(`A ${type} record was pushed into the store with the value of ${field} being ${(0,_ember_debug__WEBPACK_IMPORTED_MODULE_0__.inspect)(payload.data)}, but ${field} is a belongsTo relationship so the value must not be an array. You should probably check your data payload or serializer.`);}})(!Array.isArray(payload.data));assertRelationshipData(getStore(graph.store),identifier,payload.data,definition);}else if(kind==='hasMany'){(test=>{if(!test){throw new Error(`A ${type} record was pushed into the store with the value of ${field} being '${(0,_ember_debug__WEBPACK_IMPORTED_MODULE_0__.inspect)(payload.data)}', but ${field} is a hasMany relationship so the value must be an array. You should probably check your data payload or serializer.`);}})(Array.isArray(payload.data));if(Array.isArray(payload.data)){for(let i=0;i<payload.data.length;i++){assertRelationshipData(getStore(graph.store),identifier,payload.data[i],definition);}}}}}function isNew(identifier){if(!identifier.id){return true;}const cache=(0,_ember_data_store_private__WEBPACK_IMPORTED_MODULE_1__.peekCache)(identifier);return Boolean(cache?.isNew(identifier));}function isBelongsTo(relationship){return relationship.definition.kind==='belongsTo';}function isImplicit(relationship){return relationship.definition.isImplicit;}function isHasMany(relationship){return relationship.definition.kind==='hasMany';}function forAllRelatedIdentifiers(rel,cb){if(isBelongsTo(rel)){if(rel.remoteState){cb(rel.remoteState);}if(rel.localState&&rel.localState!==rel.remoteState){cb(rel.localState);}}else if(isHasMany(rel)){// TODO\n// rel.remoteMembers.forEach(cb);\n// might be simpler if performance is not a concern\nfor(let i=0;i<rel.remoteState.length;i++){const inverseIdentifier=rel.remoteState[i];cb(inverseIdentifier);}rel.additions?.forEach(cb);}else{rel.localMembers.forEach(cb);rel.remoteMembers.forEach(inverseIdentifier=>{if(!rel.localMembers.has(inverseIdentifier)){cb(inverseIdentifier);}});}}/*\n  Removes the given identifier from BOTH remote AND local state.\n\n  This method is useful when either a deletion or a rollback on a new record\n  needs to entirely purge itself from an inverse relationship.\n  */function removeIdentifierCompletelyFromRelationship(graph,relationship,value,silenceNotifications){if(isBelongsTo(relationship)){if(relationship.remoteState===value){relationship.remoteState=null;}if(relationship.localState===value){relationship.localState=null;// This allows dematerialized inverses to be rematerialized\n// we shouldn't be notifying here though, figure out where\n// a notification was missed elsewhere.\n{notifyChange(graph,relationship.identifier,relationship.definition.key);}}}else if(isHasMany(relationship)){relationship.remoteMembers.delete(value);relationship.additions?.delete(value);const wasInRemovals=relationship.removals?.delete(value);const canonicalIndex=relationship.remoteState.indexOf(value);if(canonicalIndex!==-1){relationship.remoteState.splice(canonicalIndex,1);}if(!wasInRemovals){const currentIndex=relationship.localState?.indexOf(value);if(currentIndex!==-1&&currentIndex!==undefined){relationship.localState.splice(currentIndex,1);// This allows dematerialized inverses to be rematerialized\n// we shouldn't be notifying here though, figure out where\n// a notification was missed elsewhere.\n{notifyChange(graph,relationship.identifier,relationship.definition.key);}}}}else{relationship.remoteMembers.delete(value);relationship.localMembers.delete(value);}}// TODO add silencing at the graph level\nfunction notifyChange(graph,identifier,key){if(identifier===graph._removing){return;}graph.store.notifyChange(identifier,'relationships',key);}function assertRelationshipData(store,identifier,data,meta){(test=>{if(!test){throw new Error(`A ${identifier.type} record was pushed into the store with the value of ${meta.key} being '${JSON.stringify(data)}', but ${meta.key} is a belongsTo relationship so the value must not be an array. You should probably check your data payload or serializer.`);}})(!Array.isArray(data));(test=>{if(!test){throw new Error(`Encountered a relationship identifier without a type for the ${meta.kind} relationship '${meta.key}' on <${identifier.type}:${String(identifier.id)}>, expected an identifier with type '${meta.type}' but found\\n\\n'${JSON.stringify(data,null,2)}'\\n\\nPlease check your serializer and make sure it is serializing the relationship payload into a JSON API format.`);}})(data===null||'type'in data&&typeof data.type==='string'&&data.type.length);(test=>{if(!test){throw new Error(`Encountered a relationship identifier without an id for the ${meta.kind} relationship '${meta.key}' on <${identifier.type}:${String(identifier.id)}>, expected an identifier but found\\n\\n'${JSON.stringify(data,null,2)}'\\n\\nPlease check your serializer and make sure it is serializing the relationship payload into a JSON API format.`);}})(data===null||!!coerceId(data.id));if(data?.type===meta.type){(test=>{if(!test){throw new Error(`Missing Schema: Encountered a relationship identifier { type: '${data.type}', id: '${String(data.id)}' } for the '${identifier.type}.${meta.key}' ${meta.kind} relationship on <${identifier.type}:${String(identifier.id)}>, but no schema exists for that type.`);}})(store.schema.hasResource(data));}else{(test=>{if(!test){throw new Error(`Missing Schema: Encountered a relationship identifier with type '${data.type}' for the ${meta.kind} relationship '${meta.key}' on <${identifier.type}:${String(identifier.id)}>, Expected an identifier with type '${meta.type}'. No schema was found for '${data.type}'.`);}})(data===null||!data.type||store.schema.hasResource(data));}}const RELATIONSHIP_KINDS=['belongsTo','hasMany','resource','collection'];function isLegacyField(field){return field.kind==='belongsTo'||field.kind==='hasMany';}function isRelationshipField(field){return RELATIONSHIP_KINDS.includes(field.kind);}function temporaryConvertToLegacy(field){return{kind:field.kind==='resource'?'belongsTo':'hasMany',name:field.name,type:field.type,options:Object.assign({},{async:false,inverse:null,resetOnRemoteUpdate:false},field.options)};}/**\n *\n * Given RHS (Right Hand Side)\n *\n * ```ts\n * class User extends Model {\n *   @hasMany('animal', { async: false, inverse: 'owner' }) pets;\n * }\n * ```\n *\n * Given LHS (Left Hand Side)\n *\n * ```ts\n * class Animal extends Model {\n *  @belongsTo('user', { async: false, inverse: 'pets' }) owner;\n * }\n * ```\n *\n * The UpgradedMeta for the RHS would be:\n *\n * ```ts\n * {\n *   kind: 'hasMany',\n *   key: 'pets',\n *   type: 'animal',\n *   isAsync: false,\n *   isImplicit: false,\n *   isCollection: true,\n *   isPolymorphic: false,\n *   inverseKind: 'belongsTo',\n *   inverseKey: 'owner',\n *   inverseType: 'user',\n *   inverseIsAsync: false,\n *   inverseIsImplicit: false,\n *   inverseIsCollection: false,\n *   inverseIsPolymorphic: false,\n * }\n * ```\n *\n * The UpgradeMeta for the LHS would be:\n *\n * ```ts\n * {\n *   kind: 'belongsTo',\n *   key: 'owner',\n *   type: 'user',\n *   isAsync: false,\n *   isImplicit: false,\n *   isCollection: false,\n *   isPolymorphic: false,\n *   inverseKind: 'hasMany',\n *   inverseKey: 'pets',\n *   inverseType: 'animal',\n *   inverseIsAsync: false,\n *   inverseIsImplicit: false,\n *   inverseIsCollection: true,\n *   inverseIsPolymorphic: false,\n * }\n * ```\n *\n *\n * @class UpgradedMeta\n * @internal\n */const BOOL_LATER=null;const STR_LATER='';const IMPLICIT_KEY_RAND=Date.now();function implicitKeyFor(type,key){return`implicit-${type}:${key}${IMPLICIT_KEY_RAND}`;}function syncMeta(definition,inverseDefinition){definition.inverseKind=inverseDefinition.kind;definition.inverseKey=inverseDefinition.key;definition.inverseType=inverseDefinition.type;definition.inverseIsAsync=inverseDefinition.isAsync;definition.inverseIsCollection=inverseDefinition.isCollection;definition.inverseIsPolymorphic=inverseDefinition.isPolymorphic;definition.inverseIsImplicit=inverseDefinition.isImplicit;const resetOnRemoteUpdate=definition.resetOnRemoteUpdate===false||inverseDefinition.resetOnRemoteUpdate===false?false:true;definition.resetOnRemoteUpdate=resetOnRemoteUpdate;inverseDefinition.resetOnRemoteUpdate=resetOnRemoteUpdate;}function upgradeMeta(meta){if(!isLegacyField(meta)){meta=temporaryConvertToLegacy(meta);}const niceMeta={};const options=meta.options;niceMeta.kind=meta.kind;niceMeta.key=meta.name;niceMeta.type=meta.type;(test=>{if(!test){throw new Error(`Expected relationship definition to specify async`);}})(typeof options?.async==='boolean');niceMeta.isAsync=options.async;niceMeta.isImplicit=false;niceMeta.isCollection=meta.kind==='hasMany';niceMeta.isPolymorphic=options&&!!options.polymorphic;niceMeta.inverseKey=options&&options.inverse||STR_LATER;niceMeta.inverseType=STR_LATER;niceMeta.inverseIsAsync=BOOL_LATER;niceMeta.inverseIsImplicit=options&&options.inverse===null||BOOL_LATER;niceMeta.inverseIsCollection=BOOL_LATER;niceMeta.resetOnRemoteUpdate=isLegacyField(meta)?meta.options?.resetOnRemoteUpdate===false?false:true:false;return niceMeta;}function assertConfiguration(info,type,key){{const isSelfReferential=info.isSelfReferential;if(isSelfReferential){return true;}const _isRHS=key===info.rhs_relationshipName&&(type===info.rhs_baseModelName||// base or non-polymorphic\n// if the other side is polymorphic then we need to scan our modelNames\ninfo.lhs_isPolymorphic&&info.rhs_modelNames.includes(type));// polymorphic\nconst _isLHS=key===info.lhs_relationshipName&&(type===info.lhs_baseModelName||// base or non-polymorphic\n// if the other side is polymorphic then we need to scan our modelNames\ninfo.rhs_isPolymorphic&&info.lhs_modelNames.includes(type));// polymorphic;\nif(!_isRHS&&!_isLHS){/*\n        this occurs when we are likely polymorphic but not configured to be polymorphic\n        most often due to extending a class that has a relationship definition on it.\n         e.g.\n         ```ts\n        class Pet extends Model {\n          @belongsTo('human', { async: false, inverse: 'pet' }) owner;\n        }\n        class Human extends Model {\n          @belongsTo('pet', { async: false, inverse: 'owner' }) pet;\n        }\n        class Farmer extends Human {}\n        ```\n         In the above case, the following would trigger this error:\n         ```ts\n        let pet = store.createRecord('pet');\n        let farmer = store.createRecord('farmer');\n        farmer.pet = pet; // error\n        ```\n         The correct way to fix this is to specify the polymorphic option on Pet\n        and to specify the abstract type 'human' on the Human base class.\n         ```ts\n        class Pet extends Model {\n          @belongsTo('human', { async: false, inverse: 'pet', polymorphic: true }) owner;\n        }\n        class Human extends Model {\n          @belongsTo('pet', { async: false, inverse: 'owner', as: 'human' }) pet;\n        }\n        class Farmer extends Human {}\n        ```\n         Alternatively both Human and Farmer could declare the relationship, because relationship\n        definitions are \"structural\".\n         ```ts\n        class Pet extends Model {\n          @belongsTo('human', { async: false, inverse: 'pet', polymorphic: true }) owner;\n        }\n        class Human extends Model {\n          @belongsTo('pet', { async: false, inverse: 'owner', as: 'human' }) pet;\n        }\n        class Farmer extends Model {\n          @belongsTo('pet', { async: false, inverse: 'owner', as: 'human' }) pet;\n        }\n        ```\n        */if(key===info.lhs_relationshipName&&info.lhs_modelNames.includes(type)){// parentIdentifier, parentDefinition, addedIdentifier, store\nassertInheritedSchema(info.lhs_definition,type);}else if(key===info.rhs_relationshipName&&info.rhs_modelNames.includes(type)){assertInheritedSchema(info.lhs_definition,type);}// OPEN AN ISSUE :: we would like to improve our errors but need to understand what corner case got us here\nthrow new Error(`PLEASE OPEN AN ISSUE :: Found a relationship that is neither the LHS nor RHS of the same edge. This is not supported. Please report this to the EmberData team.`);}if(_isRHS&&_isLHS){// not sure how we get here but it's probably the result of some form of inheritance\n// without having specified polymorphism correctly leading to it not being self-referential\n// OPEN AN ISSUE :: we would like to improve our errors but need to understand what corner case got us here\nthrow new Error(`PLEASE OPEN AN ISSUE :: Found a relationship that is both the LHS and RHS of the same edge but is not self-referential. This is not supported. Please report this to the EmberData team.`);}}}function isLHS(info,type,key){const isSelfReferential=info.isSelfReferential;const isRelationship=key===info.lhs_relationshipName;{assertConfiguration(info,type,key);}if(isRelationship===true){return isSelfReferential===true||// itself\ntype===info.lhs_baseModelName||// base or non-polymorphic\n// if the other side is polymorphic then we need to scan our modelNames\ninfo.rhs_isPolymorphic&&info.lhs_modelNames.includes(type)// polymorphic\n;}return false;}function upgradeDefinition(graph,identifier,propertyName,isImplicit=false){const cache=graph._definitionCache;const storeWrapper=graph.store;const polymorphicLookup=graph._potentialPolymorphicTypes;const{type}=identifier;let cached=/*#__NOINLINE__*/expandingGet(cache,type,propertyName);// CASE: We have a cached resolution (null if no relationship exists)\nif(cached!==undefined){return cached;}(test=>{if(!test){throw new Error(`Expected to find relationship definition in the cache for the implicit relationship ${propertyName}`);}})(!isImplicit);const relationships=storeWrapper.schema.fields(identifier);(test=>{if(!test){throw new Error(`Expected to have a relationship definition for ${type} but none was found.`);}})(relationships);const meta=relationships.get(propertyName);if(!meta){// TODO potentially we should just be permissive here since this is an implicit relationship\n// and not require the lookup table to be populated\nif(polymorphicLookup[type]){const altTypes=Object.keys(polymorphicLookup[type]);for(let i=0;i<altTypes.length;i++){const _cached=expandingGet(cache,altTypes[i],propertyName);if(_cached){/*#__NOINLINE__*/expandingSet(cache,type,propertyName,_cached);_cached.rhs_modelNames.push(type);return _cached;}}}// CASE: We don't have a relationship at all\n// we should only hit this in prod\n(test=>{if(!test){throw new Error(`Expected a relationship schema for '${type}.${propertyName}', but no relationship schema was found.`);}})(meta);cache[type][propertyName]=null;return null;}(test=>{if(!test){throw new Error(`Expected ${propertyName} to be a relationship`);}})(isRelationshipField(meta));const definition=/*#__NOINLINE__*/upgradeMeta(meta);let inverseDefinition;let inverseKey;const inverseType=definition.type;// CASE: Inverse is explicitly null\nif(definition.inverseKey===null){// TODO probably dont need this assertion if polymorphic\n(test=>{if(!test){throw new Error(`Expected the inverse model to exist`);}})(getStore(storeWrapper).modelFor(inverseType));inverseDefinition=null;}else{inverseKey=/*#__NOINLINE__*/inverseForRelationship(getStore(storeWrapper),identifier,propertyName);// CASE: If we are polymorphic, and we declared an inverse that is non-null\n// we must assume that the lack of inverseKey means that there is no\n// concrete type as the baseType, so we must construct and artificial\n// placeholder\nif(!inverseKey&&definition.isPolymorphic&&definition.inverseKey){inverseDefinition={kind:'belongsTo',// this must be updated when we find the first belongsTo or hasMany definition that matches\nkey:definition.inverseKey,type:type,isAsync:false,// this must be updated when we find the first belongsTo or hasMany definition that matches\nisImplicit:false,isCollection:false,// this must be updated when we find the first belongsTo or hasMany definition that matches\nisPolymorphic:false};// the rest of the fields are populated by syncMeta\n// CASE: Inverse resolves to null\n}else if(!inverseKey){inverseDefinition=null;}else{// CASE: We have an explicit inverse or were able to resolve one\nconst inverseDefinitions=storeWrapper.schema.fields({type:inverseType});(test=>{if(!test){throw new Error(`Expected to have a relationship definition for ${inverseType} but none was found.`);}})(inverseDefinitions);const metaFromInverse=inverseDefinitions.get(inverseKey);(test=>{if(!test){throw new Error(`Expected a relationship schema for '${inverseType}.${inverseKey}' to match the inverse of '${type}.${propertyName}', but no relationship schema was found.`);}})(metaFromInverse);(test=>{if(!test){throw new Error(`Expected ${inverseKey} to be a relationship`);}})(isRelationshipField(metaFromInverse));inverseDefinition=upgradeMeta(metaFromInverse);}}// CASE: We have no inverse\nif(!inverseDefinition){// polish off meta\ninverseKey=/*#__NOINLINE__*/implicitKeyFor(type,propertyName);inverseDefinition={kind:'implicit',key:inverseKey,type:type,isAsync:false,isImplicit:true,isCollection:true,// with implicits any number of records could point at us\nisPolymorphic:false};// the rest of the fields are populated by syncMeta\nsyncMeta(definition,inverseDefinition);syncMeta(inverseDefinition,definition);const info={lhs_key:`${type}:${propertyName}`,lhs_modelNames:[type],lhs_baseModelName:type,lhs_relationshipName:propertyName,lhs_definition:definition,lhs_isPolymorphic:definition.isPolymorphic,rhs_key:inverseDefinition.key,rhs_modelNames:[inverseType],rhs_baseModelName:inverseType,rhs_relationshipName:inverseDefinition.key,rhs_definition:inverseDefinition,rhs_isPolymorphic:false,hasInverse:false,isSelfReferential:type===inverseType,// this could be wrong if we are self-referential but also polymorphic\nisReflexive:false// we can't be reflexive if we don't define an inverse\n};expandingSet(cache,inverseType,inverseKey,info);expandingSet(cache,type,propertyName,info);return info;}// CASE: We do have an inverse\nconst baseType=inverseDefinition.type;// TODO we want to assert this but this breaks all of our shoddily written tests\n/*\n    if (DEBUG) {\n      let inverseDoubleCheck = inverseFor(inverseRelationshipName, store);\n       assert(`The ${inverseBaseModelName}:${inverseRelationshipName} relationship declares 'inverse: null', but it was resolved as the inverse for ${baseModelName}:${relationshipName}.`, inverseDoubleCheck);\n    }\n  */// CASE: We may have already discovered the inverse for the baseModelName\n// CASE: We have already discovered the inverse\n(test=>{if(!test){throw new Error(`We should have determined an inverseKey by now, open an issue if this is hit`);}})(typeof inverseKey==='string'&&inverseKey.length>0);cached=expandingGet(cache,baseType,propertyName)||expandingGet(cache,inverseType,inverseKey);if(cached){// TODO this assert can be removed if the above assert is enabled\n(test=>{if(!test){throw new Error(`The ${inverseType}:${inverseKey} relationship declares 'inverse: null', but it was resolved as the inverse for ${type}:${propertyName}.`);}})(cached.hasInverse!==false);const _isLHS=cached.lhs_baseModelName===baseType;const modelNames=_isLHS?cached.lhs_modelNames:cached.rhs_modelNames;// make this lookup easier in the future by caching the key\nmodelNames.push(type);expandingSet(cache,type,propertyName,cached);return cached;}// this is our first time so polish off the metas\nsyncMeta(definition,inverseDefinition);syncMeta(inverseDefinition,definition);const lhs_modelNames=[type];if(type!==baseType){lhs_modelNames.push(baseType);}const isSelfReferential=baseType===inverseType;const info={lhs_key:`${baseType}:${propertyName}`,lhs_modelNames,lhs_baseModelName:baseType,lhs_relationshipName:propertyName,lhs_definition:definition,lhs_isPolymorphic:definition.isPolymorphic,rhs_key:`${inverseType}:${inverseKey}`,rhs_modelNames:[inverseType],rhs_baseModelName:inverseType,rhs_relationshipName:inverseKey,rhs_definition:inverseDefinition,rhs_isPolymorphic:inverseDefinition.isPolymorphic,hasInverse:true,isSelfReferential,isReflexive:isSelfReferential&&propertyName===inverseKey};// Create entries for the baseModelName as well as modelName to speed up\n//  inverse lookups\nexpandingSet(cache,baseType,propertyName,info);expandingSet(cache,type,propertyName,info);// Greedily populate the inverse\nexpandingSet(cache,inverseType,inverseKey,info);return info;}function inverseForRelationship(store,identifier,key){const definition=store.schema.fields(identifier).get(key);if(!definition){return null;}(test=>{if(!test){throw new Error(`Expected ${key} to be a relationship`);}})(isRelationshipField(definition));(test=>{if(!test){throw new Error(`Expected the relationship defintion to specify the inverse type or null.`);}})(definition.options?.inverse===null||typeof definition.options?.inverse==='string'&&definition.options.inverse.length>0);return definition.options.inverse;}/* eslint-disable @typescript-eslint/no-shadow */let assertPolymorphicType;let assertInheritedSchema;{function validateSchema(definition,meta){const errors=new Map();if(definition.inverseKey!==meta.name){errors.set('name',` <---- should be '${definition.inverseKey}'`);}if(definition.inverseType!==meta.type){errors.set('type',` <---- should be '${definition.inverseType}'`);}if(definition.inverseKind!==meta.kind){errors.set('type',` <---- should be '${definition.inverseKind}'`);}if(definition.inverseIsAsync!==meta.options.async){errors.set('async',` <---- should be ${definition.inverseIsAsync}`);}if(definition.inverseIsPolymorphic&&definition.inverseIsPolymorphic!==meta.options.polymorphic){errors.set('polymorphic',` <---- should be ${definition.inverseIsPolymorphic}`);}if(definition.key!==meta.options.inverse){errors.set('inverse',` <---- should be '${definition.key}'`);}if(definition.type!==meta.options.as){errors.set('as',` <---- should be '${definition.type}'`);}return errors;}function expectedSchema(definition){return printSchema({name:definition.inverseKey,type:definition.inverseType,kind:definition.inverseKind,options:{as:definition.type,async:definition.inverseIsAsync,polymorphic:definition.inverseIsPolymorphic||false,inverse:definition.key}});}function printSchema(config,errors){return`\n\n\\`\\`\\`\n{\n  ${config.name}: {\n    name: '${config.name}',${errors?.get('name')||''}\n    type: '${config.type}',${errors?.get('type')||''}\n    kind: '${config.kind}',${errors?.get('kind')||''}\n    options: {\n      as: '${config.options.as}',${errors?.get('as')||''}\n      async: ${config.options.async},${errors?.get('async')||''}\n      polymorphic: ${config.options.polymorphic},${errors?.get('polymorphic')||''}\n      inverse: '${config.options.inverse}'${errors?.get('inverse')||''}\n    }\n  }\n}\n\\`\\`\\`\n\n`;}function metaFrom(definition){return{name:definition.key,type:definition.type,kind:definition.kind,options:{async:definition.isAsync,polymorphic:definition.isPolymorphic,inverse:definition.inverseKey}};}function inverseMetaFrom(definition){return{name:definition.inverseKey,type:definition.inverseType,kind:definition.inverseKind,options:{as:definition.isPolymorphic?definition.type:undefined,async:definition.inverseIsAsync,polymorphic:definition.inverseIsPolymorphic,inverse:definition.key}};}function inverseDefinition(definition){return{key:definition.inverseKey,type:definition.inverseType,kind:definition.inverseKind,isAsync:definition.inverseIsAsync,isPolymorphic:true,isCollection:definition.inverseIsCollection,isImplicit:definition.inverseIsImplicit,inverseKey:definition.key,inverseType:definition.type,inverseKind:definition.kind,inverseIsAsync:definition.isAsync,inverseIsPolymorphic:definition.isPolymorphic,inverseIsImplicit:definition.isImplicit,inverseIsCollection:definition.isCollection,resetOnRemoteUpdate:definition.resetOnRemoteUpdate};}function definitionWithPolymorphic(definition){return Object.assign({},definition,{inverseIsPolymorphic:true});}assertInheritedSchema=function assertInheritedSchema(definition,type){const meta1=metaFrom(definition);const meta2=inverseMetaFrom(definition);const errors1=validateSchema(inverseDefinition(definition),meta1);const errors2=validateSchema(definitionWithPolymorphic(definition),meta2);if(errors2.size===0&&errors1.size>0){throw new Error(`The schema for the relationship '${type}.${definition.key}' is not configured to satisfy '${definition.inverseType}' and thus cannot utilize the '${definition.inverseType}.${definition.key}' relationship to connect with '${definition.type}.${definition.inverseKey}'\\n\\nIf using this relationship in a polymorphic manner is desired, the relationships schema definition for '${type}' should include:${printSchema(meta1,errors1)}`);}else if(errors1.size>0){throw new Error(`The schema for the relationship '${type}.${definition.key}' is not configured to satisfy '${definition.inverseType}' and thus cannot utilize the '${definition.inverseType}.${definition.key}' relationship to connect with '${definition.type}.${definition.inverseKey}'\\n\\nIf using this relationship in a polymorphic manner is desired, the relationships schema definition for '${type}' should include:${printSchema(meta1,errors1)} and the relationships schema definition for '${definition.type}' should include:${printSchema(meta2,errors2)}`);}else if(errors2.size>0){throw new Error(`The schema for the relationship '${type}.${definition.key}' satisfies '${definition.inverseType}' but cannot utilize the '${definition.inverseType}.${definition.key}' relationship to connect with '${definition.type}.${definition.inverseKey}' because that relationship is not polymorphic.\\n\\nIf using this relationship in a polymorphic manner is desired, the relationships schema definition for '${definition.type}' should include:${printSchema(meta2,errors2)}`);}};assertPolymorphicType=function assertPolymorphicType(parentIdentifier,parentDefinition,addedIdentifier,store){if(parentDefinition.inverseIsImplicit){return;}if(parentDefinition.isPolymorphic){let meta=store.schema.fields(addedIdentifier).get(parentDefinition.inverseKey);(test=>{if(!test){throw new Error(`No '${parentDefinition.inverseKey}' field exists on '${addedIdentifier.type}'. To use this type in the polymorphic relationship '${parentDefinition.inverseType}.${parentDefinition.key}' the relationships schema definition for ${addedIdentifier.type} should include:${expectedSchema(parentDefinition)}`);}})(meta);(test=>{if(!test){throw new Error(`Expected the field ${parentDefinition.inverseKey} to be a relationship`);}})(meta&&isRelationshipField(meta));meta=isLegacyField(meta)?meta:temporaryConvertToLegacy(meta);(test=>{if(!test){throw new Error(`You should not specify both options.as and options.inverse as null on ${addedIdentifier.type}.${parentDefinition.inverseKey}, as if there is no inverse field there is no abstract type to conform to. You may have intended for this relationship to be polymorphic, or you may have mistakenly set inverse to null.`);}})(!(meta.options.inverse===null&&meta?.options.as?.length));const errors=validateSchema(parentDefinition,meta);(test=>{if(!test){throw new Error(`The schema for the relationship '${parentDefinition.inverseKey}' on '${addedIdentifier.type}' type does not correctly implement '${parentDefinition.type}' and thus cannot be assigned to the '${parentDefinition.key}' relationship in '${parentIdentifier.type}'. If using this record in this polymorphic relationship is desired, correct the errors in the schema shown below:${printSchema(meta,errors)}`);}})(errors.size===0);}else if(addedIdentifier.type!==parentDefinition.type){// if we are not polymorphic\n// then the addedIdentifier.type must be the same as the parentDefinition.type\nlet meta=store.schema.fields(addedIdentifier).get(parentDefinition.inverseKey);(test=>{if(!test){throw new Error(`Expected the field ${parentDefinition.inverseKey} to be a relationship`);}})(!meta||isRelationshipField(meta));meta=meta&&(isLegacyField(meta)?meta:temporaryConvertToLegacy(meta));if(meta?.options.as===parentDefinition.type){// inverse is likely polymorphic but missing the polymorphic flag\nlet meta=store.schema.fields({type:parentDefinition.inverseType}).get(parentDefinition.key);(test=>{if(!test){throw new Error(`Expected the field ${parentDefinition.key} to be a relationship`);}})(meta&&isRelationshipField(meta));meta=isLegacyField(meta)?meta:temporaryConvertToLegacy(meta);const errors=validateSchema(definitionWithPolymorphic(inverseDefinition(parentDefinition)),meta);(test=>{{throw new Error(`The '<${addedIdentifier.type}>.${parentDefinition.inverseKey}' relationship cannot be used polymorphically because '<${parentDefinition.inverseType}>.${parentDefinition.key} is not a polymorphic relationship. To use this relationship in a polymorphic manner, fix the following schema issues on the relationships schema for '${parentDefinition.inverseType}':${printSchema(meta,errors)}`);}})();}else{(test=>{{throw new Error(`The '${addedIdentifier.type}' type does not implement '${parentDefinition.type}' and thus cannot be assigned to the '${parentDefinition.key}' relationship in '${parentIdentifier.type}'. If this relationship should be polymorphic, mark ${parentDefinition.inverseType}.${parentDefinition.key} as \\`polymorphic: true\\` and ${addedIdentifier.type}.${parentDefinition.inverseKey} as implementing it via \\`as: '${parentDefinition.type}'\\`.`);}})();}}};}/*\n    case many:1\n    ========\n    In a bi-directional graph with Many:1 edges, adding a value\n    results in up-to 3 discrete value transitions, while removing\n    a value is only 2 transitions.\n\n    For adding C to A\n    If: A <<-> B, C <->> D is the initial state,\n    and: B <->> A <<-> C, D is the final state\n\n    then we would undergo the following transitions.\n\n    add C to A\n    remove C from D\n    add A to C\n\n    For removing B from A\n    If: A <<-> B, C <->> D is the initial state,\n    and: A, B, C <->> D is the final state\n\n    then we would undergo the following transitions.\n\n    remove B from A\n    remove A from B\n\n    case many:many\n    ===========\n    In a bi-directional graph with Many:Many edges, adding or\n    removing a value requires only 2 value transitions.\n\n    For Adding\n    If: A<<->>B, C<<->>D is the initial state (double arrows representing the many side)\n    And: D<<->>C<<->>A<<->>B is the final state\n\n    Then we would undergo two transitions.\n\n    add C to A.\n    add A to C\n\n    For Removing\n    If: A<<->>B, C<<->>D is the initial state (double arrows representing the many side)\n    And: A, B, C<<->>D is the final state\n\n    Then we would undergo two transitions.\n\n    remove B from A\n    remove A from B\n\n    case many:?\n    ========\n    In a uni-directional graph with Many:? edges (modeled in EmberData with `inverse:null`) with\n    artificial (implicit) inverses, replacing a value results in 2 discrete value transitions.\n    This is because a Many:? relationship is effectively Many:Many.\n  */function replaceRelatedRecords(graph,op,isRemote){if(isRemote){replaceRelatedRecordsRemote(graph,op,isRemote);}else{replaceRelatedRecordsLocal(graph,op,isRemote);}}function replaceRelatedRecordsLocal(graph,op,isRemote){const identifiers=op.value;const relationship=graph.get(op.record,op.field);(test=>{if(!test){throw new Error(`expected hasMany relationship`);}})(isHasMany(relationship));// relationships for newly created records begin in the dirty state, so if updated\n// before flushed we would fail to notify. This check helps us avoid that.\nconst isMaybeFirstUpdate=relationship.remoteState.length===0&&relationship.localState===null&&relationship.state.hasReceivedData===false;relationship.state.hasReceivedData=true;const{additions,removals}=relationship;const{inverseKey,type}=relationship.definition;const{record}=op;const wasDirty=relationship.isDirty;relationship.isDirty=false;const onAdd=identifier=>{// Since we are diffing against the remote state, we check\n// if our previous local state did not contain this identifier\nconst removalsHas=removals?.has(identifier);if(removalsHas||!additions?.has(identifier)){if(type!==identifier.type){{assertPolymorphicType(relationship.identifier,relationship.definition,identifier,graph.store);}graph.registerPolymorphicType(type,identifier.type);}relationship.isDirty=true;addToInverse(graph,identifier,inverseKey,op.record,isRemote);if(removalsHas){removals.delete(identifier);}}};const onRemove=identifier=>{// Since we are diffing against the remote state, we check\n// if our previous local state had contained this identifier\nconst additionsHas=additions?.has(identifier);if(additionsHas||!removals?.has(identifier)){relationship.isDirty=true;removeFromInverse(graph,identifier,inverseKey,record,isRemote);if(additionsHas){additions.delete(identifier);}}};const diff=diffCollection(identifiers,relationship,onAdd,onRemove);// eslint-disable-next-line @typescript-eslint/no-unused-vars\nrelationship.isDirty||diff.changed;// any additions no longer in the local state\n// need to be removed from the inverse\nif(additions&&additions.size>0){additions.forEach(identifier=>{if(!diff.add.has(identifier)){onRemove(identifier);}});}// any removals no longer in the local state\n// need to be added back to the inverse\nif(removals&&removals.size>0){removals.forEach(identifier=>{if(!diff.del.has(identifier)){onAdd(identifier);}});}relationship.additions=diff.add;relationship.removals=diff.del;relationship.localState=diff.finalState;relationship.isDirty=wasDirty;if(isMaybeFirstUpdate||!wasDirty/*&& becameDirty // TODO to guard like this we need to detect reorder when diffing local */){notifyChange(graph,op.record,op.field);}}function replaceRelatedRecordsRemote(graph,op,isRemote){const identifiers=op.value;const relationship=graph.get(op.record,op.field);(test=>{if(!test){throw new Error(`You can only '${op.op}' on a hasMany relationship. ${op.record.type}.${op.field} is a ${relationship.definition.kind}`);}})(isHasMany(relationship));if(isRemote){graph._addToTransaction(relationship);}relationship.state.hasReceivedData=true;// cache existing state\nconst{definition}=relationship;const{type}=relationship.definition;const diff=diffCollection(identifiers,relationship,identifier=>{if(type!==identifier.type){{assertPolymorphicType(relationship.identifier,relationship.definition,identifier,graph.store);}graph.registerPolymorphicType(type,identifier.type);}// commit additions\n// TODO build this into the diff?\n// because we are not dirty if this was a committed local addition\nif(relationship.additions?.has(identifier)){relationship.additions.delete(identifier);}else{relationship.isDirty=true;}addToInverse(graph,identifier,definition.inverseKey,op.record,isRemote);},identifier=>{// commit removals\n// TODO build this into the diff?\n// because we are not dirty if this was a committed local addition\nif(relationship.removals?.has(identifier)){relationship.removals.delete(identifier);}else{relationship.isDirty=true;}removeFromInverse(graph,identifier,definition.inverseKey,op.record,isRemote);});// replace existing state\nrelationship.remoteMembers=diff.finalSet;relationship.remoteState=diff.finalState;// changed also indicates a change in order\nif(diff.changed){relationship.isDirty=true;}// TODO unsure if we need this but it\n// may allow us to more efficiently patch\n// the associated ManyArray\nrelationship._diff=diff;{// only do this for legacy hasMany, not collection\n// and provide a way to incrementally migrate\nif(relationship.definition.kind==='hasMany'&&relationship.definition.resetOnRemoteUpdate!==false){const deprecationInfo={removals:[],additions:[],triggered:false};if(relationship.removals){relationship.isDirty=true;relationship.removals.forEach(identifier=>{deprecationInfo.triggered=true;deprecationInfo.removals.push(identifier);// reverse the removal\n// if we are still in removals at this point then\n// we were not \"committed\" which means we are present\n// in the remoteMembers. So we \"add back\" on the inverse.\naddToInverse(graph,identifier,definition.inverseKey,op.record,isRemote);});relationship.removals=null;}if(relationship.additions){relationship.additions.forEach(identifier=>{// reverse the addition\n// if we are still in additions at this point then\n// we were not \"committed\" which means we are not present\n// in the remoteMembers. So we \"remove\" from the inverse.\n// however we only do this if we are not a \"new\" record.\nif(!isNew(identifier)){deprecationInfo.triggered=true;deprecationInfo.additions.push(identifier);relationship.isDirty=true;relationship.additions.delete(identifier);removeFromInverse(graph,identifier,definition.inverseKey,op.record,isRemote);}});if(relationship.additions.size===0){relationship.additions=null;}}if(deprecationInfo.triggered){(0,_ember_debug__WEBPACK_IMPORTED_MODULE_0__.deprecate)(`EmberData is changing the default semantics of updates to the remote state of relationships.\\n\\nThe following local state was cleared from the <${relationship.identifier.type}>.${relationship.definition.key} hasMany relationship but will not be once this deprecation is resolved by opting into the new behavior:\\n\\n\\tAdded: [${deprecationInfo.additions.map(i=>i.lid).join(', ')}]\\n\\tRemoved: [${deprecationInfo.removals.map(i=>i.lid).join(', ')}]`,false,{id:'ember-data:deprecate-relationship-remote-update-clearing-local-state',for:'ember-data',since:{enabled:'5.3',available:'5.3'},until:'6.0',url:'https://deprecations.emberjs.com/v5.x#ember-data-deprecate-relationship-remote-update-clearing-local-state'});}}}if(relationship.isDirty){flushCanonical(graph,relationship);}}function addToInverse(graph,identifier,key,value,isRemote){const relationship=graph.get(identifier,key);const{type}=relationship.definition;if(type!==value.type){{assertPolymorphicType(relationship.identifier,relationship.definition,value,graph.store);}graph.registerPolymorphicType(type,value.type);}if(isBelongsTo(relationship)){relationship.state.hasReceivedData=true;relationship.state.isEmpty=false;if(isRemote){graph._addToTransaction(relationship);if(relationship.remoteState!==null){removeFromInverse(graph,relationship.remoteState,relationship.definition.inverseKey,identifier,isRemote);}relationship.remoteState=value;}if(relationship.localState!==value){if(!isRemote&&relationship.localState){removeFromInverse(graph,relationship.localState,relationship.definition.inverseKey,identifier,isRemote);}relationship.localState=value;notifyChange(graph,identifier,key);}}else if(isHasMany(relationship)){if(isRemote){// TODO this needs to alert stuffs\n// And patch state better\n// This is almost definitely wrong\n// WARNING WARNING WARNING\nif(!relationship.remoteMembers.has(value)){graph._addToTransaction(relationship);relationship.remoteState.push(value);relationship.remoteMembers.add(value);if(relationship.additions?.has(value)){relationship.additions.delete(value);}else{relationship.isDirty=true;relationship.state.hasReceivedData=true;flushCanonical(graph,relationship);}}}else{if(_addLocal(graph,identifier,relationship,value,null)){notifyChange(graph,identifier,key);}}}else{if(isRemote){if(!relationship.remoteMembers.has(value)){relationship.remoteMembers.add(value);relationship.localMembers.add(value);}}else{if(!relationship.localMembers.has(value)){relationship.localMembers.add(value);}}}}function notifyInverseOfPotentialMaterialization(graph,identifier,key,value,isRemote){const relationship=graph.get(identifier,key);if(isHasMany(relationship)&&isRemote&&relationship.remoteMembers.has(value)){notifyChange(graph,identifier,key);}}function removeFromInverse(graph,identifier,key,value,isRemote){const relationship=graph.get(identifier,key);if(isBelongsTo(relationship)){relationship.state.isEmpty=true;if(isRemote){graph._addToTransaction(relationship);relationship.remoteState=null;}if(relationship.localState===value){relationship.localState=null;notifyChange(graph,identifier,key);}}else if(isHasMany(relationship)){if(isRemote){graph._addToTransaction(relationship);if(_removeRemote(relationship,value)){notifyChange(graph,identifier,key);}}else{if(_removeLocal(relationship,value)){notifyChange(graph,identifier,key);}}}else{if(isRemote){relationship.remoteMembers.delete(value);relationship.localMembers.delete(value);}else{if(value&&relationship.localMembers.has(value)){relationship.localMembers.delete(value);}}}}function flushCanonical(graph,rel){graph._scheduleLocalSync(rel);}function replaceRelatedRecord(graph,op,isRemote=false){const relationship=graph.get(op.record,op.field);(test=>{if(!test){throw new Error(`You can only '${op.op}' on a belongsTo relationship. ${op.record.type}.${op.field} is a ${relationship.definition.kind}`);}})(isBelongsTo(relationship));if(isRemote){graph._addToTransaction(relationship);}const{definition,state}=relationship;const prop=isRemote?'remoteState':'localState';const existingState=relationship[prop];/*\n    case 1:1\n    ========\n    In a bi-directional graph with 1:1 edges, replacing a value\n    results in up-to 4 discrete value transitions.\n     If: A <-> B, C <-> D is the initial state,\n    and: A <-> C, B, D is the final state\n     then we would undergo the following 4 transitions.\n     remove A from B\n    add C to A\n    remove C from D\n    add A to C\n     case 1:many\n    ===========\n    In a bi-directional graph with 1:Many edges, replacing a value\n    results in up-to 3 discrete value transitions.\n     If: A<->>B<<->D, C<<->D is the initial state (double arrows representing the many side)\n    And: A<->>C<<->D, B<<->D is the final state\n     Then we would undergo three transitions.\n     remove A from B\n    add C to A.\n    add A to C\n     case 1:?\n    ========\n    In a uni-directional graph with 1:? edges (modeled in EmberData with `inverse:null`) with\n    artificial (implicit) inverses, replacing a value results in up-to 3 discrete value transitions.\n    This is because a 1:? relationship is effectively 1:many.\n     If: A->B, C->B is the initial state\n    And: A->C, C->B is the final state\n     Then we would undergo three transitions.\n     Remove A from B\n    Add C to A\n    Add A to C\n  */// nothing for us to do\nif(op.value===existingState){// if we were empty before but now know we are empty this needs to be true\nstate.hasReceivedData=true;// if this is a remote update we still sync\nif(isRemote){const{localState}=relationship;// don't sync if localState is a new record and our remoteState is null\nif(localState&&isNew(localState)&&!existingState){return;}if(existingState&&localState===existingState){notifyInverseOfPotentialMaterialization(graph,existingState,definition.inverseKey,op.record,isRemote);}else{// if localState does not match existingState then we know\n// we have a local mutation that has not been persisted yet\nif(localState!==op.value&&relationship.definition.resetOnRemoteUpdate!==false){relationship.localState=existingState;(0,_ember_debug__WEBPACK_IMPORTED_MODULE_0__.deprecate)(`EmberData is changing the default semantics of updates to the remote state of relationships.\\n\\nThe following local state was cleared from the <${relationship.identifier.type}>.${relationship.definition.key} belongsTo relationship but will not be once this deprecation is resolved:\\n\\n\\t${localState?'Added: '+localState.lid+'\\n\\t':''}${existingState?'Removed: '+existingState.lid:''}`,false,{id:'ember-data:deprecate-relationship-remote-update-clearing-local-state',for:'ember-data',since:{enabled:'5.3',available:'5.3'},until:'6.0',url:'https://deprecations.emberjs.com/v5.x#ember-data-deprecate-relationship-remote-update-clearing-local-state'});notifyChange(graph,relationship.identifier,relationship.definition.key);}}}return;}// remove this value from the inverse if required\nif(existingState){removeFromInverse(graph,existingState,definition.inverseKey,op.record,isRemote);}// update value to the new value\nrelationship[prop]=op.value;state.hasReceivedData=true;state.isEmpty=op.value===null;state.isStale=false;state.hasFailedLoadAttempt=false;if(op.value){if(definition.type!==op.value.type){// assert(\n//   `The '<${definition.inverseType}>.${op.field}' relationship expects only '${definition.type}' records since it is not polymorphic. Received a Record of type '${op.value.type}'`,\n//   definition.isPolymorphic\n// );\n// TODO this should now handle the deprecation warning if isPolymorphic is not set\n// but the record does turn out to be polymorphic\n// this should still assert if the user is relying on legacy inheritance/mixins to\n// provide polymorphic behavior and has not yet added the polymorphic flags\n{assertPolymorphicType(relationship.identifier,definition,op.value,graph.store);}graph.registerPolymorphicType(definition.type,op.value.type);}addToInverse(graph,op.value,definition.inverseKey,op.record,isRemote);}if(isRemote){const{localState,remoteState}=relationship;if(localState&&isNew(localState)&&!remoteState){return;}// when localState does not match the new remoteState and\n// localState === existingState then we had no local mutation\n// and we can safely sync the new remoteState to local\nif(localState!==remoteState&&localState===existingState){relationship.localState=remoteState;notifyChange(graph,relationship.identifier,relationship.definition.key);// But when localState does not match the new remoteState and\n// and localState !== existingState then we know we have a local mutation\n// that has not been persisted yet.\n}else{if(localState!==remoteState&&localState!==existingState&&relationship.definition.resetOnRemoteUpdate!==false){relationship.localState=remoteState;(0,_ember_debug__WEBPACK_IMPORTED_MODULE_0__.deprecate)(`EmberData is changing the default semantics of updates to the remote state of relationships.\\n\\nThe following local state was cleared from the <${relationship.identifier.type}>.${relationship.definition.key} belongsTo relationship but will not be once this deprecation is resolved:\\n\\n\\t${localState?'Added: '+localState.lid+'\\n\\t':''}${existingState?'Removed: '+existingState.lid:''}`,false,{id:'ember-data:deprecate-relationship-remote-update-clearing-local-state',for:'ember-data',since:{enabled:'5.3',available:'5.3'},until:'6.0',url:'https://deprecations.emberjs.com/v5.x#ember-data-deprecate-relationship-remote-update-clearing-local-state'});notifyChange(graph,relationship.identifier,relationship.definition.key);}}}else{notifyChange(graph,relationship.identifier,relationship.definition.key);}}function _deprecatedCompare(newState,newMembers,prevState,prevSet,onAdd,onDel){const newLength=newState.length;const prevLength=prevState.length;const iterationLength=Math.max(newLength,prevLength);let changed=newMembers.size!==prevSet.size;const added=new Set();const removed=new Set();const duplicates=new Map();const finalSet=new Set();const finalState=[];for(let i=0,j=0;i<iterationLength;i++){let adv=false;let member;// accumulate anything added\nif(i<newLength){member=newState[i];if(!finalSet.has(member)){finalState[j]=member;finalSet.add(member);adv=true;if(!prevSet.has(member)){changed=true;added.add(member);onAdd(member);}}else{let list=duplicates.get(member);if(list===undefined){list=[];duplicates.set(member,list);}list.push(i);}}// accumulate anything removed\nif(i<prevLength){const prevMember=prevState[i];// detect reordering, adjusting index for duplicates\n// j is always less than i and so if i < prevLength, j < prevLength\nif(member!==prevState[j]){changed=true;}if(!newMembers.has(prevMember)){changed=true;removed.add(prevMember);onDel(prevMember);}}else if(adv&&j<prevLength&&member!==prevState[j]){changed=true;}if(adv){j++;}}const diff={add:added,del:removed,finalState,finalSet,changed};return{diff,duplicates};}function _compare(finalState,finalSet,prevState,prevSet,onAdd,onDel){const finalLength=finalState.length;const prevLength=prevState.length;const iterationLength=Math.max(finalLength,prevLength);const equalLength=finalLength===prevLength;let changed=finalSet.size!==prevSet.size;const added=new Set();const removed=new Set();for(let i=0;i<iterationLength;i++){let member;// accumulate anything added\nif(i<finalLength){member=finalState[i];if(!prevSet.has(member)){changed=true;added.add(member);onAdd(member);}}// accumulate anything removed\nif(i<prevLength){const prevMember=prevState[i];// detect reordering\nif(equalLength&&member!==prevMember){changed=true;}if(!finalSet.has(prevMember)){changed=true;removed.add(prevMember);onDel(prevMember);}}}return{add:added,del:removed,finalState,finalSet,changed};}function diffCollection(finalState,relationship,onAdd,onDel){const finalSet=new Set(finalState);const{remoteState,remoteMembers}=relationship;{if(finalState.length!==finalSet.size){const{diff,duplicates}=_deprecatedCompare(finalState,finalSet,remoteState,remoteMembers,onAdd,onDel);{(0,_ember_debug__WEBPACK_IMPORTED_MODULE_0__.deprecate)(`Expected all entries in the relationship ${relationship.definition.type}:${relationship.definition.key} to be unique, see log for a list of duplicate entry indeces`,false,{id:'ember-data:deprecate-non-unique-relationship-entries',for:'ember-data',until:'6.0',since:{available:'5.3',enabled:'5.3'}});// eslint-disable-next-line no-console\nconsole.log(duplicates);}return diff;}}return _compare(finalState,finalSet,remoteState,remoteMembers,onAdd,onDel);}function computeLocalState(storage){if(!storage.isDirty){(test=>{if(!test){throw new Error(`Expected localState to be present`);}})(Array.isArray(storage.localState));return storage.localState;}const state=storage.remoteState.slice();storage.removals?.forEach(v=>{const index=state.indexOf(v);state.splice(index,1);});storage.additions?.forEach(v=>{state.push(v);});storage.localState=state;storage.isDirty=false;return state;}function _addLocal(graph,record,relationship,value,index){const{remoteMembers,removals}=relationship;let additions=relationship.additions;const hasPresence=remoteMembers.has(value)||additions?.has(value);if(hasPresence&&!removals?.has(value)){(test=>{if(!test){throw new Error(`Attempted to add the resource '${value.lid}' to the collection <${relationship.identifier.type}>.${relationship.definition.key} it was already in`);}})(hasPresence&&!removals?.has(value));return false;}if(removals?.has(value)){removals.delete(value);}else{if(!additions){additions=relationship.additions=new Set();}relationship.state.hasReceivedData=true;additions.add(value);const{type}=relationship.definition;if(type!==value.type){{assertPolymorphicType(record,relationship.definition,value,graph.store);}graph.registerPolymorphicType(value.type,type);}}// if we have existing localState\n// and we have an index\n// apply the change, as this is more efficient\n// than recomputing localState and\n// it allows us to preserve local ordering\n// to a small extend. Local ordering should not\n// be relied upon as any remote change will blow it away\nif(relationship.localState){if(index!==null){relationship.localState.splice(index,0,value);}else{relationship.localState.push(value);}}(test=>{if(!test){throw new Error(`Expected relationship to be dirty when adding a local mutation`);}})(relationship.localState||relationship.isDirty);return true;}function _removeLocal(relationship,value){(test=>{if(!test){throw new Error(`expected an identifier to remove from the collection relationship`);}})(value);const{remoteMembers,additions}=relationship;let removals=relationship.removals;const hasPresence=remoteMembers.has(value)||additions?.has(value);if(!hasPresence||removals?.has(value)){(test=>{if(!test){throw new Error(`Attempted to remove the resource '${value.lid}' from the collection <${relationship.identifier.type}>.${relationship.definition.key} but it was not present`);}})(!hasPresence||removals?.has(value));return false;}if(additions?.has(value)){additions.delete(value);}else{if(!removals){removals=relationship.removals=new Set();}removals.add(value);}// if we have existing localState\n// apply the change, as this is more efficient\n// than recomputing localState and\n// it allows us to preserve local ordering\n// to a small extend. Local ordering should not\n// be relied upon as any remote change will blow it away\nif(relationship.localState){const index=relationship.localState.indexOf(value);(test=>{if(!test){throw new Error(`Cannot remove a resource that is not present`);}})(index!==-1);relationship.localState.splice(index,1);}(test=>{if(!test){throw new Error(`Expected relationship to be dirty when performing a local mutation`);}})(relationship.localState||relationship.isDirty);return true;}function _removeRemote(relationship,value){(test=>{if(!test){throw new Error(`expected an identifier to remove from the collection relationship`);}})(value);const{remoteMembers,additions,removals,remoteState}=relationship;(test=>{if(!test){throw new Error(`Cannot remove a resource that is not present`);}})(remoteMembers.has(value));if(!remoteMembers.has(value)){return false;}// remove from remote state\nremoteMembers.delete(value);let index=remoteState.indexOf(value);(test=>{if(!test){throw new Error(`Cannot remove a resource that is not present`);}})(index!==-1);remoteState.splice(index,1);// remove from removals if present\nif(removals?.has(value)){removals.delete(value);// nothing more to do this was our state already\nreturn false;}(test=>{if(!test){throw new Error(`Remote state indicated removal of a resource that was present only as a local mutation`);}})(!additions?.has(value));// if we have existing localState\n// and we have an index\n// apply the change, as this is more efficient\n// than recomputing localState and\n// it allows us to preserve local ordering\n// to a small extend. Local ordering should not\n// be relied upon as any remote change will blow it away\nif(relationship.localState){index=relationship.localState.indexOf(value);(test=>{if(!test){throw new Error(`Cannot remove a resource that is not present`);}})(index!==-1);relationship.localState.splice(index,1);}(test=>{if(!test){throw new Error(`Expected relationship to be dirty when performing a local mutation`);}})(relationship.localState||relationship.isDirty);return true;}function rollbackRelationship(graph,identifier,field,relationship){if(isBelongsTo(relationship)){replaceRelatedRecord(graph,{op:'replaceRelatedRecord',record:identifier,field,value:relationship.remoteState},false);}else{replaceRelatedRecords(graph,{op:'replaceRelatedRecords',record:identifier,field,value:relationship.remoteState.slice()},false);}}function createState(){return{hasReceivedData:false,isEmpty:true,isStale:false,hasFailedLoadAttempt:false,shouldForceReload:false,hasDematerializedInverse:false};}function createCollectionEdge(definition,identifier){return{definition,identifier,state:createState(),remoteMembers:new Set(),remoteState:[],additions:null,removals:null,meta:null,links:null,localState:null,isDirty:true,transactionRef:0,_diff:undefined};}function legacyGetCollectionRelationshipData(source){const payload={};if(source.state.hasReceivedData){payload.data=computeLocalState(source);}if(source.links){payload.links=source.links;}if(source.meta){payload.meta=source.meta;}return payload;}function createImplicitEdge(definition,identifier){return{definition,identifier,localMembers:new Set(),remoteMembers:new Set()};}/*\n * @module @ember-data/graph\n *\n * Stores the data for one side of a \"single\" resource relationship.\n *\n * @class ResourceEdge\n * @internal\n */function createResourceEdge(definition,identifier){return{definition,identifier,state:createState(),transactionRef:0,localState:null,remoteState:null,meta:null,links:null};}function legacyGetResourceRelationshipData(source){let data;const payload={};if(source.localState){data=source.localState;}if(source.localState===null&&source.state.hasReceivedData){data=null;}if(source.links){payload.links=source.links;}if(data!==undefined){payload.data=data;}if(source.meta){payload.meta=source.meta;}return payload;}function addToRelatedRecords(graph,op,isRemote){(test=>{if(!test){throw new Error(`Graph does not yet support updating the remote state of a relationship via the ${op.op} operation`);}})(!isRemote);const{record,value,index}=op;const relationship=graph.get(record,op.field);(test=>{if(!test){throw new Error(`You can only '${op.op}' on a hasMany relationship. ${record.type}.${op.field} is a ${relationship.definition.kind}`);}})(isHasMany(relationship));if(Array.isArray(value)){for(let i=0;i<value.length;i++){addRelatedRecord(graph,relationship,record,value[i],index!==undefined?index+i:index,isRemote);}}else{addRelatedRecord(graph,relationship,record,value,index,isRemote);}notifyChange(graph,relationship.identifier,relationship.definition.key);}function addRelatedRecord(graph,relationship,record,value,index,isRemote){(test=>{if(!test){throw new Error(`expected an identifier to add to the collection relationship`);}})(value);if(_addLocal(graph,record,relationship,value,index??null)){addToInverse(graph,value,relationship.definition.inverseKey,record,isRemote);}}function mergeIdentifier(graph,op,relationships){Object.keys(relationships).forEach(key=>{const rel=relationships[key];if(!rel){return;}mergeIdentifierForRelationship(graph,op,rel);});}function mergeIdentifierForRelationship(graph,op,rel){rel.identifier=op.value;forAllRelatedIdentifiers(rel,identifier=>{const inverse=graph.get(identifier,rel.definition.inverseKey);mergeInRelationship(graph,inverse,op);});}function mergeInRelationship(graph,rel,op){if(isBelongsTo(rel)){mergeBelongsTo(graph,rel,op);}else if(isHasMany(rel)){mergeHasMany(graph,rel,op);}else{mergeImplicit(graph,rel,op);}}function mergeBelongsTo(graph,rel,op){if(rel.remoteState===op.record){rel.remoteState=op.value;}if(rel.localState===op.record){rel.localState=op.value;notifyChange(graph,rel.identifier,rel.definition.key);}}function mergeHasMany(graph,rel,op){if(rel.remoteMembers.has(op.record)){rel.remoteMembers.delete(op.record);rel.remoteMembers.add(op.value);const index=rel.remoteState.indexOf(op.record);rel.remoteState.splice(index,1,op.value);rel.isDirty=true;}if(rel.additions?.has(op.record)){rel.additions.delete(op.record);rel.additions.add(op.value);rel.isDirty=true;}if(rel.removals?.has(op.record)){rel.removals.delete(op.record);rel.removals.add(op.value);rel.isDirty=true;}if(rel.isDirty){notifyChange(graph,rel.identifier,rel.definition.key);}}function mergeImplicit(graph,rel,op){if(rel.remoteMembers.has(op.record)){rel.remoteMembers.delete(op.record);rel.remoteMembers.add(op.value);}if(rel.localMembers.has(op.record)){rel.localMembers.delete(op.record);rel.localMembers.add(op.value);}}function removeFromRelatedRecords(graph,op,isRemote){(test=>{if(!test){throw new Error(`Graph does not yet support updating the remote state of a relationship via the ${op.op} operation`);}})(!isRemote);const{record,value}=op;const relationship=graph.get(record,op.field);(test=>{if(!test){throw new Error(`You can only '${op.op}' on a hasMany relationship. ${record.type}.${op.field} is a ${relationship.definition.kind}`);}})(isHasMany(relationship));// TODO we should potentially thread the index information through here\n// when available as it may make it faster to remove from the local state\n// when trying to patch more efficiently without blowing away the entire\n// local state array\nif(Array.isArray(value)){for(let i=0;i<value.length;i++){removeRelatedRecord(graph,relationship,record,value[i],isRemote);}}else{removeRelatedRecord(graph,relationship,record,value,isRemote);}notifyChange(graph,relationship.identifier,relationship.definition.key);}function removeRelatedRecord(graph,relationship,record,value,isRemote){(test=>{if(!test){throw new Error(`expected an identifier to remove from the collection relationship`);}})(value);if(_removeLocal(relationship,value)){removeFromInverse(graph,value,relationship.definition.inverseKey,record,isRemote);}}/*\n  This method normalizes a link to an \"links object\". If the passed link is\n  already an object it's returned without any modifications.\n\n  See http://jsonapi.org/format/#document-links for more information.\n*/function _normalizeLink(link){switch(typeof link){case'object':return link;case'string':return{href:link};}}/*\n    Updates the \"canonical\" or \"remote\" state of a relationship, replacing any existing\n    state and blowing away any local changes (excepting new records).\n*/function updateRelationshipOperation(graph,op){const relationship=graph.get(op.record,op.field);(test=>{if(!test){throw new Error(`Cannot update an implicit relationship`);}})(isHasMany(relationship)||isBelongsTo(relationship));const{definition,state,identifier}=relationship;const{isCollection}=definition;const payload=op.value;let hasRelationshipDataProperty=false;let hasUpdatedLink=false;if(payload.meta){relationship.meta=payload.meta;}if(payload.data!==undefined){hasRelationshipDataProperty=true;if(isCollection){// TODO deprecate this case. We\n// have tests saying we support it.\nif(payload.data===null){payload.data=[];}(test=>{if(!test){throw new Error(`Expected an array`);}})(Array.isArray(payload.data));const cache=graph.store.identifierCache;graph.update({op:'replaceRelatedRecords',record:identifier,field:op.field,value:upgradeIdentifiers(payload.data,cache)},true);}else{graph.update({op:'replaceRelatedRecord',record:identifier,field:op.field,value:payload.data?graph.store.identifierCache.upgradeIdentifier(payload.data):null},true);}}else if(definition.isAsync===false&&!state.hasReceivedData){hasRelationshipDataProperty=true;if(isCollection){graph.update({op:'replaceRelatedRecords',record:identifier,field:op.field,value:[]},true);}else{graph.update({op:'replaceRelatedRecord',record:identifier,field:op.field,value:null},true);}}if(payload.links){const originalLinks=relationship.links;relationship.links=payload.links;if(payload.links.related){const relatedLink=_normalizeLink(payload.links.related);const currentLink=originalLinks&&originalLinks.related?_normalizeLink(originalLinks.related):null;const currentLinkHref=currentLink?currentLink.href:null;if(relatedLink&&relatedLink.href&&relatedLink.href!==currentLinkHref){(0,_ember_debug__WEBPACK_IMPORTED_MODULE_0__.warn)(`You pushed a record of type '${identifier.type}' with a relationship '${definition.key}' configured as 'async: false'. You've included a link but no primary data, this may be an error in your payload. EmberData will treat this relationship as known-to-be-empty.`,definition.isAsync||state.hasReceivedData,{id:'ds.store.push-link-for-sync-relationship'});(test=>{if(!test){throw new Error(`You have pushed a record of type '${identifier.type}' with '${definition.key}' as a link, but the value of that link is not a string.`);}})(typeof relatedLink.href==='string'||relatedLink.href===null);hasUpdatedLink=true;}}}/*\n       Data being pushed into the relationship might contain only data or links,\n       or a combination of both.\n        IF contains only data\n       IF contains both links and data\n        state.isEmpty -> true if is empty array (has-many) or is null (belongs-to)\n        state.hasReceivedData -> true\n        hasDematerializedInverse -> false\n        state.isStale -> false\n        allInverseRecordsAreLoaded -> run-check-to-determine\n        IF contains only links\n        state.isStale -> true\n       */relationship.state.hasFailedLoadAttempt=false;if(hasRelationshipDataProperty){const relationshipIsEmpty=payload.data===null||Array.isArray(payload.data)&&payload.data.length===0;// we don't need to notify here as the update op we pushed in above will notify once\n// membership is in the correct state.\nrelationship.state.hasReceivedData=true;relationship.state.isStale=false;relationship.state.hasDematerializedInverse=false;relationship.state.isEmpty=relationshipIsEmpty;}else if(hasUpdatedLink){// only notify stale if we have not previously received membership data.\n// within this same transaction\n// this prevents refetching when only one side of the relationship in the\n// payload contains the info while the other side contains just a link\n// this only works when the side with just a link is a belongsTo, as we\n// don't know if a hasMany has full information or not.\n// see #7049 for context.\nif(isCollection||!relationship.state.hasReceivedData||isStaleTransaction(relationship.transactionRef,graph._transaction)){relationship.state.isStale=true;notifyChange(graph,relationship.identifier,relationship.definition.key);}else{relationship.state.isStale=false;}}}function isStaleTransaction(relationshipTransactionId,graphTransactionId){return relationshipTransactionId===0||// relationship has never notified\ngraphTransactionId===null||// we are not in a transaction\nrelationshipTransactionId<graphTransactionId// we are not part of the current transaction\n;}function upgradeIdentifiers(arr,cache){for(let i=0;i<arr.length;i++){arr[i]=cache.upgradeIdentifier(arr[i]);}return arr;}const Graphs=(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_2__.getOrSetGlobal)('Graphs',new Map());/*\n * Graph acts as the cache for relationship data. It allows for\n * us to ask about and update relationships for a given Identifier\n * without requiring other objects for that Identifier to be\n * instantiated (such as `RecordData` or a `Record`)\n *\n * This also allows for us to make more substantive changes to relationships\n * with increasingly minor alterations to other portions of the internals\n * over time.\n *\n * The graph is made up of nodes and edges. Each unique identifier gets\n * its own node, which is a dictionary with a list of that node's edges\n * (or connections) to other nodes. In `Model` terms, a node represents a\n * record instance, with each key (an edge) in the dictionary correlating\n * to either a `hasMany` or `belongsTo` field on that record instance.\n *\n * The value for each key, or `edge` is the identifier(s) the node relates\n * to in the graph from that key.\n */class Graph{constructor(store){this._definitionCache=Object.create(null);this._metaCache=Object.create(null);this._potentialPolymorphicTypes=Object.create(null);this.identifiers=new Map();this.store=store;this.isDestroyed=false;this._willSyncRemote=false;this._willSyncLocal=false;this._pushedUpdates={belongsTo:undefined,hasMany:undefined,deletions:[]};this._updatedRelationships=new Set();this._transaction=null;this._removing=null;this.silenceNotifications=false;}has(identifier,propertyName){const relationships=this.identifiers.get(identifier);if(!relationships){return false;}return relationships[propertyName]!==undefined;}getDefinition(identifier,propertyName){let defs=this._metaCache[identifier.type];let meta=defs?.[propertyName];if(!meta){const info=/*#__NOINLINE__*/upgradeDefinition(this,identifier,propertyName);(test=>{if(!test){throw new Error(`Could not determine relationship information for ${identifier.type}.${propertyName}`);}})(info!==null);// if (info.rhs_definition?.kind === 'implicit') {\n// we should possibly also do this\n// but it would result in being extremely permissive for other relationships by accident\n// this.registerPolymorphicType(info.rhs_baseModelName, identifier.type);\n// }\nmeta=/*#__NOINLINE__*/isLHS(info,identifier.type,propertyName)?info.lhs_definition:info.rhs_definition;defs=this._metaCache[identifier.type]=defs||{};defs[propertyName]=meta;}return meta;}get(identifier,propertyName){(test=>{if(!test){throw new Error(`expected propertyName`);}})(propertyName);let relationships=this.identifiers.get(identifier);if(!relationships){relationships=Object.create(null);this.identifiers.set(identifier,relationships);}let relationship=relationships[propertyName];if(!relationship){const meta=this.getDefinition(identifier,propertyName);if(meta.kind==='belongsTo'){relationship=relationships[propertyName]=createResourceEdge(meta,identifier);}else if(meta.kind==='hasMany'){relationship=relationships[propertyName]=createCollectionEdge(meta,identifier);}else{(test=>{if(!test){throw new Error(`Expected kind to be implicit`);}})(meta.kind==='implicit'&&meta.isImplicit===true);relationship=relationships[propertyName]=createImplicitEdge(meta,identifier);}}return relationship;}getData(identifier,propertyName){const relationship=this.get(identifier,propertyName);(test=>{if(!test){throw new Error(`Cannot getData() on an implicit relationship`);}})(!isImplicit(relationship));if(isBelongsTo(relationship)){return legacyGetResourceRelationshipData(relationship);}return legacyGetCollectionRelationshipData(relationship);}/*\n   * Allows for the graph to dynamically discover polymorphic connections\n   * without needing to walk prototype chains.\n   *\n   * Used by edges when an added `type` does not match the expected `type`\n   * for that edge.\n   *\n   * Currently we assert before calling this. For a public API we will want\n   * to call out to the schema manager to ask if we should consider these\n   * types as equivalent for a given relationship.\n   */registerPolymorphicType(type1,type2){const typeCache=this._potentialPolymorphicTypes;let t1=typeCache[type1];if(!t1){t1=typeCache[type1]=Object.create(null);}t1[type2]=true;let t2=typeCache[type2];if(!t2){t2=typeCache[type2]=Object.create(null);}t2[type1]=true;}/*\n   TODO move this comment somewhere else\n   implicit relationships are relationships which have not been declared but the inverse side exists on\n   another record somewhere\n    For example if there was:\n    ```app/models/comment.js\n   import Model, { attr } from '@ember-data/model';\n    export default class Comment extends Model {\n     @attr text;\n   }\n   ```\n    and there is also:\n    ```app/models/post.js\n   import Model, { attr, hasMany } from '@ember-data/model';\n    export default class Post extends Model {\n     @attr title;\n     @hasMany('comment', { async: true, inverse: null }) comments;\n   }\n   ```\n    Then we would have a implicit 'post' relationship for the comment record in order\n   to be do things like remove the comment from the post if the comment were to be deleted.\n  */isReleasable(identifier){const relationships=this.identifiers.get(identifier);if(!relationships){return true;}const keys=Object.keys(relationships);for(let i=0;i<keys.length;i++){const relationship=relationships[keys[i]];// account for previously unloaded relationships\n// typically from a prior deletion of a record that pointed to this one implicitly\nif(relationship===undefined){continue;}(test=>{if(!test){throw new Error(`Expected a relationship`);}})(relationship);if(relationship.definition.inverseIsAsync&&!isNew(identifier)){return false;}}return true;}unload(identifier,silenceNotifications){const relationships=this.identifiers.get(identifier);if(relationships){// cleans up the graph but retains some nodes\n// to allow for rematerialization\nObject.keys(relationships).forEach(key=>{const rel=relationships[key];if(!rel){return;}/*#__NOINLINE__*/destroyRelationship(this,rel,silenceNotifications);if(/*#__NOINLINE__*/isImplicit(rel)){// @ts-expect-error\nrelationships[key]=undefined;}});}}_isDirty(identifier,field){const relationships=this.identifiers.get(identifier);if(!relationships){return false;}const relationship=relationships[field];if(!relationship){return false;}if(isBelongsTo(relationship)){return relationship.localState!==relationship.remoteState;}else if(isHasMany(relationship)){const hasAdditions=relationship.additions!==null&&relationship.additions.size>0;const hasRemovals=relationship.removals!==null&&relationship.removals.size>0;return hasAdditions||hasRemovals||isReordered(relationship);}return false;}getChanged(identifier){const relationships=this.identifiers.get(identifier);const changed=new Map();if(!relationships){return changed;}const keys=Object.keys(relationships);for(let i=0;i<keys.length;i++){const field=keys[i];const relationship=relationships[field];if(!relationship){continue;}if(isBelongsTo(relationship)){if(relationship.localState!==relationship.remoteState){changed.set(field,{kind:'resource',remoteState:relationship.remoteState,localState:relationship.localState});}}else if(isHasMany(relationship)){const hasAdditions=relationship.additions!==null&&relationship.additions.size>0;const hasRemovals=relationship.removals!==null&&relationship.removals.size>0;const reordered=isReordered(relationship);if(hasAdditions||hasRemovals||reordered){changed.set(field,{kind:'collection',additions:new Set(relationship.additions),removals:new Set(relationship.removals),remoteState:relationship.remoteState,localState:legacyGetCollectionRelationshipData(relationship).data||[],reordered});}}}return changed;}hasChanged(identifier){const relationships=this.identifiers.get(identifier);if(!relationships){return false;}const keys=Object.keys(relationships);for(let i=0;i<keys.length;i++){if(this._isDirty(identifier,keys[i])){return true;}}return false;}rollback(identifier){const relationships=this.identifiers.get(identifier);const changed=[];if(!relationships){return changed;}const keys=Object.keys(relationships);for(let i=0;i<keys.length;i++){const field=keys[i];const relationship=relationships[field];if(!relationship){continue;}if(this._isDirty(identifier,field)){rollbackRelationship(this,identifier,field,relationship);changed.push(field);}}return changed;}remove(identifier){(test=>{if(!test){throw new Error(`Cannot remove ${String(identifier)} while still removing ${String(this._removing)}`);}})(!this._removing);this._removing=identifier;this.unload(identifier);this.identifiers.delete(identifier);this._removing=null;}/*\n   * Remote state changes\n   */push(op){if(op.op==='deleteRecord'){this._pushedUpdates.deletions.push(op);}else{const definition=this.getDefinition(op.record,op.field);(test=>{if(!test){throw new Error(`Cannot push a remote update for an implicit relationship`);}})(definition.kind!=='implicit');addPending(this._pushedUpdates,definition,op);}if(!this._willSyncRemote){this._willSyncRemote=true;getStore(this.store)._schedule('coalesce',()=>this._flushRemoteQueue());}}/*\n   * Local state changes\n   */update(op,isRemote=false){(test=>{if(!test){throw new Error(`Cannot update an implicit relationship`);}})(op.op==='deleteRecord'||op.op==='mergeIdentifiers'||!isImplicit(this.get(op.record,op.field)));switch(op.op){case'mergeIdentifiers':{const relationships=this.identifiers.get(op.record);if(relationships){/*#__NOINLINE__*/mergeIdentifier(this,op,relationships);}break;}case'updateRelationship':(test=>{if(!test){throw new Error(`Can only perform the operation updateRelationship on remote state`);}})(isRemote);{// in debug, assert payload validity eagerly\n// TODO add deprecations/assertion here for duplicates\nassertValidRelationshipPayload(this,op);}/*#__NOINLINE__*/updateRelationshipOperation(this,op);break;case'deleteRecord':{(test=>{if(!test){throw new Error(`Can only perform the operation deleteRelationship on remote state`);}})(isRemote);const identifier=op.record;const relationships=this.identifiers.get(identifier);if(relationships){Object.keys(relationships).forEach(key=>{const rel=relationships[key];if(!rel){return;}// works together with the has check\n// @ts-expect-error\nrelationships[key]=undefined;/*#__NOINLINE__*/removeCompletelyFromInverse(this,rel);});this.identifiers.delete(identifier);}break;}case'replaceRelatedRecord':/*#__NOINLINE__*/replaceRelatedRecord(this,op,isRemote);break;case'addToRelatedRecords':// we will lift this restriction once the cache is allowed to make remote updates directly\n(test=>{if(!test){throw new Error(`Can only perform the operation addToRelatedRecords on local state`);}})(!isRemote);/*#__NOINLINE__*/addToRelatedRecords(this,op,isRemote);break;case'removeFromRelatedRecords':// we will lift this restriction once the cache is allowed to make remote updates directly\n(test=>{if(!test){throw new Error(`Can only perform the operation removeFromRelatedRecords on local state`);}})(!isRemote);/*#__NOINLINE__*/removeFromRelatedRecords(this,op,isRemote);break;case'replaceRelatedRecords':/*#__NOINLINE__*/replaceRelatedRecords(this,op,isRemote);break;default:(test=>{{throw new Error(`No local relationship update operation exists for '${op.op}'`);}})();}}_scheduleLocalSync(relationship){this._updatedRelationships.add(relationship);if(!this._willSyncLocal){this._willSyncLocal=true;getStore(this.store)._schedule('sync',()=>this._flushLocalQueue());}}_flushRemoteQueue(){if(!this._willSyncRemote){return;}let transactionRef=(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_2__.peekTransient)('transactionRef')??0;this._transaction=++transactionRef;(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_2__.setTransient)('transactionRef',transactionRef);this._willSyncRemote=false;const updates=this._pushedUpdates;const{deletions,hasMany,belongsTo}=updates;updates.deletions=[];updates.hasMany=undefined;updates.belongsTo=undefined;for(let i=0;i<deletions.length;i++){this.update(deletions[i],true);}if(hasMany){flushPending(this,hasMany);}if(belongsTo){flushPending(this,belongsTo);}this._transaction=null;}_addToTransaction(relationship){(test=>{if(!test){throw new Error(`expected a transaction`);}})(this._transaction!==null);relationship.transactionRef=this._transaction;}_flushLocalQueue(){if(!this._willSyncLocal){return;}if(this.silenceNotifications){this.silenceNotifications=false;this._updatedRelationships=new Set();return;}this._willSyncLocal=false;const updated=this._updatedRelationships;this._updatedRelationships=new Set();updated.forEach(rel=>notifyChange(this,rel.identifier,rel.definition.key));}destroy(){Graphs.delete(this.store);{Graphs.delete(getStore(this.store));if(Graphs.size){Graphs.forEach((_,key)=>{(test=>{if(!test){throw new Error(`Memory Leak Detected, likely the test or app instance previous to this was not torn down properly`);}})(!key.isDestroyed&&!key.isDestroying);});}}this.identifiers.clear();this.store=null;this.isDestroyed=true;}}function flushPending(graph,ops){ops.forEach(type=>{type.forEach(opList=>{flushPendingList(graph,opList);});});}function flushPendingList(graph,opList){for(let i=0;i<opList.length;i++){graph.update(opList[i],true);}}// Handle dematerialization for relationship `rel`.  In all cases, notify the\n// relationship of the dematerialization: this is done so the relationship can\n// notify its inverse which needs to update state\n//\n// If the inverse is sync, unloading this record is treated as a client-side\n// delete, so we remove the inverse records from this relationship to\n// disconnect the graph.  Because it's not async, we don't need to keep around\n// the identifier as an id-wrapper for references\nfunction destroyRelationship(graph,rel,silenceNotifications){if(isImplicit(rel)){if(graph.isReleasable(rel.identifier)){/*#__NOINLINE__*/removeCompletelyFromInverse(graph,rel);}return;}const{identifier}=rel;const{inverseKey}=rel.definition;if(!rel.definition.inverseIsImplicit){/*#__NOINLINE__*/forAllRelatedIdentifiers(rel,inverseIdentifer=>/*#__NOINLINE__*/notifyInverseOfDematerialization(graph,inverseIdentifer,inverseKey,identifier,silenceNotifications));}if(!rel.definition.inverseIsImplicit&&!rel.definition.inverseIsAsync){rel.state.isStale=true;/*#__NOINLINE__*/clearRelationship(rel);// necessary to clear relationships in the ui from dematerialized records\n// hasMany is managed by Model which calls `retreiveLatest` after\n// dematerializing the resource-cache instance.\n// but sync belongsTo requires this since they don't have a proxy to update.\n// so we have to notify so it will \"update\" to null.\n// we should discuss whether we still care about this, probably fine to just\n// leave the ui relationship populated since the record is destroyed and\n// internally we've fully cleaned up.\nif(!rel.definition.isAsync&&!silenceNotifications){/*#__NOINLINE__*/notifyChange(graph,rel.identifier,rel.definition.key);}}}function notifyInverseOfDematerialization(graph,inverseIdentifier,inverseKey,identifier,silenceNotifications){if(!graph.has(inverseIdentifier,inverseKey)){return;}const relationship=graph.get(inverseIdentifier,inverseKey);(test=>{if(!test){throw new Error(`expected no implicit`);}})(!isImplicit(relationship));// For remote members, it is possible that inverseRecordData has already been associated to\n// to another record. For such cases, do not dematerialize the inverseRecordData\nif(!isBelongsTo(relationship)||!relationship.localState||identifier===relationship.localState){/*#__NOINLINE__*/removeDematerializedInverse(graph,relationship,identifier,silenceNotifications);}}function clearRelationship(relationship){if(isBelongsTo(relationship)){relationship.localState=null;relationship.remoteState=null;relationship.state.hasReceivedData=false;relationship.state.isEmpty=true;}else{relationship.remoteMembers.clear();relationship.remoteState=[];relationship.additions=null;relationship.removals=null;relationship.localState=null;}}function removeDematerializedInverse(graph,relationship,inverseIdentifier,silenceNotifications){if(isBelongsTo(relationship)){const localInverse=relationship.localState;if(!relationship.definition.isAsync||localInverse&&isNew(localInverse)){// unloading inverse of a sync relationship is treated as a client-side\n// delete, so actually remove the models don't merely invalidate the cp\n// cache.\n// if the record being unloaded only exists on the client, we similarly\n// treat it as a client side delete\nif(relationship.localState===localInverse&&localInverse!==null){relationship.localState=null;}if(relationship.remoteState===localInverse&&localInverse!==null){relationship.remoteState=null;relationship.state.hasReceivedData=true;relationship.state.isEmpty=true;if(relationship.localState&&!isNew(relationship.localState)){relationship.localState=null;}}}else{relationship.state.hasDematerializedInverse=true;}if(!silenceNotifications){notifyChange(graph,relationship.identifier,relationship.definition.key);}}else{if(!relationship.definition.isAsync||inverseIdentifier&&isNew(inverseIdentifier)){// unloading inverse of a sync relationship is treated as a client-side\n// delete, so actually remove the models don't merely invalidate the cp\n// cache.\n// if the record being unloaded only exists on the client, we similarly\n// treat it as a client side delete\n/*#__NOINLINE__*/removeIdentifierCompletelyFromRelationship(graph,relationship,inverseIdentifier);}else{relationship.state.hasDematerializedInverse=true;}if(!silenceNotifications){notifyChange(graph,relationship.identifier,relationship.definition.key);}}}function removeCompletelyFromInverse(graph,relationship){const{identifier}=relationship;const{inverseKey}=relationship.definition;forAllRelatedIdentifiers(relationship,inverseIdentifier=>{if(graph.has(inverseIdentifier,inverseKey)){removeIdentifierCompletelyFromRelationship(graph,graph.get(inverseIdentifier,inverseKey),identifier);}});if(isBelongsTo(relationship)){if(!relationship.definition.isAsync){clearRelationship(relationship);}relationship.localState=null;}else if(isHasMany(relationship)){if(!relationship.definition.isAsync){clearRelationship(relationship);notifyChange(graph,relationship.identifier,relationship.definition.key);}}else{relationship.remoteMembers.clear();relationship.localMembers.clear();}}function addPending(cache,definition,op){const lc=cache[definition.kind]=cache[definition.kind]||new Map();let lc2=lc.get(definition.inverseType);if(!lc2){lc2=new Map();lc.set(definition.inverseType,lc2);}let arr=lc2.get(op.field);if(!arr){arr=[];lc2.set(op.field,arr);}arr.push(op);}function isReordered(relationship){// if we are dirty we are never re-ordered because accessing\n// the state would flush away any reordering.\nif(relationship.isDirty){return false;}const{remoteState,localState,additions,removals}=relationship;(test=>{if(!test){throw new Error(`Expected localSate`);}})(localState);for(let i=0,j=0;i<remoteState.length;i++){const member=remoteState[i];const localMember=localState[j];if(member!==localMember){if(removals&&removals.has(member)){// dont increment j because we want to skip this\ncontinue;}if(additions&&additions.has(localMember)){// increment j to skip this localMember\n// decrement i to repeat this remoteMember\nj++;i--;continue;}return true;}// if we made it here, increment j\nj++;}return false;}/**\n * <p align=\"center\">\n  <img\n    class=\"project-logo\"\n    src=\"https://raw.githubusercontent.com/emberjs/data/4612c9354e4c54d53327ec2cf21955075ce21294/ember-data-logo-light.svg#gh-light-mode-only\"\n    alt=\"EmberData\"\n    width=\"240px\"\n    title=\"EmberData\"\n    />\n</p>\n\n<p align=\"center\">Provides a performance tuned normalized graph for intelligently managing relationships between resources based on identity</p>\n\nWhile this Graph is abstract, it currently is a private implementation required as a peer-dependency by the [JSON:API Cache Implementation](https://github.com/emberjs/data/tree/main/packages/json-api).\n\nWe intend to make this Graph public API after some additional iteration during the 5.x timeframe, until then all APIs should be considered experimental and unstable, not fit for direct application or 3rd party library usage.\n\n## Installation\n\nInstall using your javascript package manager of choice. For instance with [pnpm](https://pnpm.io/)\n\n```no-highlight\npnpm add @ember-data/graph\n```\n\n  @module @ember-data/graph\n  @main @ember-data/graph\n*/function isStore(maybeStore){return maybeStore._instanceCache!==undefined;}function getWrapper(store){return isStore(store)?store._instanceCache._storeWrapper:store;}function peekGraph(store){return Graphs.get(getWrapper(store));}function graphFor(store){const wrapper=getWrapper(store);let graph=Graphs.get(wrapper);if(!graph){graph=new Graph(wrapper);Graphs.set(wrapper,graph);getStore(wrapper)._graph=graph;{if(getStore(wrapper).isDestroying){throw new Error(`Memory Leak Detected During Teardown`);}}}return graph;}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@ember-data/graph/dist/-private.js?");

/***/ }),

/***/ "./node_modules/@ember-data/json-api/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@ember-data/json-api/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ JSONAPICache)\n/* harmony export */ });\n/* harmony import */ var _ember_data_graph_private__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ember-data/graph/-private */ \"./node_modules/@ember-data/graph/dist/-private.js\");\n/**\n * @module @ember-data/json-api\n */function isImplicit(relationship){return relationship.definition.isImplicit;}function upgradeCapabilities(obj){}const EMPTY_ITERATOR={iterator(){return{next(){return{done:true,value:undefined};}};}};function makeCache(){return{id:null,remoteAttrs:null,localAttrs:null,defaultAttrs:null,inflightAttrs:null,changes:null,errors:null,isNew:false,isDeleted:false,isDeletionCommitted:false};}/**\n  A JSON:API Cache implementation.\n\n  What cache the store uses is configurable. Using a different\n  implementation can be achieved by implementing the store's\n  createCache hook.\n\n  This is the cache implementation used by `ember-data`.\n\n  ```js\n  import Cache from '@ember-data/json-api';\n  import Store from '@ember-data/store';\n\n  export default class extends Store {\n    createCache(wrapper) {\n      return new Cache(wrapper);\n    }\n  }\n  ```\n\n  @class Cache\n  @public\n */class JSONAPICache{/**\n   * The Cache Version that this implementation implements.\n   *\n   * @type {'2'}\n   * @public\n   * @property version\n   */constructor(storeWrapper){this.version='2';this._capabilities=storeWrapper;this.__cache=new Map();this.__graph=(0,_ember_data_graph_private__WEBPACK_IMPORTED_MODULE_0__.graphFor)(storeWrapper);this.__destroyedCache=new Map();this.__documents=new Map();}// Cache Management\n// ================\n/**\n   * Cache the response to a request\n   *\n   * Implements `Cache.put`.\n   *\n   * Expects a StructuredDocument whose `content` member is a JsonApiDocument.\n   *\n   * ```js\n   * cache.put({\n   *   request: { url: 'https://api.example.com/v1/user/1' },\n   *   content: {\n   *     data: {\n   *       type: 'user',\n   *       id: '1',\n   *       attributes: {\n   *         name: 'Chris'\n   *       }\n   *     }\n   *   }\n   * })\n   * ```\n   *\n   * > **Note**\n   * > The nested `content` and `data` members are not a mistake. This is because\n   * > there are two separate concepts involved here, the `StructuredDocument` which contains\n   * > the context of a given Request that has been issued with the returned contents as its\n   * > `content` property, and a `JSON:API Document` which is the json contents returned by\n   * > this endpoint and which uses its `data` property to signify which resources are the\n   * > primary resources associated with the request.\n   *\n   * StructuredDocument's with urls will be cached as full documents with\n   * associated resource membership order and contents preserved but linked\n   * into the cache.\n   *\n   * @method put\n   * @param {StructuredDocument} doc\n   * @return {ResourceDocument}\n   * @public\n   */put(doc){(test=>{if(!test){throw new Error(`Expected a JSON:API Document as the content provided to the cache, received ${typeof doc.content}`);}})(doc instanceof Error||typeof doc.content==='object'&&doc.content!==null);if(isErrorDocument(doc)){return this._putDocument(doc,undefined,undefined);}else if(isMetaDocument(doc)){return this._putDocument(doc,undefined,undefined);}const jsonApiDoc=doc.content;const included=jsonApiDoc.included;let i,length;const{identifierCache}=this._capabilities;if(included){for(i=0,length=included.length;i<length;i++){included[i]=putOne(this,identifierCache,included[i]);}}if(Array.isArray(jsonApiDoc.data)){length=jsonApiDoc.data.length;const identifiers=[];for(i=0;i<length;i++){identifiers.push(putOne(this,identifierCache,jsonApiDoc.data[i]));}return this._putDocument(doc,identifiers,included);}if(jsonApiDoc.data===null){return this._putDocument(doc,null,included);}(test=>{if(!test){throw new Error(`Expected a resource object in the 'data' property in the document provided to the cache, but was ${typeof jsonApiDoc.data}`);}})(typeof jsonApiDoc.data==='object');const identifier=putOne(this,identifierCache,jsonApiDoc.data);return this._putDocument(doc,identifier,included);}_putDocument(doc,data,included){// @ts-expect-error narrowing within is just horrible  in TS :/\nconst resourceDocument=isErrorDocument(doc)?fromStructuredError(doc):fromBaseDocument(doc);if(data!==undefined){resourceDocument.data=data;}if(included!==undefined){(test=>{if(!test){throw new Error(`There should not be included data on an Error document`);}})(!isErrorDocument(doc));(test=>{if(!test){throw new Error(`There should not be included data on a Meta document`);}})(!isMetaDocument(doc));resourceDocument.included=included;}const request=doc.request;const identifier=request?this._capabilities.identifierCache.getOrCreateDocumentIdentifier(request):null;if(identifier){resourceDocument.lid=identifier.lid;// @ts-expect-error\ndoc.content=resourceDocument;const hasExisting=this.__documents.has(identifier.lid);this.__documents.set(identifier.lid,doc);this._capabilities.notifyChange(identifier,hasExisting?'updated':'added');}return resourceDocument;}/**\n   * Update the \"remote\" or \"canonical\" (persisted) state of the Cache\n   * by merging new information into the existing state.\n   *\n   * Note: currently the only valid resource operation is a MergeOperation\n   * which occurs when a collision of identifiers is detected.\n   *\n   * @method patch\n   * @public\n   * @param {Operation} op the operation to perform\n   * @return {void}\n   */patch(op){if(op.op==='mergeIdentifiers'){const cache=this.__cache.get(op.record);if(cache){this.__cache.set(op.value,cache);this.__cache.delete(op.record);}this.__graph.update(op,true);}}/**\n   * Update the \"local\" or \"current\" (unpersisted) state of the Cache\n   *\n   * @method mutate\n   * @param {Mutation} mutation\n   * @return {void}\n   * @public\n   */mutate(mutation){this.__graph.update(mutation,false);}/**\n   * Peek resource data from the Cache.\n   *\n   * In development, if the return value\n   * is JSON the return value\n   * will be deep-cloned and deep-frozen\n   * to prevent mutation thereby enforcing cache\n   * Immutability.\n   *\n   * This form of peek is useful for implementations\n   * that want to feed raw-data from cache to the UI\n   * or which want to interact with a blob of data\n   * directly from the presentation cache.\n   *\n   * An implementation might want to do this because\n   * de-referencing records which read from their own\n   * blob is generally safer because the record does\n   * not require retainining connections to the Store\n   * and Cache to present data on a per-field basis.\n   *\n   * This generally takes the place of `getAttr` as\n   * an API and may even take the place of `getRelationship`\n   * depending on implementation specifics, though this\n   * latter usage is less recommended due to the advantages\n   * of the Graph handling necessary entanglements and\n   * notifications for relational data.\n   *\n   * @method peek\n   * @public\n   * @param {StableRecordIdentifier | StableDocumentIdentifier} identifier\n   * @return {ResourceDocument | ResourceObject | null} the known resource data\n   */peek(identifier){if('type'in identifier){const peeked=this.__safePeek(identifier,false);if(!peeked){return null;}const{type,id,lid}=identifier;const attributes=Object.assign({},peeked.remoteAttrs,peeked.inflightAttrs,peeked.localAttrs);const relationships={};const rels=this.__graph.identifiers.get(identifier);if(rels){Object.keys(rels).forEach(key=>{const rel=rels[key];if(rel.definition.isImplicit){return;}else{relationships[key]=this.__graph.getData(identifier,key);}});}upgradeCapabilities(this._capabilities);const store=this._capabilities._store;const attrs=this._capabilities.schema.fields(identifier);attrs.forEach((attr,key)=>{if(key in attributes&&attributes[key]!==undefined){return;}const defaultValue=getDefaultValue(attr,identifier,store);if(defaultValue!==undefined){attributes[key]=defaultValue;}});return{type,id,lid,attributes,relationships};}const document=this.peekRequest(identifier);if(document){if('content'in document)return document.content;}return null;}/**\n   * Peek the Cache for the existing request data associated with\n   * a cacheable request.\n   *\n   * This is effectively the reverse of `put` for a request in\n   * that it will return the the request, response, and content\n   * whereas `peek` will return just the `content`.\n   *\n   * @method peekRequest\n   * @param {StableDocumentIdentifier}\n   * @return {StructuredDocument<ResourceDocument> | null}\n   * @public\n   */peekRequest(identifier){return this.__documents.get(identifier.lid)||null;}/**\n   * Push resource data from a remote source into the cache for this identifier\n   *\n   * @method upsert\n   * @public\n   * @param identifier\n   * @param data\n   * @param hasRecord\n   * @return {void | string[]} if `hasRecord` is true then calculated key changes should be returned\n   */upsert(identifier,data,calculateChanges){let changedKeys;const peeked=this.__safePeek(identifier,false);const existed=!!peeked;const cached=peeked||this._createCache(identifier);const isLoading=/*#__NOINLINE__*/_isLoading(peeked,this._capabilities,identifier)||!recordIsLoaded(peeked);const isUpdate=/*#__NOINLINE__*/!_isEmpty(peeked)&&!isLoading;if(cached.isNew){cached.isNew=false;this._capabilities.notifyChange(identifier,'identity');this._capabilities.notifyChange(identifier,'state');}if(calculateChanges){changedKeys=existed?calculateChangedKeys(cached,data.attributes):Object.keys(data.attributes||{});}cached.remoteAttrs=Object.assign(cached.remoteAttrs||Object.create(null),data.attributes);if(cached.localAttrs){if(patchLocalAttributes(cached)){this._capabilities.notifyChange(identifier,'state');}}if(!isUpdate){this._capabilities.notifyChange(identifier,'added');}if(data.id){cached.id=data.id;}if(data.relationships){setupRelationships(this.__graph,this._capabilities,identifier,data);}if(changedKeys&&changedKeys.length){notifyAttributes(this._capabilities,identifier,changedKeys);}return changedKeys;}// Cache Forking Support\n// =====================\n/**\n   * Create a fork of the cache from the current state.\n   *\n   * Applications should typically not call this method themselves,\n   * preferring instead to fork at the Store level, which will\n   * utilize this method to fork the cache.\n   *\n   * @method fork\n   * @internal\n   * @return Promise<Cache>\n   */fork(){throw new Error(`Not Implemented`);}/**\n   * Merge a fork back into a parent Cache.\n   *\n   * Applications should typically not call this method themselves,\n   * preferring instead to merge at the Store level, which will\n   * utilize this method to merge the caches.\n   *\n   * @method merge\n   * @param {Cache} cache\n   * @public\n   * @return Promise<void>\n   */merge(cache){throw new Error(`Not Implemented`);}/**\n   * Generate the list of changes applied to all\n   * record in the store.\n   *\n   * Each individual resource or document that has\n   * been mutated should be described as an individual\n   * `Change` entry in the returned array.\n   *\n   * A `Change` is described by an object containing up to\n   * three properties: (1) the `identifier` of the entity that\n   * changed; (2) the `op` code of that change being one of\n   * `upsert` or `remove`, and if the op is `upsert` a `patch`\n   * containing the data to merge into the cache for the given\n   * entity.\n   *\n   * This `patch` is opaque to the Store but should be understood\n   * by the Cache and may expect to be utilized by an Adapter\n   * when generating data during a `save` operation.\n   *\n   * It is generally recommended that the `patch` contain only\n   * the updated state, ignoring fields that are unchanged\n   *\n   * ```ts\n   * interface Change {\n   *  identifier: StableRecordIdentifier | StableDocumentIdentifier;\n   *  op: 'upsert' | 'remove';\n   *  patch?: unknown;\n   * }\n   * ```\n   *\n   * @method diff\n   * @public\n   */diff(){throw new Error(`Not Implemented`);}// SSR Support\n// ===========\n/**\n   * Serialize the entire contents of the Cache into a Stream\n   * which may be fed back into a new instance of the same Cache\n   * via `cache.hydrate`.\n   *\n   * @method dump\n   * @return {Promise<ReadableStream>}\n   * @public\n   */dump(){throw new Error(`Not Implemented`);}/**\n   * hydrate a Cache from a Stream with content previously serialized\n   * from another instance of the same Cache, resolving when hydration\n   * is complete.\n   *\n   * This method should expect to be called both in the context of restoring\n   * the Cache during application rehydration after SSR **AND** at unknown\n   * times during the lifetime of an already booted application when it is\n   * desired to bulk-load additional information into the cache. This latter\n   * behavior supports optimizing pre/fetching of data for route transitions\n   * via data-only SSR modes.\n   *\n   * @method hydrate\n   * @param {ReadableStream} stream\n   * @return {Promise<void>}\n   * @public\n   */hydrate(stream){throw new Error('Not Implemented');}// Resource Support\n// ================\n/**\n   * [LIFECYCLE] Signal to the cache that a new record has been instantiated on the client\n   *\n   * It returns properties from options that should be set on the record during the create\n   * process. This return value behavior is deprecated.\n   *\n   * @method clientDidCreate\n   * @public\n   * @param identifier\n   * @param createArgs\n   */clientDidCreate(identifier,options){const cached=this._createCache(identifier);cached.isNew=true;const createOptions={};if(options!==undefined){const storeWrapper=this._capabilities;const fields=storeWrapper.schema.fields(identifier);const graph=this.__graph;const propertyNames=Object.keys(options);for(let i=0;i<propertyNames.length;i++){const name=propertyNames[i];const propertyValue=options[name];if(name==='id'){continue;}const fieldType=fields.get(name);const kind=fieldType!==undefined?'kind'in fieldType?fieldType.kind:'attribute':null;let relationship;switch(kind){case'attribute':this.setAttr(identifier,name,propertyValue);createOptions[name]=propertyValue;break;case'belongsTo':this.mutate({op:'replaceRelatedRecord',field:name,record:identifier,value:propertyValue});relationship=graph.get(identifier,name);relationship.state.hasReceivedData=true;relationship.state.isEmpty=false;break;case'hasMany':this.mutate({op:'replaceRelatedRecords',field:name,record:identifier,value:propertyValue});relationship=graph.get(identifier,name);relationship.state.hasReceivedData=true;relationship.state.isEmpty=false;break;default:// reflect back (pass-thru) unknown properties\ncreateOptions[name]=propertyValue;}}}this._capabilities.notifyChange(identifier,'added');return createOptions;}/**\n   * [LIFECYCLE] Signals to the cache that a resource\n   * will be part of a save transaction.\n   *\n   * @method willCommit\n   * @public\n   * @param identifier\n   */willCommit(identifier){const cached=this.__peek(identifier,false);/*\n      if we have multiple saves in flight at once then\n      we have information loss no matter what. This\n      attempts to lose the least information.\n       If we were to clear inflightAttrs, previous requests\n      would not be able to use it during their didCommit.\n       If we upsert inflightattrs, previous requests incorrectly\n      see more recent inflight changes as part of their own and\n      will incorrectly mark the new state as the correct remote state.\n       We choose this latter behavior to avoid accidentally removing\n      earlier changes.\n       If apps do not want this behavior they can either\n      - chain save requests serially vs allowing concurrent saves\n      - move to using a request handler that caches the inflight state\n        on a per-request basis\n      - change their save requests to only send a \"PATCH\" instead of a \"PUT\"\n        so that only latest changes are involved in each request, and then also\n        ensure that the API or their handler reflects only those changes back\n        for upsert into the cache.\n    */if(cached.inflightAttrs){if(cached.localAttrs){Object.assign(cached.inflightAttrs,cached.localAttrs);}}else{cached.inflightAttrs=cached.localAttrs;}cached.localAttrs=null;{}}/**\n   * [LIFECYCLE] Signals to the cache that a resource\n   * was successfully updated as part of a save transaction.\n   *\n   * @method didCommit\n   * @public\n   * @param identifier\n   * @param data\n   */didCommit(committedIdentifier,result){const payload=result.content;const operation=result.request.op;const data=payload&&payload.data;if(!data){(test=>{if(!test){throw new Error(`Your ${committedIdentifier.type} record was saved to the server, but the response does not have an id and no id has been set client side. Records must have ids. Please update the server response to provide an id in the response or generate the id on the client side either before saving the record or while normalizing the response.`);}})(committedIdentifier.id);}const{identifierCache}=this._capabilities;const existingId=committedIdentifier.id;const identifier=operation!=='deleteRecord'&&data?identifierCache.updateRecordIdentifier(committedIdentifier,data):committedIdentifier;const cached=this.__peek(identifier,false);if(cached.isDeleted){this.__graph.push({op:'deleteRecord',record:identifier,isNew:false});cached.isDeletionCommitted=true;this._capabilities.notifyChange(identifier,'removed');// TODO @runspired should we early exit here?\n}{if(cached.isNew&&!identifier.id&&(typeof data?.id!=='string'||data.id.length>0)){const error=new Error(`Expected an id ${String(identifier)} in response ${JSON.stringify(data)}`);//@ts-expect-error\nerror.isAdapterError=true;//@ts-expect-error\nerror.code='InvalidError';throw error;}}cached.isNew=false;let newCanonicalAttributes;if(data){if(data.id&&!cached.id){cached.id=data.id;}if(identifier===committedIdentifier&&identifier.id!==existingId){this._capabilities.notifyChange(identifier,'identity');}(test=>{if(!test){throw new Error(`Expected the ID received for the primary '${identifier.type}' resource being saved to match the current id '${cached.id}' but received '${identifier.id}'.`);}})(identifier.id===cached.id);if(data.relationships){{}setupRelationships(this.__graph,this._capabilities,identifier,data);}newCanonicalAttributes=data.attributes;}const changedKeys=calculateChangedKeys(cached,newCanonicalAttributes);cached.remoteAttrs=Object.assign(cached.remoteAttrs||Object.create(null),cached.inflightAttrs,newCanonicalAttributes);cached.inflightAttrs=null;patchLocalAttributes(cached);if(cached.errors){cached.errors=null;this._capabilities.notifyChange(identifier,'errors');}notifyAttributes(this._capabilities,identifier,changedKeys);this._capabilities.notifyChange(identifier,'state');const included=payload&&payload.included;if(included){for(let i=0,length=included.length;i<length;i++){putOne(this,identifierCache,included[i]);}}return{data:identifier};}/**\n   * [LIFECYCLE] Signals to the cache that a resource\n   * was update via a save transaction failed.\n   *\n   * @method commitWasRejected\n   * @public\n   * @param identifier\n   * @param errors\n   */commitWasRejected(identifier,errors){const cached=this.__peek(identifier,false);if(cached.inflightAttrs){const keys=Object.keys(cached.inflightAttrs);if(keys.length>0){const attrs=cached.localAttrs=cached.localAttrs||Object.create(null);for(let i=0;i<keys.length;i++){if(attrs[keys[i]]===undefined){attrs[keys[i]]=cached.inflightAttrs[keys[i]];}}}cached.inflightAttrs=null;}if(errors){cached.errors=errors;}this._capabilities.notifyChange(identifier,'errors');}/**\n   * [LIFECYCLE] Signals to the cache that all data for a resource\n   * should be cleared.\n   *\n   * This method is a candidate to become a mutation\n   *\n   * @method unloadRecord\n   * @public\n   * @param identifier\n   */unloadRecord(identifier){const storeWrapper=this._capabilities;// TODO this is necessary because\n// we maintain memebership inside InstanceCache\n// for peekAll, so even though we haven't created\n// any data we think this exists.\n// TODO can we eliminate that membership now?\nif(!this.__cache.has(identifier)){// the graph may still need to unload identity\n(0,_ember_data_graph_private__WEBPACK_IMPORTED_MODULE_0__.peekGraph)(storeWrapper)?.unload(identifier);return;}const removeFromRecordArray=!this.isDeletionCommitted(identifier);let removed=false;const cached=this.__peek(identifier,false);if(cached.isNew){(0,_ember_data_graph_private__WEBPACK_IMPORTED_MODULE_0__.peekGraph)(storeWrapper)?.push({op:'deleteRecord',record:identifier,isNew:true});}else{(0,_ember_data_graph_private__WEBPACK_IMPORTED_MODULE_0__.peekGraph)(storeWrapper)?.unload(identifier);}// effectively clearing these is ensuring that\n// we report as `isEmpty` during teardown.\ncached.localAttrs=null;cached.remoteAttrs=null;cached.defaultAttrs=null;cached.inflightAttrs=null;const relatedIdentifiers=_allRelatedIdentifiers(storeWrapper,identifier);if(areAllModelsUnloaded(storeWrapper,relatedIdentifiers)){for(let i=0;i<relatedIdentifiers.length;++i){const relatedIdentifier=relatedIdentifiers[i];storeWrapper.notifyChange(relatedIdentifier,'removed');removed=true;storeWrapper.disconnectRecord(relatedIdentifier);}}this.__cache.delete(identifier);this.__destroyedCache.set(identifier,cached);/*\n     * The destroy cache is a hack to prevent applications\n     * from blowing up during teardown. Accessing state\n     * on a destroyed record is not safe, but historically\n     * was possible due to a combination of teardown timing\n     * and retention of cached state directly on the\n     * record itself.\n     *\n     * Once we have deprecated accessing state on a destroyed\n     * instance we may remove this. The timing isn't a huge deal\n     * as momentarily retaining the objects outside the bounds\n     * of a test won't cause issues.\n     */if(this.__destroyedCache.size===1){// TODO do we still need this?\nsetTimeout(()=>{this.__destroyedCache.clear();},100);}if(!removed&&removeFromRecordArray){storeWrapper.notifyChange(identifier,'removed');}}// Granular Resource Data APIs\n// ===========================\n/**\n   * Retrieve the data for an attribute from the cache\n   *\n   * @method getAttr\n   * @public\n   * @param identifier\n   * @param field\n   * @return {unknown}\n   */getAttr(identifier,attr){const isSimplePath=!Array.isArray(attr)||attr.length===1;if(Array.isArray(attr)&&attr.length===1){attr=attr[0];}if(isSimplePath){const attribute=attr;const cached=this.__peek(identifier,true);if(cached.localAttrs&&attribute in cached.localAttrs){return cached.localAttrs[attribute];}else if(cached.inflightAttrs&&attribute in cached.inflightAttrs){return cached.inflightAttrs[attribute];}else if(cached.remoteAttrs&&attribute in cached.remoteAttrs){return cached.remoteAttrs[attribute];}else if(cached.defaultAttrs&&attribute in cached.defaultAttrs){return cached.defaultAttrs[attribute];}else{const attrSchema=this._capabilities.schema.fields(identifier).get(attribute);upgradeCapabilities(this._capabilities);const defaultValue=getDefaultValue(attrSchema,identifier,this._capabilities._store);if(schemaHasLegacyDefaultValueFn(attrSchema)){cached.defaultAttrs=cached.defaultAttrs||Object.create(null);cached.defaultAttrs[attribute]=defaultValue;}return defaultValue;}}// TODO @runspired consider whether we need a defaultValue cache in SchemaRecord\n// like we do for the simple case above.\nconst path=attr;const cached=this.__peek(identifier,true);const basePath=path[0];let current=cached.localAttrs&&basePath in cached.localAttrs?cached.localAttrs[basePath]:undefined;if(current===undefined){current=cached.inflightAttrs&&basePath in cached.inflightAttrs?cached.inflightAttrs[basePath]:undefined;}if(current===undefined){current=cached.remoteAttrs&&basePath in cached.remoteAttrs?cached.remoteAttrs[basePath]:undefined;}if(current===undefined){return undefined;}for(let i=1;i<path.length;i++){current=current[path[i]];if(current===undefined){return undefined;}}return current;}/**\n   * Mutate the data for an attribute in the cache\n   *\n   * This method is a candidate to become a mutation\n   *\n   * @method setAttr\n   * @public\n   * @param identifier\n   * @param field\n   * @param value\n   */setAttr(identifier,attr,value){// this assert works to ensure we have a non-empty string and/or a non-empty array\n(test=>{if(!test){throw new Error('setAttr must receive at least one attribute path');}})(attr.length>0);const isSimplePath=!Array.isArray(attr)||attr.length===1;if(Array.isArray(attr)&&attr.length===1){attr=attr[0];}if(isSimplePath){const cached=this.__peek(identifier,false);const currentAttr=attr;const existing=cached.inflightAttrs&&currentAttr in cached.inflightAttrs?cached.inflightAttrs[currentAttr]:cached.remoteAttrs&&currentAttr in cached.remoteAttrs?cached.remoteAttrs[currentAttr]:undefined;if(existing!==value){cached.localAttrs=cached.localAttrs||Object.create(null);cached.localAttrs[currentAttr]=value;cached.changes=cached.changes||Object.create(null);cached.changes[currentAttr]=[existing,value];}else if(cached.localAttrs){delete cached.localAttrs[currentAttr];delete cached.changes[currentAttr];}if(cached.defaultAttrs&&currentAttr in cached.defaultAttrs){delete cached.defaultAttrs[currentAttr];}this._capabilities.notifyChange(identifier,'attributes',currentAttr);return;}// get current value from local else inflight else remote\n// structuredClone current if not local (or always?)\n// traverse path, update value at path\n// notify change at first link in path.\n// second pass optimization is change notifyChange signature to take an array path\n// guaranteed that we have path of at least 2 in length\nconst path=attr;const cached=this.__peek(identifier,false);// get existing cache record for base path\nconst basePath=path[0];const existing=cached.inflightAttrs&&basePath in cached.inflightAttrs?cached.inflightAttrs[basePath]:cached.remoteAttrs&&basePath in cached.remoteAttrs?cached.remoteAttrs[basePath]:undefined;let existingAttr;if(existing){existingAttr=existing[path[1]];for(let i=2;i<path.length;i++){// the specific change we're making is at path[length - 1]\nexistingAttr=existingAttr[path[i]];}}if(existingAttr!==value){cached.localAttrs=cached.localAttrs||Object.create(null);cached.localAttrs[basePath]=cached.localAttrs[basePath]||structuredClone(existing);cached.changes=cached.changes||Object.create(null);let currentLocal=cached.localAttrs[basePath];let nextLink=1;while(nextLink<path.length-1){currentLocal=currentLocal[path[nextLink++]];}currentLocal[path[nextLink]]=value;cached.changes[basePath]=[existing,cached.localAttrs[basePath]];// since we initiaize the value as basePath as a clone of the value at the remote basePath\n// then in theory we can use JSON.stringify to compare the two values as key insertion order\n// ought to be consistent.\n// we try/catch this because users have a habit of doing \"Bad Things\"TM wherein the cache contains\n// stateful values that are not JSON serializable correctly such as Dates.\n// in the case that we error, we fallback to not removing the local value\n// so that any changes we don't understand are preserved. Thse objects would then sometimes\n// appear to be dirty unnecessarily, and for folks that open an issue we can guide them\n// to make their cache data less stateful.\n}else if(cached.localAttrs){try{if(!existing){return;}const existingStr=JSON.stringify(existing);const newStr=JSON.stringify(cached.localAttrs[basePath]);if(existingStr!==newStr){delete cached.localAttrs[basePath];delete cached.changes[basePath];}}catch{// noop\n}}this._capabilities.notifyChange(identifier,'attributes',basePath);}/**\n   * Query the cache for the changed attributes of a resource.\n   *\n   * @method changedAttrs\n   * @public\n   * @param identifier\n   * @return {ChangedAttributesHash} { <field>: [<old>, <new>] }\n   */changedAttrs(identifier){// TODO freeze in dev\nreturn this.__peek(identifier,false).changes||Object.create(null);}/**\n   * Query the cache for whether any mutated attributes exist\n   *\n   * @method hasChangedAttrs\n   * @public\n   * @param identifier\n   * @return {boolean}\n   */hasChangedAttrs(identifier){const cached=this.__peek(identifier,true);return cached.inflightAttrs!==null&&Object.keys(cached.inflightAttrs).length>0||cached.localAttrs!==null&&Object.keys(cached.localAttrs).length>0;}/**\n   * Tell the cache to discard any uncommitted mutations to attributes\n   *\n   * This method is a candidate to become a mutation\n   *\n   * @method rollbackAttrs\n   * @public\n   * @param identifier\n   * @return {string[]} the names of fields that were restored\n   */rollbackAttrs(identifier){const cached=this.__peek(identifier,false);let dirtyKeys;cached.isDeleted=false;if(cached.localAttrs!==null){dirtyKeys=Object.keys(cached.localAttrs);cached.localAttrs=null;cached.changes=null;}if(cached.isNew){// > Note: Graph removal handled by unloadRecord\ncached.isDeletionCommitted=true;cached.isDeleted=true;cached.isNew=false;}cached.inflightAttrs=null;cached.defaultAttrs=null;if(cached.errors){cached.errors=null;this._capabilities.notifyChange(identifier,'errors');}this._capabilities.notifyChange(identifier,'state');if(dirtyKeys&&dirtyKeys.length){notifyAttributes(this._capabilities,identifier,dirtyKeys);}return dirtyKeys||[];}/**\n     * Query the cache for the changes to relationships of a resource.\n     *\n     * Returns a map of relationship names to RelationshipDiff objects.\n     *\n     * ```ts\n     * type RelationshipDiff =\n    | {\n        kind: 'collection';\n        remoteState: StableRecordIdentifier[];\n        additions: Set<StableRecordIdentifier>;\n        removals: Set<StableRecordIdentifier>;\n        localState: StableRecordIdentifier[];\n        reordered: boolean;\n      }\n    | {\n        kind: 'resource';\n        remoteState: StableRecordIdentifier | null;\n        localState: StableRecordIdentifier | null;\n      };\n      ```\n     *\n     * @method changedRelationships\n     * @public\n     * @param {StableRecordIdentifier} identifier\n     * @return {Map<string, RelationshipDiff>}\n     */changedRelationships(identifier){return this.__graph.getChanged(identifier);}/**\n   * Query the cache for whether any mutated relationships exist\n   *\n   * @method hasChangedRelationships\n   * @public\n   * @param {StableRecordIdentifier} identifier\n   * @return {boolean}\n   */hasChangedRelationships(identifier){return this.__graph.hasChanged(identifier);}/**\n   * Tell the cache to discard any uncommitted mutations to relationships.\n   *\n   * This will also discard the change on any appropriate inverses.\n   *\n   * This method is a candidate to become a mutation\n   *\n   * @method rollbackRelationships\n   * @public\n   * @param {StableRecordIdentifier} identifier\n   * @return {string[]} the names of relationships that were restored\n   */rollbackRelationships(identifier){upgradeCapabilities(this._capabilities);let result;this._capabilities._store._join(()=>{result=this.__graph.rollback(identifier);});return result;}/**\n   * Query the cache for the current state of a relationship property\n   *\n   * @method getRelationship\n   * @public\n   * @param identifier\n   * @param field\n   * @return resource relationship object\n   */getRelationship(identifier,field){return this.__graph.getData(identifier,field);}// Resource State\n// ===============\n/**\n   * Update the cache state for the given resource to be marked\n   * as locally deleted, or remove such a mark.\n   *\n   * This method is a candidate to become a mutation\n   *\n   * @method setIsDeleted\n   * @public\n   * @param identifier\n   * @param isDeleted {boolean}\n   */setIsDeleted(identifier,isDeleted){const cached=this.__peek(identifier,false);cached.isDeleted=isDeleted;// > Note: Graph removal for isNew handled by unloadRecord\nthis._capabilities.notifyChange(identifier,'state');}/**\n   * Query the cache for any validation errors applicable to the given resource.\n   *\n   * @method getErrors\n   * @public\n   * @param identifier\n   * @return {JsonApiError[]}\n   */getErrors(identifier){return this.__peek(identifier,true).errors||[];}/**\n   * Query the cache for whether a given resource has any available data\n   *\n   * @method isEmpty\n   * @public\n   * @param identifier\n   * @return {boolean}\n   */isEmpty(identifier){const cached=this.__safePeek(identifier,true);return cached?cached.remoteAttrs===null&&cached.inflightAttrs===null&&cached.localAttrs===null:true;}/**\n   * Query the cache for whether a given resource was created locally and not\n   * yet persisted.\n   *\n   * @method isNew\n   * @public\n   * @param identifier\n   * @return {boolean}\n   */isNew(identifier){// TODO can we assert here?\nreturn this.__safePeek(identifier,true)?.isNew||false;}/**\n   * Query the cache for whether a given resource is marked as deleted (but not\n   * necessarily persisted yet).\n   *\n   * @method isDeleted\n   * @public\n   * @param identifier\n   * @return {boolean}\n   */isDeleted(identifier){// TODO can we assert here?\nreturn this.__safePeek(identifier,true)?.isDeleted||false;}/**\n   * Query the cache for whether a given resource has been deleted and that deletion\n   * has also been persisted.\n   *\n   * @method isDeletionCommitted\n   * @public\n   * @param identifier\n   * @return {boolean}\n   */isDeletionCommitted(identifier){// TODO can we assert here?\nreturn this.__safePeek(identifier,true)?.isDeletionCommitted||false;}/**\n   * Private method used to populate an entry for the identifier\n   *\n   * @method _createCache\n   * @internal\n   * @param {StableRecordIdentifier} identifier\n   * @return {CachedResource}\n   */_createCache(identifier){(test=>{if(!test){throw new Error(`Expected no resource data to yet exist in the cache`);}})(!this.__cache.has(identifier));const cache=makeCache();this.__cache.set(identifier,cache);return cache;}/**\n   * Peek whether we have cached resource data matching the identifier\n   * without asserting if the resource data is missing.\n   *\n   * @method __safePeek\n   * @param {StableRecordIdentifier} identifier\n   * @param {Boolean} allowDestroyed\n   * @internal\n   * @return {CachedResource | undefined}\n   */__safePeek(identifier,allowDestroyed){let resource=this.__cache.get(identifier);if(!resource&&allowDestroyed){resource=this.__destroyedCache.get(identifier);}return resource;}/**\n   * Peek whether we have cached resource data matching the identifier\n   * Asserts if the resource data is missing.\n   *\n   * @method __Peek\n   * @param {StableRecordIdentifier} identifier\n   * @param {Boolean} allowDestroyed\n   * @internal\n   * @return {CachedResource}\n   */__peek(identifier,allowDestroyed){const resource=this.__safePeek(identifier,allowDestroyed);(test=>{if(!test){throw new Error(`Expected Cache to have a resource entry for the identifier ${String(identifier)} but none was found`);}})(resource);return resource;}}function areAllModelsUnloaded(wrapper,identifiers){for(let i=0;i<identifiers.length;++i){const identifier=identifiers[i];if(wrapper.hasRecord(identifier)){return false;}}return true;}function getLocalState(rel){if((0,_ember_data_graph_private__WEBPACK_IMPORTED_MODULE_0__.isBelongsTo)(rel)){return rel.localState?[rel.localState]:[];}return rel.additions?[...rel.additions]:[];}function getRemoteState(rel){if((0,_ember_data_graph_private__WEBPACK_IMPORTED_MODULE_0__.isBelongsTo)(rel)){return rel.remoteState?[rel.remoteState]:[];}return rel.remoteState;}function schemaHasLegacyDefaultValueFn(schema){if(!schema)return false;return hasLegacyDefaultValueFn(schema.options);}function hasLegacyDefaultValueFn(options){return!!options&&typeof options.defaultValue==='function';}function getDefaultValue(schema,identifier,store){const options=schema?.options;if(!schema||!options&&!schema.type){return;}if(schema.kind!=='attribute'&&schema.kind!=='field'){return;}// legacy support for defaultValues that are functions\nif(hasLegacyDefaultValueFn(options)){// If anyone opens an issue for args not working right, we'll restore + deprecate it via a Proxy\n// that lazily instantiates the record. We don't want to provide any args here\n// because in a non @ember-data/model world they don't make sense.\nreturn options.defaultValue();// legacy support for defaultValues that are primitives\n}else if(options&&'defaultValue'in options){const defaultValue=options.defaultValue;(test=>{if(!test){throw new Error(`Non primitive defaultValues are not supported because they are shared between all instances. If you would like to use a complex object as a default value please provide a function that returns the complex object.`);}})(typeof defaultValue!=='object'||defaultValue===null);return defaultValue;// new style transforms\n}else if(schema.kind!=='attribute'&&schema.type){const transform=store.schema.transformation(schema);if(transform?.defaultValue){return transform.defaultValue(options||null,identifier);}}}function notifyAttributes(storeWrapper,identifier,keys){if(!keys){storeWrapper.notifyChange(identifier,'attributes');return;}for(let i=0;i<keys.length;i++){storeWrapper.notifyChange(identifier,'attributes',keys[i]);}}/*\n      TODO @deprecate IGOR DAVID\n      There seems to be a potential bug here, where we will return keys that are not\n      in the schema\n  */function calculateChangedKeys(cached,updates){const changedKeys=[];if(updates){const keys=Object.keys(updates);const length=keys.length;const localAttrs=cached.localAttrs;const original=Object.assign(Object.create(null),cached.remoteAttrs,cached.inflightAttrs);for(let i=0;i<length;i++){const key=keys[i];const value=updates[key];// A value in localAttrs means the user has a local change to\n// this attribute. We never override this value when merging\n// updates from the backend so we should not sent a change\n// notification if the server value differs from the original.\nif(localAttrs&&localAttrs[key]!==undefined){continue;}if(original[key]!==value){changedKeys.push(key);}}}return changedKeys;}function cacheIsEmpty(cached){return!cached||cached.remoteAttrs===null&&cached.inflightAttrs===null&&cached.localAttrs===null;}function _isEmpty(peeked){if(!peeked){return true;}const isNew=peeked.isNew;const isDeleted=peeked.isDeleted;const isEmpty=cacheIsEmpty(peeked);return(!isNew||isDeleted)&&isEmpty;}function recordIsLoaded(cached,filterDeleted=false){if(!cached){return false;}const isNew=cached.isNew;const isEmpty=cacheIsEmpty(cached);// if we are new we must consider ourselves loaded\nif(isNew){return!cached.isDeleted;}// even if we have a past request, if we are now empty we are not loaded\n// typically this is true after an unloadRecord call\n// if we are not empty, not new && we have a fulfilled request then we are loaded\n// we should consider allowing for something to be loaded that is simply \"not empty\".\n// which is how RecordState currently handles this case; however, RecordState is buggy\n// in that it does not account for unloading.\nreturn filterDeleted&&cached.isDeletionCommitted?false:!isEmpty;}function _isLoading(peeked,capabilities,identifier){// TODO refactor things such that the cache is not required to know\n// about isLoading\nconst req=capabilities._store.getRequestStateService();// const fulfilled = req.getLastRequestForRecord(identifier);\nconst isLoaded=recordIsLoaded(peeked);return!isLoaded&&// fulfilled === null &&\nreq.getPendingRequestsForRecord(identifier).some(r=>r.type==='query');}function setupRelationships(graph,capabilities,identifier,data){// TODO @runspired iterating by definitions instead of by payload keys\n// allows relationship payloads to be ignored silently if no relationship\n// definition exists. Ensure there's a test for this and then consider\n// moving this to an assertion. This check should possibly live in the graph.\nconst fields=capabilities.schema.fields(identifier);for(const[name,field]of fields){if(!isRelationship(field))continue;const relationshipData=data.relationships[name];if(!relationshipData)continue;graph.push({op:'updateRelationship',record:identifier,field:name,value:relationshipData});}}const RelationshipKinds=new Set(['hasMany','belongsTo','resource','collection']);function isRelationship(field){return RelationshipKinds.has(field.kind);}function patchLocalAttributes(cached){const{localAttrs,remoteAttrs,inflightAttrs,defaultAttrs,changes}=cached;if(!localAttrs){cached.changes=null;return false;}let hasAppliedPatch=false;const mutatedKeys=Object.keys(localAttrs);for(let i=0,length=mutatedKeys.length;i<length;i++){const attr=mutatedKeys[i];const existing=inflightAttrs&&attr in inflightAttrs?inflightAttrs[attr]:remoteAttrs&&attr in remoteAttrs?remoteAttrs[attr]:undefined;if(existing===localAttrs[attr]){hasAppliedPatch=true;delete localAttrs[attr];delete changes[attr];}if(defaultAttrs&&attr in defaultAttrs){delete defaultAttrs[attr];}}return hasAppliedPatch;}function putOne(cache,identifiers,resource){(test=>{if(!test){throw new Error(`You must include an 'id' for the resource data ${resource.type}`);}})(resource.id!==null&&resource.id!==undefined&&resource.id!=='');(test=>{if(!test){throw new Error(`Missing Resource Type: received resource data with a type '${resource.type}' but no schema could be found with that name.`);}})(cache._capabilities.schema.hasResource(resource));let identifier=identifiers.peekRecordIdentifier(resource);if(identifier){identifier=identifiers.updateRecordIdentifier(identifier,resource);}else{identifier=identifiers.getOrCreateRecordIdentifier(resource);}cache.upsert(identifier,resource,cache._capabilities.hasRecord(identifier));// even if the identifier was not \"existing\" before, it is now\nreturn identifier;}/*\n    Iterates over the set of internal models reachable from `this` across exactly one\n    relationship.\n  */function _directlyRelatedIdentifiersIterable(storeWrapper,originating){const graph=(0,_ember_data_graph_private__WEBPACK_IMPORTED_MODULE_0__.peekGraph)(storeWrapper);const initializedRelationships=graph?.identifiers.get(originating);if(!initializedRelationships){return EMPTY_ITERATOR;}const initializedRelationshipsArr=[];Object.keys(initializedRelationships).forEach(key=>{const rel=initializedRelationships[key];if(rel&&!isImplicit(rel)){initializedRelationshipsArr.push(rel);}});let i=0;let j=0;let k=0;const findNext=()=>{while(i<initializedRelationshipsArr.length){while(j<2){const relatedIdentifiers=j===0?getLocalState(initializedRelationshipsArr[i]):getRemoteState(initializedRelationshipsArr[i]);while(k<relatedIdentifiers.length){const relatedIdentifier=relatedIdentifiers[k++];if(relatedIdentifier!==null){return relatedIdentifier;}}k=0;j++;}j=0;i++;}return undefined;};return{iterator(){return{next:()=>{const value=findNext();return{value,done:value===undefined};}};}};}/*\n      Computes the set of Identifiers reachable from this Identifier.\n\n      Reachability is determined over the relationship graph (ie a graph where\n      nodes are identifiers and edges are belongs to or has many\n      relationships).\n\n      Returns an array including `this` and all identifiers reachable\n      from `this.identifier`.\n    */function _allRelatedIdentifiers(storeWrapper,originating){const array=[];const queue=[];const seen=new Set();queue.push(originating);while(queue.length>0){const identifier=queue.shift();array.push(identifier);seen.add(identifier);const iterator=_directlyRelatedIdentifiersIterable(storeWrapper,originating).iterator();for(let obj=iterator.next();!obj.done;obj=iterator.next()){const relatedIdentifier=obj.value;if(relatedIdentifier&&!seen.has(relatedIdentifier)){seen.add(relatedIdentifier);queue.push(relatedIdentifier);}}}return array;}function isMetaDocument(doc){return!(doc instanceof Error)&&doc.content&&!('data'in doc.content)&&!('included'in doc.content)&&'meta'in doc.content;}function isErrorDocument(doc){return doc instanceof Error;}function fromBaseDocument(doc){const resourceDocument={};const jsonApiDoc=doc.content;if(jsonApiDoc){copyLinksAndMeta(resourceDocument,jsonApiDoc);}return resourceDocument;}function fromStructuredError(doc){const errorDoc={};if(doc.content){copyLinksAndMeta(errorDoc,doc.content);if('errors'in doc.content){errorDoc.errors=doc.content.errors;}else if(typeof doc.error==='object'&&'errors'in doc.error){errorDoc.errors=doc.error.errors;}else{errorDoc.errors=[{title:doc.message}];}}return errorDoc;}function copyLinksAndMeta(target,source){if('links'in source){target.links=source.links;}if('meta'in source){target.meta=source.meta;}}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@ember-data/json-api/dist/index.js?");

/***/ }),

/***/ "./node_modules/@ember-data/json-api/dist/request.js":
/*!***********************************************************!*\
  !*** ./node_modules/@ember-data/json-api/dist/request.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createRecord: () => (/* binding */ createRecord),\n/* harmony export */   deleteRecord: () => (/* binding */ deleteRecord),\n/* harmony export */   findRecord: () => (/* binding */ findRecord),\n/* harmony export */   postQuery: () => (/* binding */ postQuery),\n/* harmony export */   query: () => (/* binding */ query),\n/* harmony export */   serializePatch: () => (/* binding */ serializePatch),\n/* harmony export */   serializeResources: () => (/* binding */ serializeResources),\n/* harmony export */   setBuildURLConfig: () => (/* binding */ setBuildURLConfig),\n/* harmony export */   updateRecord: () => (/* binding */ updateRecord)\n/* harmony export */ });\n/* harmony import */ var _ember_data_request_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ember-data/request-utils */ \"./node_modules/@ember-data/request-utils/dist/index.js\");\n/* harmony import */ var _ember_data_request_utils_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ember-data/request-utils/string */ \"./node_modules/@ember-data/request-utils/dist/string.js\");\n/* harmony import */ var _ember_data_store__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ember-data/store */ \"./node_modules/@ember-data/store/dist/index.js\");\n/**\n * @module @ember-data/json-api/request\n */const JsonApiAccept='application/vnd.api+json';const DEFAULT_CONFIG={host:'',namespace:''};let ACCEPT_HEADER_VALUE='application/vnd.api+json';/**\n * Allows setting extensions and profiles to be used in the `Accept` header.\n *\n * Extensions and profiles are keyed by their namespace with the value being\n * their URI.\n *\n * Example:\n *\n * ```ts\n * setBuildURLConfig({\n *   extensions: {\n *     atomic: 'https://jsonapi.org/ext/atomic'\n *   },\n *   profiles: {\n *     pagination: 'https://jsonapi.org/profiles/ethanresnick/cursor-pagination'\n *   }\n * });\n * ```\n *\n * This also sets the global configuration for `buildBaseURL`\n * for host and namespace values for the application\n * in the `@ember-data/request-utils` package.\n *\n * These values may still be overridden by passing\n * them to buildBaseURL directly.\n *\n * This method may be called as many times as needed\n *\n * ```ts\n * type BuildURLConfig = {\n *   host: string;\n *   namespace: string'\n * }\n * ```\n *\n * @method setBuildURLConfig\n * @static\n * @public\n * @for @ember-data/json-api/request\n * @param {BuildURLConfig} config\n * @return void\n */function setBuildURLConfig(config){Object.assign({},DEFAULT_CONFIG,config);if(config.profiles||config.extensions){let accept=JsonApiAccept;if(config.profiles){const profiles=Object.values(config.profiles);if(profiles.length){accept+=';profile=\"'+profiles.join(' ')+'\"';}}if(config.extensions){const extensions=Object.values(config.extensions);if(extensions.length){accept+=';ext='+extensions.join(' ');}}ACCEPT_HEADER_VALUE=accept;}(0,_ember_data_request_utils__WEBPACK_IMPORTED_MODULE_0__.setBuildURLConfig)(config);}function copyForwardUrlOptions(urlOptions,options){if('host'in options){urlOptions.host=options.host;}if('namespace'in options){urlOptions.namespace=options.namespace;}if('resourcePath'in options){urlOptions.resourcePath=options.resourcePath;}}function extractCacheOptions(options){const cacheOptions={};if('reload'in options){cacheOptions.reload=options.reload;}if('backgroundReload'in options){cacheOptions.backgroundReload=options.backgroundReload;}return cacheOptions;}/**\n * @module @ember-data/json-api/request\n *//**\n * Builds request options to fetch a single resource by a known id or identifier\n * configured for the url and header expectations of most JSON:API APIs.\n *\n * **Basic Usage**\n *\n * ```ts\n * import { findRecord } from '@ember-data/json-api/request';\n *\n * const data = await store.request(findRecord('person', '1'));\n * ```\n *\n * **With Options**\n *\n * ```ts\n * import { findRecord } from '@ember-data/json-api/request';\n *\n * const options = findRecord('person', '1', { include: ['pets', 'friends'] });\n * const data = await store.request(options);\n * ```\n *\n * **With an Identifier**\n *\n * ```ts\n * import { findRecord } from '@ember-data/json-api/request';\n *\n * const options = findRecord({ type: 'person', id: '1' }, { include: ['pets', 'friends'] });\n * const data = await store.request(options);\n * ```\n *\n * **Supplying Options to Modify the Request Behavior**\n *\n * The following options are supported:\n *\n * - `host` - The host to use for the request, defaults to the `host` configured with `setBuildURLConfig`.\n * - `namespace` - The namespace to use for the request, defaults to the `namespace` configured with `setBuildURLConfig`.\n * - `resourcePath` - The resource path to use for the request, defaults to pluralizing the supplied type\n * - `reload` - Whether to forcibly reload the request if it is already in the store, not supplying this\n *      option will delegate to the store's CachePolicy, defaulting to `false` if none is configured.\n * - `backgroundReload` - Whether to reload the request if it is already in the store, but to also resolve the\n *      promise with the cached value, not supplying this option will delegate to the store's CachePolicy,\n *      defaulting to `false` if none is configured.\n * - `urlParamsSetting` - an object containing options for how to serialize the query params (see `buildQueryParams`)\n *\n * ```ts\n * import { findRecord } from '@ember-data/json-api/request';\n *\n * const options = findRecord('person', '1', { include: ['pets', 'friends'] }, { namespace: 'api/v2' });\n * const data = await store.request(options);\n * ```\n *\n * @method findRecord\n * @public\n * @static\n * @for @ember-data/json-api/request\n * @param identifier\n * @param options\n */function findRecord(arg1,arg2,arg3){const identifier=typeof arg1==='string'?{type:arg1,id:arg2}:arg1;const options=(typeof arg1==='string'?arg3:arg2)||{};const cacheOptions=extractCacheOptions(options);const urlOptions={identifier,op:'findRecord',resourcePath:(0,_ember_data_request_utils_string__WEBPACK_IMPORTED_MODULE_1__.pluralize)(identifier.type)};copyForwardUrlOptions(urlOptions,options);const url=(0,_ember_data_request_utils__WEBPACK_IMPORTED_MODULE_0__.buildBaseURL)(urlOptions);const headers=new Headers();headers.append('Accept',ACCEPT_HEADER_VALUE);return{url:options.include?.length?`${url}?${(0,_ember_data_request_utils__WEBPACK_IMPORTED_MODULE_0__.buildQueryParams)({include:options.include},options.urlParamsSettings)}`:url,method:'GET',headers,cacheOptions,op:'findRecord',records:[identifier]};}/**\n * @module @ember-data/json-api/request\n *//**\n * Builds request options to query for resources, usually by a primary\n * type, configured for the url and header expectations of most JSON:API APIs.\n *\n * The key difference between this and `postQuery` is that this method will send the query\n * as query params in the url of a \"GET\" request instead of as the JSON body of a \"POST\"\n * request.\n *\n * **Basic Usage**\n *\n * ```ts\n * import { query } from '@ember-data/json-api/request';\n *\n * const data = await store.request(query('person'));\n * ```\n *\n * **With Query Params**\n *\n * ```ts\n * import { query } from '@ember-data/json-api/request';\n *\n * const options = query('person', { include: ['pets', 'friends'] });\n * const data = await store.request(options);\n * ```\n *\n * **Supplying Options to Modify the Request Behavior**\n *\n * The following options are supported:\n *\n * - `host` - The host to use for the request, defaults to the `host` configured with `setBuildURLConfig`.\n * - `namespace` - The namespace to use for the request, defaults to the `namespace` configured with `setBuildURLConfig`.\n * - `resourcePath` - The resource path to use for the request, defaults to pluralizing the supplied type\n * - `reload` - Whether to forcibly reload the request if it is already in the store, not supplying this\n *      option will delegate to the store's CachePolicy, defaulting to `false` if none is configured.\n * - `backgroundReload` - Whether to reload the request if it is already in the store, but to also resolve the\n *      promise with the cached value, not supplying this option will delegate to the store's CachePolicy,\n *      defaulting to `false` if none is configured.\n * - `urlParamsSetting` - an object containing options for how to serialize the query params (see `buildQueryParams`)\n *\n * ```ts\n * import { query } from '@ember-data/json-api/request';\n *\n * const options = query('person', { include: ['pets', 'friends'] }, { reload: true });\n * const data = await store.request(options);\n * ```\n *\n * @method query\n * @public\n * @static\n * @for @ember-data/json-api/request\n * @param identifier\n * @param query\n * @param options\n */function query(type,// eslint-disable-next-line @typescript-eslint/no-shadow\nquery={},options={}){const cacheOptions=extractCacheOptions(options);const urlOptions={identifier:{type},op:'query',resourcePath:(0,_ember_data_request_utils_string__WEBPACK_IMPORTED_MODULE_1__.pluralize)(type)};copyForwardUrlOptions(urlOptions,options);const url=(0,_ember_data_request_utils__WEBPACK_IMPORTED_MODULE_0__.buildBaseURL)(urlOptions);const headers=new Headers();headers.append('Accept',ACCEPT_HEADER_VALUE);const queryString=(0,_ember_data_request_utils__WEBPACK_IMPORTED_MODULE_0__.buildQueryParams)(query,options.urlParamsSettings);return{url:queryString?`${url}?${queryString}`:url,method:'GET',headers,cacheOptions,op:'query'};}/**\n * Builds request options to query for resources, usually by a primary\n * type, configured for the url and header expectations of most JSON:API APIs.\n *\n * The key difference between this and `query` is that this method will send the query\n * as the JSON body of a \"POST\" request instead of as query params in the url of a \"GET\"\n * request.\n *\n * A CacheKey is generated from the url and query params, and used to cache the response\n * in the store.\n *\n * ```ts\n * import { postQuery } from '@ember-data/json-api/request';\n *\n * const options = postQuery('person', { include: ['pets', 'friends'] });\n * const data = await store.request(options);\n * ```\n *\n * **Supplying Options to Modify the Request Behavior**\n *\n * The following options are supported:\n *\n * - `host` - The host to use for the request, defaults to the `host` configured with `setBuildURLConfig`.\n * - `namespace` - The namespace to use for the request, defaults to the `namespace` configured with `setBuildURLConfig`.\n * - `resourcePath` - The resource path to use for the request, defaults to pluralizing the supplied type\n * - `reload` - Whether to forcibly reload the request if it is already in the store, not supplying this\n *      option will delegate to the store's CachePolicy, defaulting to `false` if none is configured.\n * - `backgroundReload` - Whether to reload the request if it is already in the store, but to also resolve the\n *      promise with the cached value, not supplying this option will delegate to the store's CachePolicy,\n *      defaulting to `false` if none is configured.\n * - `urlParamsSetting` - an object containing options for how to serialize the query params (see `buildQueryParams`)\n *\n * ```ts\n * import { postQuery } from '@ember-data/json-api/request';\n *\n * const options = postQuery('person', { include: ['pets', 'friends'] }, { reload: true });\n * const data = await store.request(options);\n * ```\n *\n * @method postQuery\n * @public\n * @static\n * @for @ember-data/json-api/request\n * @param identifier\n * @param query\n * @param options\n */function postQuery(type,// eslint-disable-next-line @typescript-eslint/no-shadow\nquery={},options={}){const cacheOptions=extractCacheOptions(options);const urlOptions={identifier:{type},op:'query',resourcePath:options.resourcePath??(0,_ember_data_request_utils_string__WEBPACK_IMPORTED_MODULE_1__.pluralize)(type)};copyForwardUrlOptions(urlOptions,options);const url=(0,_ember_data_request_utils__WEBPACK_IMPORTED_MODULE_0__.buildBaseURL)(urlOptions);const headers=new Headers();headers.append('Accept',ACCEPT_HEADER_VALUE);const queryData=structuredClone(query);cacheOptions.key=cacheOptions.key??`${url}?${(0,_ember_data_request_utils__WEBPACK_IMPORTED_MODULE_0__.buildQueryParams)(queryData,options.urlParamsSettings)}`;return{url,method:'POST',body:JSON.stringify(query),headers,cacheOptions:cacheOptions,op:'query'};}function isExisting(identifier){return'id'in identifier&&identifier.id!==null&&'type'in identifier&&identifier.type!==null;}/**\n * Builds request options to delete record for resources,\n * configured for the url, method and header expectations of most JSON:API APIs.\n *\n * **Basic Usage**\n *\n * ```ts\n * import { deleteRecord } from '@ember-data/json-api/request';\n *\n * const person = store.peekRecord('person', '1');\n *\n * // mark record as deleted\n * store.deleteRecord(person);\n *\n * // persist deletion\n * const data = await store.request(deleteRecord(person));\n * ```\n *\n * **Supplying Options to Modify the Request Behavior**\n *\n * The following options are supported:\n *\n * - `host` - The host to use for the request, defaults to the `host` configured with `setBuildURLConfig`.\n * - `namespace` - The namespace to use for the request, defaults to the `namespace` configured with `setBuildURLConfig`.\n * - `resourcePath` - The resource path to use for the request, defaults to pluralizing the supplied type\n * - `reload` - Whether to forcibly reload the request if it is already in the store, not supplying this\n *      option will delegate to the store's CachePolicy, defaulting to `false` if none is configured.\n * - `backgroundReload` - Whether to reload the request if it is already in the store, but to also resolve the\n *      promise with the cached value, not supplying this option will delegate to the store's CachePolicy,\n *      defaulting to `false` if none is configured.\n * - `urlParamsSetting` - an object containing options for how to serialize the query params (see `buildQueryParams`)\n *\n * ```ts\n * import { deleteRecord } from '@ember-data/json-api/request';\n *\n * const person = store.peekRecord('person', '1');\n *\n * // mark record as deleted\n * store.deleteRecord(person);\n *\n * // persist deletion\n * const options = deleteRecord(person, { namespace: 'api/v1' });\n * const data = await store.request(options);\n * ```\n *\n * @method deleteRecord\n * @public\n * @static\n * @for @ember-data/json-api/request\n * @param record\n * @param options\n */function deleteRecord(record,options={}){const identifier=(0,_ember_data_store__WEBPACK_IMPORTED_MODULE_2__.recordIdentifierFor)(record);(test=>{if(!test){throw new Error(`Expected to be given a record instance`);}})(identifier);(test=>{if(!test){throw new Error(`Cannot delete a record that does not have an associated type and id.`);}})(isExisting(identifier));const urlOptions={identifier:identifier,op:'deleteRecord',resourcePath:(0,_ember_data_request_utils_string__WEBPACK_IMPORTED_MODULE_1__.pluralize)(identifier.type)};copyForwardUrlOptions(urlOptions,options);const url=(0,_ember_data_request_utils__WEBPACK_IMPORTED_MODULE_0__.buildBaseURL)(urlOptions);const headers=new Headers();headers.append('Accept',ACCEPT_HEADER_VALUE);return{url,method:'DELETE',headers,op:'deleteRecord',data:{record:identifier},records:[identifier]};}/**\n * Builds request options to create new record for resources,\n * configured for the url, method and header expectations of most JSON:API APIs.\n *\n * **Basic Usage**\n *\n * ```ts\n * import { createRecord } from '@ember-data/json-api/request';\n *\n * const person = store.createRecord('person', { name: 'Ted' });\n * const data = await store.request(createRecord(person));\n * ```\n *\n * **Supplying Options to Modify the Request Behavior**\n *\n * The following options are supported:\n *\n * - `host` - The host to use for the request, defaults to the `host` configured with `setBuildURLConfig`.\n * - `namespace` - The namespace to use for the request, defaults to the `namespace` configured with `setBuildURLConfig`.\n * - `resourcePath` - The resource path to use for the request, defaults to pluralizing the supplied type\n * - `reload` - Whether to forcibly reload the request if it is already in the store, not supplying this\n *      option will delegate to the store's CachePolicy, defaulting to `false` if none is configured.\n * - `backgroundReload` - Whether to reload the request if it is already in the store, but to also resolve the\n *      promise with the cached value, not supplying this option will delegate to the store's CachePolicy,\n *      defaulting to `false` if none is configured.\n * - `urlParamsSetting` - an object containing options for how to serialize the query params (see `buildQueryParams`)\n *\n * ```ts\n * import { createRecord } from '@ember-data/json-api/request';\n *\n * const person = store.createRecord('person', { name: 'Ted' });\n * const options = createRecord(person, { namespace: 'api/v1' });\n * const data = await store.request(options);\n * ```\n *\n * @method createRecord\n * @public\n * @static\n * @for @ember-data/json-api/request\n * @param record\n * @param options\n */function createRecord(record,options={}){const identifier=(0,_ember_data_store__WEBPACK_IMPORTED_MODULE_2__.recordIdentifierFor)(record);(test=>{if(!test){throw new Error(`Expected to be given a record instance`);}})(identifier);const urlOptions={identifier:identifier,op:'createRecord',resourcePath:(0,_ember_data_request_utils_string__WEBPACK_IMPORTED_MODULE_1__.pluralize)(identifier.type)};copyForwardUrlOptions(urlOptions,options);const url=(0,_ember_data_request_utils__WEBPACK_IMPORTED_MODULE_0__.buildBaseURL)(urlOptions);const headers=new Headers();headers.append('Accept',ACCEPT_HEADER_VALUE);return{url,method:'POST',headers,op:'createRecord',data:{record:identifier},records:[identifier]};}/**\n * Builds request options to update existing record for resources,\n * configured for the url, method and header expectations of most JSON:API APIs.\n *\n * **Basic Usage**\n *\n * ```ts\n * import { updateRecord } from '@ember-data/json-api/request';\n *\n * const person = store.peekRecord('person', '1');\n * person.name = 'Chris';\n * const data = await store.request(updateRecord(person));\n * ```\n *\n * **Supplying Options to Modify the Request Behavior**\n *\n * The following options are supported:\n *\n * - `patch` - Allows caller to specify whether to use a PATCH request instead of a PUT request, defaults to `false`.\n * - `host` - The host to use for the request, defaults to the `host` configured with `setBuildURLConfig`.\n * - `namespace` - The namespace to use for the request, defaults to the `namespace` configured with `setBuildURLConfig`.\n * - `resourcePath` - The resource path to use for the request, defaults to pluralizing the supplied type\n * - `reload` - Whether to forcibly reload the request if it is already in the store, not supplying this\n *      option will delegate to the store's CachePolicy, defaulting to `false` if none is configured.\n * - `backgroundReload` - Whether to reload the request if it is already in the store, but to also resolve the\n *      promise with the cached value, not supplying this option will delegate to the store's CachePolicy,\n *      defaulting to `false` if none is configured.\n * - `urlParamsSetting` - an object containing options for how to serialize the query params (see `buildQueryParams`)\n *\n * ```ts\n * import { updateRecord } from '@ember-data/json-api/request';\n *\n * const person = store.peekRecord('person', '1');\n * person.name = 'Chris';\n * const options = updateRecord(person, { patch: true });\n * const data = await store.request(options);\n * ```\n *\n * @method updateRecord\n * @public\n * @static\n * @for @ember-data/json-api/request\n * @param record\n * @param options\n */function updateRecord(record,options={}){const identifier=(0,_ember_data_store__WEBPACK_IMPORTED_MODULE_2__.recordIdentifierFor)(record);(test=>{if(!test){throw new Error(`Expected to be given a record instance`);}})(identifier);(test=>{if(!test){throw new Error(`Cannot update a record that does not have an associated type and id.`);}})(isExisting(identifier));const urlOptions={identifier:identifier,op:'updateRecord',resourcePath:(0,_ember_data_request_utils_string__WEBPACK_IMPORTED_MODULE_1__.pluralize)(identifier.type)};copyForwardUrlOptions(urlOptions,options);const url=(0,_ember_data_request_utils__WEBPACK_IMPORTED_MODULE_0__.buildBaseURL)(urlOptions);const headers=new Headers();headers.append('Accept',ACCEPT_HEADER_VALUE);return{url,method:options.patch?'PATCH':'PUT',headers,op:'updateRecord',data:{record:identifier},records:[identifier]};}/**\n * @module @ember-data/json-api/request\n *//**\n * Serializes the current state of a resource or array of resources for use with POST or PUT requests.\n *\n * @method serializeResources\n * @static\n * @public\n * @for @ember-data/json-api/request\n * @param {Cache} cache}\n * @param {StableRecordIdentifier} identifier\n * @return {object} An object with a `data` property containing the serialized resource patch\n */function serializeResources(cache,identifiers){return{data:Array.isArray(identifiers)?identifiers.map(identifier=>_serializeResource(cache,identifier)):_serializeResource(cache,identifiers)};}function _serializeResource(cache,identifier){const{id,lid,type}=identifier;// yup! this method actually does nothing. It's just here for the dev assertion\n// and to assist in providing a little sugar to the consuming app via the `serializeResources` utility\nconst record=cache.peek(identifier);(test=>{if(!test){throw new Error(`A record with id ${String(id)} and type ${type} for lid ${lid} was not found not in the supplied Cache.`);}})(record);return record;}/**\n * Serializes changes to a resource for use with PATCH requests.\n *\n * Only attributes which are changed are serialized.\n * Only relationships which are changed are serialized.\n *\n * Collection relationships serialize the collection as a whole.\n *\n * If you would like to serialize updates to a collection more granularly\n * (for instance, as operations) request the diff from the store and\n * serialize as desired:\n *\n * ```ts\n * const relationshipDiffMap = cache.changedRelationships(identifier);\n * ```\n *\n * @method serializePatch\n * @static\n * @public\n * @for @ember-data/json-api/request\n * @param {Cache} cache}\n * @param {StableRecordIdentifier} identifier\n * @return {object} An object with a `data` property containing the serialized resource patch\n */function serializePatch(cache,identifier){const{id,lid,type}=identifier;const record=cache.peek(identifier);(test=>{if(!test){throw new Error(`A record with id ${String(id)} and type ${type} for lid ${lid} was not found not in the supplied Cache.`);}})(record);const data={type,lid,id};if(cache.hasChangedAttrs(identifier)){const attrsChanges=cache.changedAttrs(identifier);const attributes={};Object.keys(attrsChanges).forEach(key=>{const change=attrsChanges[key];const newVal=change[1];attributes[key]=newVal===undefined?null:newVal;});data.attributes=attributes;}const changedRelationships=cache.changedRelationships(identifier);if(changedRelationships.size){const relationships={};changedRelationships.forEach((diff,key)=>{relationships[key]={data:diff.localState};});data.relationships=relationships;}return{data};}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@ember-data/json-api/dist/request.js?");

/***/ }),

/***/ "./node_modules/@ember-data/legacy-compat/dist/-private-Dlia0pw1.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@ember-data/legacy-compat/dist/-private-Dlia0pw1.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   F: () => (/* binding */ FetchManager),\n/* harmony export */   S: () => (/* binding */ SaveOp),\n/* harmony export */   a: () => (/* binding */ assertIdentifierHasId),\n/* harmony export */   b: () => (/* binding */ SnapshotRecordArray),\n/* harmony export */   c: () => (/* binding */ Snapshot),\n/* harmony export */   i: () => (/* binding */ iterateData),\n/* harmony export */   n: () => (/* binding */ normalizeResponseHelper),\n/* harmony export */   p: () => (/* binding */ payloadIsNotBlank),\n/* harmony export */   u: () => (/* binding */ upgradeStore)\n/* harmony export */ });\n/* harmony import */ var _ember_data_store_private__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ember-data/store/-private */ \"./node_modules/@ember-data/store/dist/-private.js\");\n/* harmony import */ var _ember_debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ember/debug */ \"@ember/debug\");\n/* harmony import */ var _ember_debug__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_ember_debug__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _ember_data_request__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ember-data/request */ \"./node_modules/@ember-data/request/dist/index.js\");\n/* harmony import */ var _warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @warp-drive/core-types/-private */ \"./node_modules/@warp-drive/core-types/dist/-private.js\");\n/* harmony import */ var _embroider_macros_src_addon_es_compat2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../@embroider/macros/src/addon/es-compat2 */ \"./node_modules/@embroider/macros/src/addon/es-compat2.js\");\n/**\n  @module @ember-data/legacy-compat\n*//**\n  SnapshotRecordArray is not directly instantiable.\n  Instances are provided to consuming application's\n  adapters for certain `findAll` requests.\n\n  @class SnapshotRecordArray\n  @public\n*/class SnapshotRecordArray{/**\n    SnapshotRecordArray is not directly instantiable.\n    Instances are provided to consuming application's\n    adapters and serializers for certain requests.\n     @method constructor\n    @private\n    @constructor\n    @param {Store} store\n    @param {string} type\n    @param options\n   */constructor(store,type,options={}){this.__store=store;/**\n      An array of snapshots\n      @private\n      @property _snapshots\n      @type {Array}\n    */this._snapshots=null;/**\n    The modelName of the underlying records for the snapshots in the array, as a Model\n    @property modelName\n    @public\n    @type {Model}\n    */this.modelName=type;/**\n      A hash of adapter options passed into the store method for this request.\n       Example\n       ```app/adapters/post.js\n      import MyCustomAdapter from './custom-adapter';\n       export default class PostAdapter extends MyCustomAdapter {\n        findAll(store, type, sinceToken, snapshotRecordArray) {\n          if (snapshotRecordArray.adapterOptions.subscribe) {\n            // ...\n          }\n          // ...\n        }\n      }\n      ```\n       @property adapterOptions\n      @public\n      @type {Object}\n    */this.adapterOptions=options.adapterOptions;/**\n      The relationships to include for this request.\n       Example\n       ```app/adapters/application.js\n      import Adapter from '@ember-data/adapter';\n       export default class ApplicationAdapter extends Adapter {\n        findAll(store, type, snapshotRecordArray) {\n          let url = `/${type.modelName}?include=${encodeURIComponent(snapshotRecordArray.include)}`;\n           return fetch(url).then((response) => response.json())\n        }\n      }\n      ```\n       @property include\n      @public\n      @type {String|Array}\n    */this.include=options.include;}/**\n    An array of records\n     @property _recordArray\n    @private\n    @type {Array}\n  */get _recordArray(){return this.__store.peekAll(this.modelName);}/**\n      Number of records in the array\n       Example\n       ```app/adapters/post.js\n      import JSONAPIAdapter from '@ember-data/adapter/json-api';\n       export default class PostAdapter extends JSONAPIAdapter {\n        shouldReloadAll(store, snapshotRecordArray) {\n          return !snapshotRecordArray.length;\n        }\n      });\n      ```\n       @property length\n      @public\n      @type {Number}\n    */get length(){return this._recordArray.length;}/**\n    Get snapshots of the underlying record array\n     Example\n     ```app/adapters/post.js\n    import JSONAPIAdapter from '@ember-data/adapter/json-api';\n     export default class PostAdapter extends JSONAPIAdapter {\n      shouldReloadAll(store, snapshotArray) {\n        let snapshots = snapshotArray.snapshots();\n         return snapshots.any(function(ticketSnapshot) {\n          let timeDiff = moment().diff(ticketSnapshot.attr('lastAccessedAt'), 'minutes');\n          if (timeDiff > 20) {\n            return true;\n          } else {\n            return false;\n          }\n        });\n      }\n    }\n    ```\n     @method snapshots\n    @public\n    @return {Array} Array of snapshots\n  */snapshots(){if(this._snapshots!==null){return this._snapshots;}upgradeStore(this.__store);const{_fetchManager}=this.__store;this._snapshots=this._recordArray[_ember_data_store_private__WEBPACK_IMPORTED_MODULE_0__.SOURCE].map(identifier=>_fetchManager.createSnapshot(identifier));return this._snapshots;}}function assertIdentifierHasId(identifier){(test=>{if(!test){throw new Error(`Attempted to schedule a fetch for a record without an id.`);}})(identifier&&identifier.id!==null);}function iterateData(data,fn){if(Array.isArray(data)){return data.map(fn);}else{return fn(data,0);}}function payloadIsNotBlank(adapterPayload){if(Array.isArray(adapterPayload)){return true;}else{return Object.keys(adapterPayload||{}).length!==0;}}/**\n  This is a helper method that validates a JSON API top-level document\n\n  The format of a document is described here:\n  http://jsonapi.org/format/#document-top-level\n\n  @internal\n*/function validateDocumentStructure(doc){{const errors=[];if(!doc||typeof doc!=='object'){errors.push('Top level of a JSON API document must be an object');}else{if(!('data'in doc)&&!('errors'in doc)&&!('meta'in doc)){errors.push('One or more of the following keys must be present: \"data\", \"errors\", \"meta\".');}else{if('data'in doc&&'errors'in doc){errors.push('Top level keys \"errors\" and \"data\" cannot both be present in a JSON API document');}}if('data'in doc){if(!(doc.data===null||Array.isArray(doc.data)||typeof doc.data==='object')){errors.push('data must be null, an object, or an array');}}if('meta'in doc){if(typeof doc.meta!=='object'){errors.push('meta must be an object');}}if('errors'in doc){if(!Array.isArray(doc.errors)){errors.push('errors must be an array');}}if('links'in doc){if(typeof doc.links!=='object'){errors.push('links must be an object');}}if('jsonapi'in doc){if(typeof doc.jsonapi!=='object'){errors.push('jsonapi must be an object');}}if('included'in doc){if(typeof doc.included!=='object'){errors.push('included must be an array');}}}(test=>{if(!test){throw new Error(`Response must be normalized to a valid JSON API document:\\n\\t* ${errors.join('\\n\\t* ')}`);}})(errors.length===0);}}function normalizeResponseHelper(serializer,store,modelClass,payload,id,requestType){const normalizedResponse=serializer?serializer.normalizeResponse(store,modelClass,payload,id,requestType):payload;validateDocumentStructure(normalizedResponse);return normalizedResponse;}/**\n  @module @ember-data/store\n*//**\n  Snapshot is not directly instantiable.\n  Instances are provided to a consuming application's\n  adapters and serializers for certain requests.\n\n  Snapshots are only available when using `@ember-data/legacy-compat`\n  for legacy compatibility with adapters and serializers.\n\n  @class Snapshot\n  @public\n*/class Snapshot{/**\n   * @method constructor\n   * @constructor\n   * @private\n   * @param options\n   * @param identifier\n   * @param _store\n   */constructor(options,identifier,store){this._store=store;this.__attributes=null;this._belongsToRelationships=Object.create(null);this._belongsToIds=Object.create(null);this._hasManyRelationships=Object.create(null);this._hasManyIds=Object.create(null);const hasRecord=!!store._instanceCache.peek(identifier);this.modelName=identifier.type;/**\n      The unique RecordIdentifier associated with this Snapshot.\n       @property identifier\n      @public\n      @type {StableRecordIdentifier}\n    */this.identifier=identifier;/*\n      If the we do not yet have a record, then we are\n      likely a snapshot being provided to a find request, so we\n      populate __attributes lazily. Else, to preserve the \"moment\n      in time\" in which a snapshot is created, we greedily grab\n      the values.\n     */if(hasRecord){// eslint-disable-next-line @typescript-eslint/no-unused-expressions\nthis._attributes;}/**\n     The id of the snapshot's underlying record\n      Example\n      ```javascript\n     // store.push('post', { id: 1, author: 'Tomster', title: 'Ember.js rocks' });\n     postSnapshot.id; // => '1'\n     ```\n      @property id\n     @type {String}\n     @public\n     */this.id=identifier.id;/**\n     A hash of adapter options\n     @property adapterOptions\n     @type {Object}\n     @public\n     */this.adapterOptions=options.adapterOptions;/**\n     If `include` was passed to the options hash for the request, the value\n     would be available here.\n      @property include\n     @type {String|Array}\n     @public\n     */this.include=options.include;/**\n     The name of the type of the underlying record for this snapshot, as a string.\n      @property modelName\n     @type {String}\n     @public\n     */this.modelName=identifier.type;if(hasRecord){const cache=this._store.cache;this._changedAttributes=cache.changedAttrs(identifier);}}/**\n   The underlying record for this snapshot. Can be used to access methods and\n   properties defined on the record.\n    Example\n    ```javascript\n   let json = snapshot.record.toJSON();\n   ```\n    @property record\n   @type {Model}\n   @public\n   */get record(){const record=this._store.peekRecord(this.identifier);(test=>{if(!test){throw new Error(`Record ${this.identifier.type} ${this.identifier.id} (${this.identifier.lid}) is not yet loaded and thus cannot be accessed from the Snapshot during serialization`);}})(record!==null);return record;}get _attributes(){if(this.__attributes!==null){return this.__attributes;}const attributes=this.__attributes=Object.create(null);const{identifier}=this;const attrs=this._store.schema.fields(identifier);const cache=this._store.cache;attrs.forEach((field,keyName)=>{if(field.kind==='attribute'){attributes[keyName]=cache.getAttr(identifier,keyName);}});return attributes;}get isNew(){const cache=this._store.cache;return cache?.isNew(this.identifier)||false;}/**\n   Returns the value of an attribute.\n    Example\n    ```javascript\n   // store.push('post', { id: 1, author: 'Tomster', title: 'Ember.js rocks' });\n   postSnapshot.attr('author'); // => 'Tomster'\n   postSnapshot.attr('title'); // => 'Ember.js rocks'\n   ```\n    Note: Values are loaded eagerly and cached when the snapshot is created.\n    @method attr\n   @param {String} keyName\n   @return {Object} The attribute value or undefined\n   @public\n   */attr(keyName){if(keyName in this._attributes){return this._attributes[keyName];}(test=>{{throw new Error(`Model '${this.identifier.lid}' has no attribute named '${keyName}' defined.`);}})();}/**\n   Returns all attributes and their corresponding values.\n    Example\n    ```javascript\n   // store.push('post', { id: 1, author: 'Tomster', title: 'Ember.js rocks' });\n   postSnapshot.attributes(); // => { author: 'Tomster', title: 'Ember.js rocks' }\n   ```\n    @method attributes\n   @return {Object} All attributes of the current snapshot\n   @public\n   */attributes(){return{...this._attributes};}/**\n   Returns all changed attributes and their old and new values.\n    Example\n    ```javascript\n   // store.push('post', { id: 1, author: 'Tomster', title: 'Ember.js rocks' });\n   postModel.set('title', 'Ember.js rocks!');\n   postSnapshot.changedAttributes(); // => { title: ['Ember.js rocks', 'Ember.js rocks!'] }\n   ```\n    @method changedAttributes\n   @return {Object} All changed attributes of the current snapshot\n   @public\n   */changedAttributes(){const changedAttributes=Object.create(null);if(!this._changedAttributes){return changedAttributes;}const changedAttributeKeys=Object.keys(this._changedAttributes);for(let i=0,length=changedAttributeKeys.length;i<length;i++){const key=changedAttributeKeys[i];changedAttributes[key]=this._changedAttributes[key].slice();}return changedAttributes;}/**\n   Returns the current value of a belongsTo relationship.\n    `belongsTo` takes an optional hash of options as a second parameter,\n   currently supported options are:\n    - `id`: set to `true` if you only want the ID of the related record to be\n   returned.\n    Example\n    ```javascript\n   // store.push('post', { id: 1, title: 'Hello World' });\n   // store.createRecord('comment', { body: 'Lorem ipsum', post: post });\n   commentSnapshot.belongsTo('post'); // => Snapshot\n   commentSnapshot.belongsTo('post', { id: true }); // => '1'\n    // store.push('comment', { id: 1, body: 'Lorem ipsum' });\n   commentSnapshot.belongsTo('post'); // => undefined\n   ```\n    Calling `belongsTo` will return a new Snapshot as long as there's any known\n   data for the relationship available, such as an ID. If the relationship is\n   known but unset, `belongsTo` will return `null`. If the contents of the\n   relationship is unknown `belongsTo` will return `undefined`.\n    Note: Relationships are loaded lazily and cached upon first access.\n    @method belongsTo\n   @param {String} keyName\n   @param {Object} [options]\n   @public\n   @return {(Snapshot|String|null|undefined)} A snapshot or ID of a known\n   relationship or null if the relationship is known but unset. undefined\n   will be returned if the contents of the relationship is unknown.\n   */belongsTo(keyName,options){const returnModeIsId=!!(options&&options.id);let result;const store=this._store;if(returnModeIsId===true&&keyName in this._belongsToIds){return this._belongsToIds[keyName];}if(returnModeIsId===false&&keyName in this._belongsToRelationships){return this._belongsToRelationships[keyName];}const relationshipMeta=store.schema.fields({type:this.modelName}).get(keyName);(test=>{if(!test){throw new Error(`Model '${this.identifier.lid}' has no belongsTo relationship named '${keyName}' defined.`);}})(relationshipMeta&&relationshipMeta.kind==='belongsTo');(test=>{if(!test){throw new Error(`snapshot.belongsTo only supported when using the package @ember-data/graph`);}})(true);const graphFor=(0,_embroider_macros_src_addon_es_compat2__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(__webpack_require__(/*! @ember-data/graph/-private */ \"./node_modules/@ember-data/graph/dist/-private.js\")).graphFor;const{identifier}=this;{const relationship=graphFor(this._store).get(identifier,keyName);(test=>{if(!test){throw new Error(`You looked up the ${keyName} belongsTo relationship for { type: ${identifier.type}, id: ${identifier.id||''}, lid: ${identifier.lid} but no such relationship was found.`);}})(relationship);(test=>{if(!test){throw new Error(`You looked up the ${keyName} belongsTo relationship for { type: ${identifier.type}, id: ${identifier.id||''}, lid: ${identifier.lid} but that relationship is a hasMany.`);}})(relationship.definition.kind==='belongsTo');}const value=graphFor(this._store).getData(identifier,keyName);const data=value&&value.data;const inverseIdentifier=data?store.identifierCache.getOrCreateRecordIdentifier(data):null;if(value&&value.data!==undefined){const cache=store.cache;if(inverseIdentifier&&!cache.isDeleted(inverseIdentifier)){if(returnModeIsId){result=inverseIdentifier.id;}else{result=store._fetchManager.createSnapshot(inverseIdentifier);}}else{result=null;}}if(returnModeIsId){this._belongsToIds[keyName]=result;}else{this._belongsToRelationships[keyName]=result;}return result;}/**\n   Returns the current value of a hasMany relationship.\n    `hasMany` takes an optional hash of options as a second parameter,\n   currently supported options are:\n    - `ids`: set to `true` if you only want the IDs of the related records to be\n   returned.\n    Example\n    ```javascript\n   // store.push('post', { id: 1, title: 'Hello World', comments: [2, 3] });\n   postSnapshot.hasMany('comments'); // => [Snapshot, Snapshot]\n   postSnapshot.hasMany('comments', { ids: true }); // => ['2', '3']\n    // store.push('post', { id: 1, title: 'Hello World' });\n   postSnapshot.hasMany('comments'); // => undefined\n   ```\n    Note: Relationships are loaded lazily and cached upon first access.\n    @method hasMany\n   @param {String} keyName\n   @param {Object} [options]\n   @public\n   @return {(Array|undefined)} An array of snapshots or IDs of a known\n   relationship or an empty array if the relationship is known but unset.\n   undefined will be returned if the contents of the relationship is unknown.\n   */hasMany(keyName,options){const returnModeIsIds=!!(options&&options.ids);let results;const cachedIds=this._hasManyIds[keyName];const cachedSnapshots=this._hasManyRelationships[keyName];if(returnModeIsIds===true&&keyName in this._hasManyIds){return cachedIds;}if(returnModeIsIds===false&&keyName in this._hasManyRelationships){return cachedSnapshots;}const store=this._store;const relationshipMeta=store.schema.fields({type:this.modelName}).get(keyName);(test=>{if(!test){throw new Error(`Model '${this.identifier.lid}' has no hasMany relationship named '${keyName}' defined.`);}})(relationshipMeta&&relationshipMeta.kind==='hasMany');// TODO @runspired it seems this code branch would not work with CUSTOM_MODEL_CLASSes\n// this check is not a regression in behavior because relationships don't currently\n// function without access to intimate API contracts between RecordData and Model.\n// This is a requirement we should fix as soon as the relationship layer does not require\n// this intimate API usage.\n(test=>{if(!test){throw new Error(`snapshot.hasMany only supported when using the package @ember-data/graph`);}})(true);const graphFor=(0,_embroider_macros_src_addon_es_compat2__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(__webpack_require__(/*! @ember-data/graph/-private */ \"./node_modules/@ember-data/graph/dist/-private.js\")).graphFor;const{identifier}=this;{const relationship=graphFor(this._store).get(identifier,keyName);(test=>{if(!test){throw new Error(`You looked up the ${keyName} hasMany relationship for { type: ${identifier.type}, id: ${identifier.id||''}, lid: ${identifier.lid} but no such relationship was found.`);}})(relationship);(test=>{if(!test){throw new Error(`You looked up the ${keyName} hasMany relationship for { type: ${identifier.type}, id: ${identifier.id||''}, lid: ${identifier.lid} but that relationship is a belongsTo.`);}})(relationship.definition.kind==='hasMany');}const value=graphFor(this._store).getData(identifier,keyName);if(value.data){results=[];value.data.forEach(member=>{const inverseIdentifier=store.identifierCache.getOrCreateRecordIdentifier(member);const cache=store.cache;if(!cache.isDeleted(inverseIdentifier)){if(returnModeIsIds){results.push(inverseIdentifier.id);}else{results.push(store._fetchManager.createSnapshot(inverseIdentifier));}}});}// we assign even if `undefined` so that we don't reprocess the relationship\n// on next access. This works with the `keyName in` checks above.\nif(returnModeIsIds){this._hasManyIds[keyName]=results;}else{this._hasManyRelationships[keyName]=results;}return results;}/**\n    Iterates through all the attributes of the model, calling the passed\n    function on each attribute.\n     Example\n     ```javascript\n    snapshot.eachAttribute(function(name, meta) {\n      // ...\n    });\n    ```\n     @method eachAttribute\n    @param {Function} callback the callback to execute\n    @param {Object} [binding] the value to which the callback's `this` should be bound\n    @public\n  */eachAttribute(callback,binding){const fields=this._store.schema.fields(this.identifier);fields.forEach((field,key)=>{if(field.kind==='attribute'){callback.call(binding,key,field);}});}/**\n    Iterates through all the relationships of the model, calling the passed\n    function on each relationship.\n     Example\n     ```javascript\n    snapshot.eachRelationship(function(name, relationship) {\n      // ...\n    });\n    ```\n     @method eachRelationship\n    @param {Function} callback the callback to execute\n    @param {Object} [binding] the value to which the callback's `this` should be bound\n    @public\n  */eachRelationship(callback,binding){const fields=this._store.schema.fields(this.identifier);fields.forEach((field,key)=>{if(field.kind==='belongsTo'||field.kind==='hasMany'){callback.call(binding,key,field);}});}/**\n    Serializes the snapshot using the serializer for the model.\n     Example\n     ```app/adapters/application.js\n    import Adapter from '@ember-data/adapter';\n     export default Adapter.extend({\n      createRecord(store, type, snapshot) {\n        let data = snapshot.serialize({ includeId: true });\n        let url = `/${type.modelName}`;\n         return fetch(url, {\n          method: 'POST',\n          body: data,\n        }).then((response) => response.json())\n      }\n    });\n    ```\n     @method serialize\n    @param {Object} options\n    @return {Object} an object whose values are primitive JSON values only\n    @public\n   */serialize(options){upgradeStore(this._store);const serializer=this._store.serializerFor(this.modelName);(test=>{if(!test){throw new Error(`Cannot serialize record, no serializer found`);}})(serializer);return serializer.serialize(this,options);}}const SaveOp=(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_3__.getOrSetGlobal)('SaveOp',Symbol('SaveOp'));class FetchManager{// fetches pending in the runloop, waiting to be coalesced\nconstructor(store){this._store=store;// used to keep track of all the find requests that need to be coalesced\nthis._pendingFetch=new Map();this.requestCache=store.getRequestStateService();this.isDestroyed=false;}createSnapshot(identifier,options={}){return new Snapshot(options,identifier,this._store);}/**\n    This method is called by `record.save`, and gets passed a\n    resolver for the promise that `record.save` returns.\n     It schedules saving to happen at the end of the run loop.\n     @internal\n  */scheduleSave(identifier,options){const resolver=(0,_ember_data_request__WEBPACK_IMPORTED_MODULE_2__.createDeferred)();const query={op:'saveRecord',recordIdentifier:identifier,options};const queryRequest={data:[query]};const snapshot=this.createSnapshot(identifier,options);const pendingSaveItem={snapshot:snapshot,resolver:resolver,identifier,options,queryRequest};const monitored=this.requestCache._enqueue(resolver.promise,pendingSaveItem.queryRequest);_flushPendingSave(this._store,pendingSaveItem);return monitored;}scheduleFetch(identifier,options,request){const query={op:'findRecord',recordIdentifier:identifier,options};const queryRequest={data:[query]};const pendingFetch=this.getPendingFetch(identifier,options);if(pendingFetch){return pendingFetch;}const modelName=identifier.type;const resolver=(0,_ember_data_request__WEBPACK_IMPORTED_MODULE_2__.createDeferred)();const pendingFetchItem={identifier,resolver,options,queryRequest};const resolverPromise=resolver.promise;const store=this._store;const isInitialLoad=!store._instanceCache.recordIsLoaded(identifier);// we don't use isLoading directly because we are the request\nconst monitored=this.requestCache._enqueue(resolverPromise,pendingFetchItem.queryRequest);let promise=monitored.then(payload=>{// ensure that regardless of id returned we assign to the correct record\nif(payload.data&&!Array.isArray(payload.data)){payload.data.lid=identifier.lid;}// additional data received in the payload\n// may result in the merging of identifiers (and thus records)\nconst potentiallyNewIm=store._push(payload,options.reload);if(potentiallyNewIm&&!Array.isArray(potentiallyNewIm)){return potentiallyNewIm;}return identifier;},error=>{(test=>{if(!test){throw new Error(`Async Leak Detected: Expected the store to not be destroyed`);}})(!store.isDestroyed);const cache=store.cache;if(!cache||cache.isEmpty(identifier)||isInitialLoad){let isReleasable=true;{if(!cache){const graphFor=(0,_embroider_macros_src_addon_es_compat2__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(__webpack_require__(/*! @ember-data/graph/-private */ \"./node_modules/@ember-data/graph/dist/-private.js\")).graphFor;const graph=graphFor(store);isReleasable=graph.isReleasable(identifier);if(!isReleasable){graph.unload(identifier,true);}}}if(cache||isReleasable){store._enableAsyncFlush=true;store._instanceCache.unloadRecord(identifier);store._enableAsyncFlush=null;}}throw error;});if(this._pendingFetch.size===0){void new Promise(resolve=>setTimeout(resolve,0)).then(()=>{this.flushAllPendingFetches();});}const fetchesByType=this._pendingFetch;let fetchesById=fetchesByType.get(modelName);if(!fetchesById){fetchesById=new Map();fetchesByType.set(modelName,fetchesById);}let requestsForIdentifier=fetchesById.get(identifier);if(!requestsForIdentifier){requestsForIdentifier=[];fetchesById.set(identifier,requestsForIdentifier);}requestsForIdentifier.push(pendingFetchItem);{if(!request.disableTestWaiter){const{waitForPromise}=(0,_embroider_macros_src_addon_es_compat2__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(__webpack_require__(/*! @ember/test-waiters */ \"@ember/test-waiters\"));promise=waitForPromise(promise);}}pendingFetchItem.promise=promise;return promise;}getPendingFetch(identifier,options){const pendingFetches=this._pendingFetch.get(identifier.type)?.get(identifier);// We already have a pending fetch for this\nif(pendingFetches){const matchingPendingFetch=pendingFetches.find(fetch=>isSameRequest(options,fetch.options));if(matchingPendingFetch){return matchingPendingFetch.promise;}}}flushAllPendingFetches(){if(this.isDestroyed){return;}const store=this._store;this._pendingFetch.forEach((fetchItem,type)=>_flushPendingFetchForType(store,fetchItem,type));this._pendingFetch.clear();}fetchDataIfNeededForIdentifier(identifier,options={},request){// pre-loading will change the isEmpty value\nconst isEmpty=_isEmpty(this._store._instanceCache,identifier);const isLoading=_isLoading(this._store._instanceCache,identifier);let promise;if(isEmpty){assertIdentifierHasId(identifier);{promise=this.scheduleFetch(identifier,Object.assign({},options,{reload:true}),request);}}else if(isLoading){promise=this.getPendingFetch(identifier,options);(test=>{if(!test){throw new Error(`Expected to find a pending request for a record in the loading state, but found none`);}})(promise);}else{promise=Promise.resolve(identifier);}return promise;}destroy(){this.isDestroyed=true;}}function _isEmpty(instanceCache,identifier){const cache=instanceCache.cache;if(!cache){return true;}const isNew=cache.isNew(identifier);const isDeleted=cache.isDeleted(identifier);const isEmpty=cache.isEmpty(identifier);return(!isNew||isDeleted)&&isEmpty;}function _isLoading(cache,identifier){const req=cache.store.getRequestStateService();// const fulfilled = req.getLastRequestForRecord(identifier);\nconst isLoaded=cache.recordIsLoaded(identifier);return!isLoaded&&// fulfilled === null &&\nreq.getPendingRequestsForRecord(identifier).some(r=>r.type==='query');}function includesSatisfies(current,existing){// if we have no includes we are good\nif(!current?.length){return true;}// if we are here we have includes,\n// and if existing has no includes then we will need a new request\nif(!existing?.length){return false;}const arrCurrent=(Array.isArray(current)?current:current.split(',')).sort();const arrExisting=(Array.isArray(existing)?existing:existing.split(',')).sort();// includes are identical\nif(arrCurrent.join(',')===arrExisting.join(',')){return true;}// if all of current includes are in existing includes then we are good\n// so if we find one that is not in existing then we need a new request\nfor(let i=0;i<arrCurrent.length;i++){if(!arrExisting.includes(arrCurrent[i])){return false;}}return true;}function optionsSatisfies(current,existing){return!current||current===existing||Object.keys(current).length===0;}// this function helps resolve whether we have a pending request that we should use instead\nfunction isSameRequest(options={},existingOptions={}){return optionsSatisfies(options.adapterOptions,existingOptions.adapterOptions)&&includesSatisfies(options.include,existingOptions.include);}function _findMany(store,adapter,modelName,snapshots){const modelClass=store.modelFor(modelName);// `adapter.findMany` gets the modelClass still\nconst promise=Promise.resolve().then(()=>{const ids=snapshots.map(s=>s.id);(test=>{if(!test){throw new Error(`Cannot fetch a record without an id`);}})(ids.every(v=>v!==null));// eslint-disable-next-line @typescript-eslint/unbound-method\n(test=>{if(!test){throw new Error(`Expected this adapter to implement findMany for coalescing`);}})(adapter.findMany);const ret=adapter.findMany(store,modelClass,ids,snapshots);(test=>{if(!test){throw new Error('adapter.findMany returned undefined, this was very likely a mistake');}})(ret!==undefined);return ret;});return promise.then(adapterPayload=>{(test=>{if(!test){throw new Error(`You made a 'findMany' request for '${modelName}' records with ids '[${snapshots.map(s=>s.id).join(',')}]', but the adapter's response did not have any data`);}})(!!payloadIsNotBlank(adapterPayload));const serializer=store.serializerFor(modelName);const payload=normalizeResponseHelper(serializer,store,modelClass,adapterPayload,null,'findMany');return payload;});}function rejectFetchedItems(fetchMap,snapshots,error){for(let i=0,l=snapshots.length;i<l;i++){const snapshot=snapshots[i];const pair=fetchMap.get(snapshot);if(pair){pair.resolver.reject(error||new Error(`Expected: '<${snapshot.modelName}:${snapshot.id}>' to be present in the adapter provided payload, but it was not found.`));}}}function handleFoundRecords(store,fetchMap,snapshots,coalescedPayload){/*\n    It is possible that the same ID is included multiple times\n    via multiple snapshots. This happens when more than one\n    options hash was supplied, each of which must be uniquely\n    accounted for.\n     However, since we can't map from response to a specific\n    options object, we resolve all snapshots by id with\n    the first response we see.\n  */const snapshotsById=new Map();for(let i=0;i<snapshots.length;i++){const id=snapshots[i].id;let snapshotGroup=snapshotsById.get(id);if(!snapshotGroup){snapshotGroup=[];snapshotsById.set(id,snapshotGroup);}snapshotGroup.push(snapshots[i]);}const included=Array.isArray(coalescedPayload.included)?coalescedPayload.included:[];// resolve found records\nconst resources=coalescedPayload.data;for(let i=0,l=resources.length;i<l;i++){const resource=resources[i];const snapshotGroup=snapshotsById.get(resource.id);snapshotsById.delete(resource.id);if(!snapshotGroup){// TODO consider whether this should be a deprecation/assertion\nincluded.push(resource);}else{snapshotGroup.forEach(snapshot=>{const pair=fetchMap.get(snapshot);const resolver=pair.resolver;resolver.resolve({data:resource});});}}if(included.length>0){store._push({data:null,included},true);}if(snapshotsById.size===0){return;}// reject missing records\nconst rejected=[];snapshotsById.forEach(snapshotArray=>{rejected.push(...snapshotArray);});(0,_ember_debug__WEBPACK_IMPORTED_MODULE_1__.warn)('Ember Data expected to find records with the following ids in the adapter response from findMany but they were missing: [ \"'+[...snapshotsById.values()].map(r=>r[0].id).join('\", \"')+'\" ]',{id:'ds.store.missing-records-from-adapter'});rejectFetchedItems(fetchMap,rejected);}function _fetchRecord(store,adapter,fetchItem){const identifier=fetchItem.identifier;const modelName=identifier.type;(test=>{if(!test){throw new Error(`You tried to find a record but you have no adapter (for ${modelName})`);}})(adapter);(test=>{if(!test){throw new Error(`You tried to find a record but your adapter (for ${modelName}) does not implement 'findRecord'`);}})(typeof adapter.findRecord==='function');const snapshot=store._fetchManager.createSnapshot(identifier,fetchItem.options);const klass=store.modelFor(identifier.type);const id=identifier.id;let promise=Promise.resolve().then(()=>{return adapter.findRecord(store,klass,identifier.id,snapshot);});promise=promise.then(adapterPayload=>{(test=>{if(!test){throw new Error(`Async Leak Detected: Expected the store to not be destroyed`);}})(!(store.isDestroyed||store.isDestroying));(test=>{if(!test){throw new Error(`You made a 'findRecord' request for a '${modelName}' with id '${id}', but the adapter's response did not have any data`);}})(!!payloadIsNotBlank(adapterPayload));const serializer=store.serializerFor(modelName);const payload=normalizeResponseHelper(serializer,store,klass,adapterPayload,id,'findRecord');(test=>{if(!test){throw new Error(`Ember Data expected the primary data returned from a 'findRecord' response to be an object but instead it found an array.`);}})(!Array.isArray(payload.data));(test=>{if(!test){throw new Error(`The 'findRecord' request for ${modelName}:${id} resolved indicating success but contained no primary data. To indicate a 404 not found you should either reject the promise returned by the adapter's findRecord method or throw a NotFoundError.`);}})('data'in payload&&payload.data!==null&&typeof payload.data==='object');(0,_ember_debug__WEBPACK_IMPORTED_MODULE_1__.warn)(`You requested a record of type '${modelName}' with id '${id}' but the adapter returned a payload with primary data having an id of '${payload.data.id}'. Use 'store.findRecord()' when the requested id is the same as the one returned by the adapter. In other cases use 'store.queryRecord()' instead.`,(0,_ember_data_store_private__WEBPACK_IMPORTED_MODULE_0__.coerceId)(payload.data.id)===(0,_ember_data_store_private__WEBPACK_IMPORTED_MODULE_0__.coerceId)(id),{id:'ds.store.findRecord.id-mismatch'});return payload;});fetchItem.resolver.resolve(promise);}function _processCoalescedGroup(store,fetchMap,group,adapter,modelName){if(group.length>1){_findMany(store,adapter,modelName,group).then(payloads=>{handleFoundRecords(store,fetchMap,group,payloads);}).catch(error=>{rejectFetchedItems(fetchMap,group,error);});}else if(group.length===1){_fetchRecord(store,adapter,fetchMap.get(group[0]));}else{(test=>{{throw new Error(\"You cannot return an empty array from adapter's method groupRecordsForFindMany\");}})();}}function _flushPendingFetchForType(store,pendingFetchMap,modelName){const adapter=store.adapterFor(modelName);const shouldCoalesce=!!adapter.findMany&&adapter.coalesceFindRequests;if(shouldCoalesce){const pendingFetchItems=[];pendingFetchMap.forEach((requestsForIdentifier,identifier)=>{if(requestsForIdentifier.length>1){return;}// remove this entry from the map so it's not processed again\npendingFetchMap.delete(identifier);pendingFetchItems.push(requestsForIdentifier[0]);});const totalItems=pendingFetchItems.length;if(totalItems>1){const snapshots=new Array(totalItems);const fetchMap=new Map();for(let i=0;i<totalItems;i++){const fetchItem=pendingFetchItems[i];snapshots[i]=store._fetchManager.createSnapshot(fetchItem.identifier,fetchItem.options);fetchMap.set(snapshots[i],fetchItem);}let groups;if(adapter.groupRecordsForFindMany){groups=adapter.groupRecordsForFindMany(store,snapshots);}else{groups=[snapshots];}for(let i=0,l=groups.length;i<l;i++){_processCoalescedGroup(store,fetchMap,groups[i],adapter,modelName);}}else if(totalItems===1){_fetchRecord(store,adapter,pendingFetchItems[0]);}}pendingFetchMap.forEach(pendingFetchItems=>{pendingFetchItems.forEach(pendingFetchItem=>{_fetchRecord(store,adapter,pendingFetchItem);});});}function _flushPendingSave(store,pending){const{snapshot,resolver,identifier,options}=pending;const adapter=store.adapterFor(identifier.type);const operation=options[SaveOp];const modelName=snapshot.modelName;const modelClass=store.modelFor(modelName);(test=>{if(!test){throw new Error(`You tried to update a record but you have no adapter (for ${modelName})`);}})(adapter);(test=>{if(!test){throw new Error(`You tried to update a record but your adapter (for ${modelName}) does not implement '${operation}'`);}})(typeof adapter[operation]==='function');let promise=Promise.resolve().then(()=>adapter[operation](store,modelClass,snapshot));const serializer=store.serializerFor(modelName);(test=>{if(!test){throw new Error(`Your adapter's '${operation}' method must return a value, but it returned 'undefined'`);}})(promise!==undefined);promise=promise.then(adapterPayload=>{if(adapterPayload){return normalizeResponseHelper(serializer,store,modelClass,adapterPayload,snapshot.id,operation);}});resolver.resolve(promise);}/**\n * Utilities - often temporary - for maintaining backwards compatibility with\n * older parts of EmberData.\n *\n  @module @ember-data/legacy-compat\n  @main @ember-data/legacy-compat\n*/function upgradeStore(store){}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@ember-data/legacy-compat/dist/-private-Dlia0pw1.js?");

/***/ }),

/***/ "./node_modules/@ember-data/legacy-compat/dist/-private.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@ember-data/legacy-compat/dist/-private.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FetchManager: () => (/* reexport safe */ _private_Dlia0pw1_js__WEBPACK_IMPORTED_MODULE_0__.F),\n/* harmony export */   SaveOp: () => (/* reexport safe */ _private_Dlia0pw1_js__WEBPACK_IMPORTED_MODULE_0__.S),\n/* harmony export */   Snapshot: () => (/* reexport safe */ _private_Dlia0pw1_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   SnapshotRecordArray: () => (/* reexport safe */ _private_Dlia0pw1_js__WEBPACK_IMPORTED_MODULE_0__.b),\n/* harmony export */   upgradeStore: () => (/* reexport safe */ _private_Dlia0pw1_js__WEBPACK_IMPORTED_MODULE_0__.u)\n/* harmony export */ });\n/* harmony import */ var _private_Dlia0pw1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./-private-Dlia0pw1.js */ \"./node_modules/@ember-data/legacy-compat/dist/-private-Dlia0pw1.js\");\n\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@ember-data/legacy-compat/dist/-private.js?");

/***/ }),

/***/ "./node_modules/@ember-data/legacy-compat/dist/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@ember-data/legacy-compat/dist/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LegacyNetworkHandler: () => (/* binding */ LegacyNetworkHandler),\n/* harmony export */   adapterFor: () => (/* binding */ adapterFor),\n/* harmony export */   cleanup: () => (/* binding */ cleanup),\n/* harmony export */   normalize: () => (/* binding */ normalize),\n/* harmony export */   pushPayload: () => (/* binding */ pushPayload),\n/* harmony export */   serializeRecord: () => (/* binding */ serializeRecord),\n/* harmony export */   serializerFor: () => (/* binding */ serializerFor)\n/* harmony export */ });\n/* harmony import */ var _ember_application__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ember/application */ \"@ember/application\");\n/* harmony import */ var _ember_application__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ember_application__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ember_data_store__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ember-data/store */ \"./node_modules/@ember-data/store/dist/index.js\");\n/* harmony import */ var _ember_data_store_private__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ember-data/store/-private */ \"./node_modules/@ember-data/store/dist/-private.js\");\n/* harmony import */ var _private_Dlia0pw1_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./-private-Dlia0pw1.js */ \"./node_modules/@ember-data/legacy-compat/dist/-private-Dlia0pw1.js\");\n/* harmony import */ var _embroider_macros_src_addon_es_compat2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../@embroider/macros/src/addon/es-compat2 */ \"./node_modules/@embroider/macros/src/addon/es-compat2.js\");\nfunction _findHasMany(adapter,store,identifier,link,relationship,options){const promise=Promise.resolve().then(()=>{const snapshot=store._fetchManager.createSnapshot(identifier,options);const useLink=!link||typeof link==='string';const relatedLink=useLink?link:link.href;(test=>{if(!test){throw new Error(`Attempted to load a hasMany relationship from a specified 'link' in the original payload, but the specified link is empty. You must provide a valid 'link' in the original payload to use 'findHasMany'`);}})(relatedLink);(test=>{if(!test){throw new Error(`Expected the adapter to implement 'findHasMany' but it does not`);}})(typeof adapter.findHasMany==='function');return adapter.findHasMany(store,snapshot,relatedLink,relationship);});return promise.then(adapterPayload=>{(test=>{if(!test){throw new Error(`You made a 'findHasMany' request for a ${identifier.type}'s '${relationship.name}' relationship, using link '${JSON.stringify(link)}' , but the adapter's response did not have any data`);}})((0,_private_Dlia0pw1_js__WEBPACK_IMPORTED_MODULE_3__.p)(adapterPayload));const modelClass=store.modelFor(relationship.type);const serializer=store.serializerFor(relationship.type);let payload=(0,_private_Dlia0pw1_js__WEBPACK_IMPORTED_MODULE_3__.n)(serializer,store,modelClass,adapterPayload,null,'findHasMany');(test=>{if(!test){throw new Error(`fetched the hasMany relationship '${relationship.name}' for ${identifier.type}:${identifier.id} with link '${JSON.stringify(link)}', but no data member is present in the response. If no data exists, the response should set { data: [] }`);}})('data'in payload&&Array.isArray(payload.data));payload=syncRelationshipDataFromLink(store,payload,identifier,relationship);return store._push(payload,true);},null);}function _findBelongsTo(store,identifier,link,relationship,options){const promise=Promise.resolve().then(()=>{const adapter=store.adapterFor(identifier.type);(test=>{if(!test){throw new Error(`You tried to load a belongsTo relationship but you have no adapter (for ${identifier.type})`);}})(adapter);(test=>{if(!test){throw new Error(`You tried to load a belongsTo relationship from a specified 'link' in the original payload but your adapter does not implement 'findBelongsTo'`);}})(typeof adapter.findBelongsTo==='function');const snapshot=store._fetchManager.createSnapshot(identifier,options);const useLink=!link||typeof link==='string';const relatedLink=useLink?link:link.href;(test=>{if(!test){throw new Error(`Attempted to load a belongsTo relationship from a specified 'link' in the original payload, but the specified link is empty. You must provide a valid 'link' in the original payload to use 'findBelongsTo'`);}})(relatedLink);return adapter.findBelongsTo(store,snapshot,relatedLink,relationship);});return promise.then(adapterPayload=>{const modelClass=store.modelFor(relationship.type);const serializer=store.serializerFor(relationship.type);let payload=(0,_private_Dlia0pw1_js__WEBPACK_IMPORTED_MODULE_3__.n)(serializer,store,modelClass,adapterPayload,null,'findBelongsTo');(test=>{if(!test){throw new Error(`fetched the belongsTo relationship '${relationship.name}' for ${identifier.type}:${identifier.id} with link '${JSON.stringify(link)}', but no data member is present in the response. If no data exists, the response should set { data: null }`);}})('data'in payload&&(payload.data===null||typeof payload.data==='object'&&!Array.isArray(payload.data)));if(!payload.data&&!payload.links&&!payload.meta){return null;}payload=syncRelationshipDataFromLink(store,payload,identifier,relationship);return store._push(payload,true);},null);}// sync\n// iterate over records in payload.data\n// for each record\n//   assert that record.relationships[inverse] is either undefined (so we can fix it)\n//     or provide a data: {id, type} that matches the record that requested it\n//   return the relationship data for the parent\nfunction syncRelationshipDataFromLink(store,payload,parentIdentifier,relationship){// ensure the right hand side (incoming payload) points to the parent record that\n// requested this relationship\nconst relationshipData=payload.data?(0,_private_Dlia0pw1_js__WEBPACK_IMPORTED_MODULE_3__.i)(payload.data,(data,index)=>{const{id,type}=data;ensureRelationshipIsSetToParent(data,parentIdentifier,store,relationship,index);return{id,type};}):null;const relatedDataHash={};if('meta'in payload){relatedDataHash.meta=payload.meta;}if('links'in payload){relatedDataHash.links=payload.links;}if('data'in payload){relatedDataHash.data=relationshipData;}// now, push the left hand side (the parent record) to ensure things are in sync, since\n// the payload will be pushed with store._push\nconst parentPayload={id:parentIdentifier.id,type:parentIdentifier.type,relationships:{[relationship.name]:relatedDataHash}};if(!Array.isArray(payload.included)){payload.included=[];}payload.included.push(parentPayload);return payload;}function ensureRelationshipIsSetToParent(payload,parentIdentifier,store,parentRelationship,index){const{id,type}=payload;if(!payload.relationships){payload.relationships={};}const{relationships}=payload;const inverse=getInverse(store,parentIdentifier,parentRelationship,type);if(inverse){const{inverseKey,kind}=inverse;const relationshipData=relationships[inverseKey]?.data;{if(typeof relationshipData!=='undefined'&&!relationshipDataPointsToParent(relationshipData,parentIdentifier)){const inspect=function inspect(thing){return`'${JSON.stringify(thing)}'`;};const quotedType=inspect(type);const quotedInverse=inspect(inverseKey);const expected=inspect({id:parentIdentifier.id,type:parentIdentifier.type});const expectedModel=`${parentIdentifier.type}:${parentIdentifier.id}`;const got=inspect(relationshipData);const prefix=typeof index==='number'?`data[${index}]`:`data`;const path=`${prefix}.relationships.${inverseKey}.data`;const data=Array.isArray(relationshipData)?relationshipData[0]:relationshipData;const other=data?`<${data.type}:${data.id}>`:null;const relationshipFetched=`${expectedModel}.${parentRelationship.kind}(\"${parentRelationship.name}\")`;const includedRecord=`<${type}:${id}>`;const message=[`Encountered mismatched relationship: Ember Data expected ${path} in the payload from ${relationshipFetched} to include ${expected} but got ${got} instead.\\n`,`The ${includedRecord} record loaded at ${prefix} in the payload specified ${other} as its ${quotedInverse}, but should have specified ${expectedModel} (the record the relationship is being loaded from) as its ${quotedInverse} instead.`,`This could mean that the response for ${relationshipFetched} may have accidentally returned ${quotedType} records that aren't related to ${expectedModel} and could be related to a different ${parentIdentifier.type} record instead.`,`Ember Data has corrected the ${includedRecord} record's ${quotedInverse} relationship to ${expectedModel} so that ${relationshipFetched} will include ${includedRecord}.`,`Please update the response from the server or change your serializer to either ensure that the response for only includes ${quotedType} records that specify ${expectedModel} as their ${quotedInverse}, or omit the ${quotedInverse} relationship from the response.`].join('\\n');(test=>{{throw new Error(message);}})();}}if(kind!=='hasMany'||typeof relationshipData!=='undefined'){relationships[inverseKey]=relationships[inverseKey]||{};relationships[inverseKey].data=fixRelationshipData(relationshipData??null,kind,parentIdentifier);}}}function inverseForRelationship(store,identifier,key){const definition=store.schema.fields(identifier).get(key);if(!definition){return null;}(test=>{if(!test){throw new Error(`Expected the field definition to be a relationship`);}})(definition.kind==='hasMany'||definition.kind==='belongsTo');(test=>{if(!test){throw new Error(`Expected the relationship defintion to specify the inverse type or null.`);}})(definition.options?.inverse===null||typeof definition.options?.inverse==='string'&&definition.options.inverse.length>0);return definition.options.inverse;}function getInverse(store,parentIdentifier,parentRelationship,type){const{name:lhs_relationshipName}=parentRelationship;const{type:parentType}=parentIdentifier;const inverseKey=inverseForRelationship(store,{type:parentType},lhs_relationshipName);if(inverseKey){const definition=store.schema.fields({type}).get(inverseKey);(test=>{if(!test){throw new Error(`Expected the field definition to be a relationship`);}})(definition&&(definition.kind==='hasMany'||definition.kind==='belongsTo'));return{inverseKey,kind:definition.kind};}}function relationshipDataPointsToParent(relationshipData,identifier){if(relationshipData===null){return false;}if(Array.isArray(relationshipData)){if(relationshipData.length===0){return false;}for(let i=0;i<relationshipData.length;i++){const entry=relationshipData[i];if(validateRelationshipEntry(entry,identifier)){return true;}}}else{return validateRelationshipEntry(relationshipData,identifier);}return false;}function fixRelationshipData(relationshipData,relationshipKind,{id,type}){const parentRelationshipData={id,type};let payload=null;if(relationshipKind==='hasMany'){const relData=relationshipData||[];if(relationshipData){(test=>{if(!test){throw new Error('expected the relationship data to be an array');}})(Array.isArray(relationshipData));// these arrays could be massive so this is better than filter\n// Note: this is potentially problematic if type/id are not in the\n// same state of normalization.\nconst found=relationshipData.find(v=>{return v.type===parentRelationshipData.type&&v.id===parentRelationshipData.id;});if(!found){relData.push(parentRelationshipData);}}else{relData.push(parentRelationshipData);}payload=relData;}else{const relData=relationshipData||{};Object.assign(relData,parentRelationshipData);payload=relData;}return payload;}function validateRelationshipEntry({id},{id:parentModelID}){return!!id&&id.toString()===parentModelID;}const PotentialLegacyOperations=new Set(['findRecord','findAll','query','queryRecord','findBelongsTo','findHasMany','updateRecord','createRecord','deleteRecord']);const LegacyNetworkHandler={request(context,next){// if we are not a legacy request, move on\nif(context.request.url||!context.request.op||!PotentialLegacyOperations.has(context.request.op)){return next(context.request);}const{store}=context.request;if(!store._fetchManager){store._fetchManager=new _private_Dlia0pw1_js__WEBPACK_IMPORTED_MODULE_3__.F(store);}switch(context.request.op){case'findRecord':return findRecord(context);case'findAll':return findAll(context);case'query':return query(context);case'queryRecord':return queryRecord(context);case'findBelongsTo':return findBelongsTo(context);case'findHasMany':return findHasMany(context);case'updateRecord':return saveRecord(context);case'createRecord':return saveRecord(context);case'deleteRecord':return saveRecord(context);default:return next(context.request);}}};function findBelongsTo(context){const{store,data,records:identifiers}=context.request;const{options,record,links,useLink,field}=data;const identifier=identifiers?.[0];// short circuit if we are already loading\nconst pendingRequest=identifier&&store._fetchManager.getPendingFetch(identifier,options);if(pendingRequest){return pendingRequest;}if(useLink){(test=>{if(!test){throw new Error(`Expected a related link when calling store.findBelongsTo, found ${String(links)}`);}})(links&&links.related);return _findBelongsTo(store,record,links.related,field,options);}(test=>{if(!test){throw new Error(`Expected an identifier`);}})(Array.isArray(identifiers)&&identifiers.length===1);const manager=store._fetchManager;(0,_private_Dlia0pw1_js__WEBPACK_IMPORTED_MODULE_3__.a)(identifier);return options.reload?manager.scheduleFetch(identifier,options,context.request):manager.fetchDataIfNeededForIdentifier(identifier,options,context.request);}function findHasMany(context){const{store,data,records:identifiers}=context.request;const{options,record,links,useLink,field}=data;// link case\nif(useLink){const adapter=store.adapterFor(record.type);/*\n    If a relationship was originally populated by the adapter as a link\n    (as opposed to a list of IDs), this method is called when the\n    relationship is fetched.\n     The link (which is usually a URL) is passed through unchanged, so the\n    adapter can make whatever request it wants.\n     The usual use-case is for the server to register a URL as a link, and\n    then use that URL in the future to make a request for the relationship.\n    */(test=>{if(!test){throw new Error(`You tried to load a hasMany relationship but you have no adapter (for ${record.type})`);}})(adapter);(test=>{if(!test){throw new Error(`You tried to load a hasMany relationship from a specified 'link' in the original payload but your adapter does not implement 'findHasMany'`);}})(typeof adapter.findHasMany==='function');(test=>{if(!test){throw new Error(`Expected a related link when calling store.findHasMany, found ${String(links)}`);}})(links&&links.related);return _findHasMany(adapter,store,record,links.related,field,options);}// identifiers case\n(test=>{if(!test){throw new Error(`Expected an array of identifiers to fetch`);}})(Array.isArray(identifiers));const fetches=new Array(identifiers.length);const manager=store._fetchManager;for(let i=0;i<identifiers.length;i++){const identifier=identifiers[i];// TODO we probably can be lenient here and return from cache for the isNew case\n(0,_private_Dlia0pw1_js__WEBPACK_IMPORTED_MODULE_3__.a)(identifier);fetches[i]=options.reload?manager.scheduleFetch(identifier,options,context.request):manager.fetchDataIfNeededForIdentifier(identifier,options,context.request);}return Promise.all(fetches);}function saveRecord(context){const{store,data,op:operation}=context.request;const{options,record:identifier}=data;store.cache.willCommit(identifier,context);const saveOptions=Object.assign({[_private_Dlia0pw1_js__WEBPACK_IMPORTED_MODULE_3__.S]:operation},options);const fetchManagerPromise=store._fetchManager.scheduleSave(identifier,saveOptions);return fetchManagerPromise.then(payload=>{let result;store._join(()=>{// @ts-expect-error we don't have access to a response in legacy\nresult=store.cache.didCommit(identifier,{request:context.request,content:payload});});// blatantly lie if we were a createRecord request\n// to give some semblance of cache-control to the\n// CachePolicy while legacy is still around\nif(store.lifetimes?.didRequest&&operation==='createRecord'){store.lifetimes.didRequest(context.request,{status:201},null,store);}return store.peekRecord(result.data);}).catch(e=>{let err=e;if(!e){err=new Error(`Unknown Error Occurred During Request`);}else if(typeof e==='string'){err=new Error(e);}adapterDidInvalidate(store,identifier,err);throw err;});}function adapterDidInvalidate(store,identifier,error){if(error&&error.isAdapterError===true&&error.code==='InvalidError'){const serializer=store.serializerFor(identifier.type);// TODO @deprecate extractErrors being called\n// TODO remove extractErrors from the default serializers.\nif(serializer&&typeof serializer.extractErrors==='function'){const errorsHash=serializer.extractErrors(store,store.modelFor(identifier.type),error,identifier.id);error.errors=errorsHashToArray(errorsHash);}}const cache=store.cache;if(error.errors){(test=>{if(!test){throw new Error(`Expected the cache in use by resource ${String(identifier)} to have a getErrors(identifier) method for retrieving errors.`);}})(typeof cache.getErrors==='function');let jsonApiErrors=error.errors;if(jsonApiErrors.length===0){jsonApiErrors=[{title:'Invalid Error',detail:'',source:{pointer:'/data'}}];}cache.commitWasRejected(identifier,jsonApiErrors);}else{cache.commitWasRejected(identifier);}}function makeArray(value){return Array.isArray(value)?value:[value];}const PRIMARY_ATTRIBUTE_KEY='base';function errorsHashToArray(errors){const out=[];if(errors){Object.keys(errors).forEach(key=>{const messages=makeArray(errors[key]);for(let i=0;i<messages.length;i++){let title='Invalid Attribute';let pointer=`/data/attributes/${key}`;if(key===PRIMARY_ATTRIBUTE_KEY){title='Invalid Document';pointer=`/data`;}out.push({title:title,detail:messages[i],source:{pointer:pointer}});}});}return out;}function findRecord(context){const{store,data}=context.request;const{record:identifier,options}=data;let promise;// if not loaded start loading\nif(!store._instanceCache.recordIsLoaded(identifier)){promise=store._fetchManager.fetchDataIfNeededForIdentifier(identifier,options,context.request);// Refetch if the reload option is passed\n}else if(options.reload){(0,_private_Dlia0pw1_js__WEBPACK_IMPORTED_MODULE_3__.a)(identifier);promise=store._fetchManager.scheduleFetch(identifier,options,context.request);}else{let snapshot=null;const adapter=store.adapterFor(identifier.type);// Refetch the record if the adapter thinks the record is stale\nif(typeof options.reload==='undefined'&&adapter.shouldReloadRecord&&adapter.shouldReloadRecord(store,snapshot=store._fetchManager.createSnapshot(identifier,options))){(0,_private_Dlia0pw1_js__WEBPACK_IMPORTED_MODULE_3__.a)(identifier);{promise=store._fetchManager.scheduleFetch(identifier,Object.assign({},options,{reload:true}),context.request);}}else{// Trigger the background refetch if backgroundReload option is passed\nif(options.backgroundReload!==false&&(options.backgroundReload||!adapter.shouldBackgroundReloadRecord||adapter.shouldBackgroundReloadRecord(store,snapshot=snapshot||store._fetchManager.createSnapshot(identifier,options)))){(0,_private_Dlia0pw1_js__WEBPACK_IMPORTED_MODULE_3__.a)(identifier);{void store._fetchManager.scheduleFetch(identifier,Object.assign({},options,{backgroundReload:true}),context.request);}}// Return the cached record\npromise=Promise.resolve(identifier);}}return promise.then(i=>store.peekRecord(i));}function findAll(context){const{store,data}=context.request;const{type,options}=data;const adapter=store.adapterFor(type);(test=>{if(!test){throw new Error(`You tried to load all records but you have no adapter (for ${type})`);}})(adapter);(test=>{if(!test){throw new Error(`You tried to load all records but your adapter does not implement 'findAll'`);}})(typeof adapter.findAll==='function');// avoid initializing the liveArray just to set `isUpdating`\nconst maybeRecordArray=store.recordArrayManager._live.get(type);const snapshotArray=new _private_Dlia0pw1_js__WEBPACK_IMPORTED_MODULE_3__.b(store,type,options);const shouldReload=options.reload||options.reload!==false&&(adapter.shouldReloadAll&&adapter.shouldReloadAll(store,snapshotArray)||!adapter.shouldReloadAll&&snapshotArray.length===0);let fetch;if(shouldReload){// eslint-disable-next-line @typescript-eslint/no-unused-expressions\nmaybeRecordArray&&(maybeRecordArray.isUpdating=true);fetch=_findAll(adapter,store,type,snapshotArray,context.request,true);}else{fetch=Promise.resolve(store.peekAll(type));if(options.backgroundReload||options.backgroundReload!==false&&(!adapter.shouldBackgroundReloadAll||adapter.shouldBackgroundReloadAll(store,snapshotArray))){// eslint-disable-next-line @typescript-eslint/no-unused-expressions\nmaybeRecordArray&&(maybeRecordArray.isUpdating=true);void _findAll(adapter,store,type,snapshotArray,context.request,false);}}return fetch;}function _findAll(adapter,store,type,snapshotArray,request,isAsyncFlush){const schema=store.modelFor(type);let promise=Promise.resolve().then(()=>adapter.findAll(store,schema,null,snapshotArray));promise=promise.then(adapterPayload=>{(test=>{if(!test){throw new Error(`You made a 'findAll' request for '${type}' records, but the adapter's response did not have any data`);}})((0,_private_Dlia0pw1_js__WEBPACK_IMPORTED_MODULE_3__.p)(adapterPayload));const serializer=store.serializerFor(type);const payload=(0,_private_Dlia0pw1_js__WEBPACK_IMPORTED_MODULE_3__.n)(serializer,store,schema,adapterPayload,null,'findAll');store._push(payload,isAsyncFlush);snapshotArray._recordArray.isUpdating=false;return snapshotArray._recordArray;});{if(!request.disableTestWaiter){const{waitForPromise}=(0,_embroider_macros_src_addon_es_compat2__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(__webpack_require__(/*! @ember/test-waiters */ \"@ember/test-waiters\"));promise=waitForPromise(promise);}}return promise;}function query(context){const{store,data}=context.request;let{options}=data;// eslint-disable-next-line @typescript-eslint/no-shadow\nconst{type,query}=data;const adapter=store.adapterFor(type);(test=>{if(!test){throw new Error(`You tried to make a query but you have no adapter (for ${type})`);}})(adapter);(test=>{if(!test){throw new Error(`You tried to make a query but your adapter does not implement 'query'`);}})(typeof adapter.query==='function');const recordArray=options._recordArray||store.recordArrayManager.createArray({type,query});{options=Object.assign({},options);delete options._recordArray;}const schema=store.modelFor(type);const promise=Promise.resolve().then(()=>adapter.query(store,schema,query,recordArray,options));return promise.then(adapterPayload=>{const serializer=store.serializerFor(type);const payload=(0,_private_Dlia0pw1_js__WEBPACK_IMPORTED_MODULE_3__.n)(serializer,store,schema,adapterPayload,null,'query');const identifiers=store._push(payload,true);(test=>{if(!test){throw new Error('The response to store.query is expected to be an array but it was a single record. Please wrap your response in an array or use `store.queryRecord` to query for a single record.');}})(Array.isArray(identifiers));store.recordArrayManager.populateManagedArray(recordArray,identifiers,payload);return recordArray;});}function assertSingleResourceDocument(payload){(test=>{if(!test){throw new Error(`Expected the primary data returned by the serializer for a 'queryRecord' response to be a single object or null but instead it was an array.`);}})(!Array.isArray(payload.data));}function queryRecord(context){const{store,data}=context.request;// eslint-disable-next-line @typescript-eslint/no-shadow\nconst{type,query,options}=data;const adapter=store.adapterFor(type);(test=>{if(!test){throw new Error(`You tried to make a query but you have no adapter (for ${type})`);}})(adapter);(test=>{if(!test){throw new Error(`You tried to make a query but your adapter does not implement 'queryRecord'`);}})(typeof adapter.queryRecord==='function');const schema=store.modelFor(type);const promise=Promise.resolve().then(()=>adapter.queryRecord(store,schema,query,options));return promise.then(adapterPayload=>{const serializer=store.serializerFor(type);const payload=(0,_private_Dlia0pw1_js__WEBPACK_IMPORTED_MODULE_3__.n)(serializer,store,schema,adapterPayload,null,'queryRecord');assertSingleResourceDocument(payload);const identifier=store._push(payload,true);return identifier?store.peekRecord(identifier):null;});}/**\n * @module @ember-data/store\n * @class Store\n *//**\n    Returns an instance of the adapter for a given type. For\n    example, `adapterFor('person')` will return an instance of\n    the adapter located at `app/adapters/person.js`\n\n    If no `person` adapter is found, this method will look\n    for an `application` adapter (the default adapter for\n    your entire application).\n\n    @method adapterFor\n    @public\n    @param {String} modelName\n    @return Adapter\n  */function adapterFor(modelName,_allowMissing){(test=>{if(!test){throw new Error(`Attempted to call store.adapterFor(), but the store instance has already been destroyed.`);}})(!(this.isDestroying||this.isDestroyed));(test=>{if(!test){throw new Error(`You need to pass a model name to the store's adapterFor method`);}})(modelName);(test=>{if(!test){throw new Error(`Passing classes to store.adapterFor has been removed. Please pass a dasherized string instead of ${modelName}`);}})(typeof modelName==='string');this._adapterCache=this._adapterCache||Object.create(null);const normalizedModelName=(0,_ember_data_store_private__WEBPACK_IMPORTED_MODULE_2__._deprecatingNormalize)(modelName);const{_adapterCache}=this;let adapter=_adapterCache[normalizedModelName];if(adapter){return adapter;}const owner=(0,_ember_application__WEBPACK_IMPORTED_MODULE_0__.getOwner)(this);// name specific adapter\nadapter=owner.lookup(`adapter:${normalizedModelName}`);if(adapter!==undefined){_adapterCache[normalizedModelName]=adapter;return adapter;}// no adapter found for the specific name, fallback and check for application adapter\nadapter=_adapterCache.application||owner.lookup('adapter:application');if(adapter!==undefined){_adapterCache[normalizedModelName]=adapter;_adapterCache.application=adapter;return adapter;}(test=>{if(!test){throw new Error(`No adapter was found for '${modelName}' and no 'application' adapter was found as a fallback.`);}})(_allowMissing);}/**\n    Returns an instance of the serializer for a given type. For\n    example, `serializerFor('person')` will return an instance of\n    `App.PersonSerializer`.\n\n    If no `App.PersonSerializer` is found, this method will look\n    for an `App.ApplicationSerializer` (the default serializer for\n    your entire application).\n\n    If a serializer cannot be found on the adapter, it will fall back\n    to an instance of `JSONSerializer`.\n\n    @method serializerFor\n    @public\n    @param {String} modelName the record to serialize\n    @return {Serializer}\n  */function serializerFor(modelName){(test=>{if(!test){throw new Error(`Attempted to call store.serializerFor(), but the store instance has already been destroyed.`);}})(!(this.isDestroying||this.isDestroyed));(test=>{if(!test){throw new Error(`You need to pass a model name to the store's serializerFor method`);}})(modelName);(test=>{if(!test){throw new Error(`Passing classes to store.serializerFor has been removed. Please pass a dasherized string instead of ${modelName}`);}})(typeof modelName==='string');this._serializerCache=this._serializerCache||Object.create(null);const normalizedModelName=(0,_ember_data_store_private__WEBPACK_IMPORTED_MODULE_2__._deprecatingNormalize)(modelName);const{_serializerCache}=this;let serializer=_serializerCache[normalizedModelName];if(serializer){return serializer;}// by name\nconst owner=(0,_ember_application__WEBPACK_IMPORTED_MODULE_0__.getOwner)(this);serializer=owner.lookup(`serializer:${normalizedModelName}`);if(serializer!==undefined){_serializerCache[normalizedModelName]=serializer;return serializer;}// no serializer found for the specific model, fallback and check for application serializer\nserializer=_serializerCache.application||owner.lookup('serializer:application');if(serializer!==undefined){_serializerCache[normalizedModelName]=serializer;_serializerCache.application=serializer;return serializer;}return null;}/**\n    `normalize` converts a json payload into the normalized form that\n    [push](../methods/push?anchor=push) expects.\n\n    Example\n\n    ```js\n    socket.on('message', function(message) {\n      let modelName = message.model;\n      let data = message.data;\n      store.push(store.normalize(modelName, data));\n    });\n    ```\n\n    @method normalize\n    @public\n    @param {String} modelName The name of the model type for this payload\n    @param {Object} payload\n    @return {Object} The normalized payload\n  */// TODO @runspired @deprecate users should call normalize on the associated serializer directly\nfunction normalize(modelName,payload){(test=>{if(!test){throw new Error(`Attempted to call store.normalize(), but the store instance has already been destroyed.`);}})(!(this.isDestroying||this.isDestroyed));(test=>{if(!test){throw new Error(`You need to pass a model name to the store's normalize method`);}})(modelName);(test=>{if(!test){throw new Error(`Passing classes to store methods has been removed. Please pass a dasherized string instead of ${typeof modelName}`);}})(typeof modelName==='string');const normalizedModelName=(0,_ember_data_store_private__WEBPACK_IMPORTED_MODULE_2__._deprecatingNormalize)(modelName);const serializer=this.serializerFor(normalizedModelName);const schema=this.modelFor(normalizedModelName);(test=>{if(!test){throw new Error(`You must define a normalize method in your serializer in order to call store.normalize`);}})(typeof serializer?.normalize==='function');return serializer.normalize(schema,payload);}/**\n    Push some raw data into the store.\n\n    This method can be used both to push in brand new\n    records, as well as to update existing records. You\n    can push in more than one type of object at once.\n    All objects should be in the format expected by the\n    serializer.\n\n    ```app/serializers/application.js\n    import RESTSerializer from '@ember-data/serializer/rest';\n\n    export default class ApplicationSerializer extends RESTSerializer;\n    ```\n\n    ```js\n    let pushData = {\n      posts: [\n        { id: 1, postTitle: \"Great post\", commentIds: [2] }\n      ],\n      comments: [\n        { id: 2, commentBody: \"Insightful comment\" }\n      ]\n    }\n\n    store.pushPayload(pushData);\n    ```\n\n    By default, the data will be deserialized using a default\n    serializer (the application serializer if it exists).\n\n    Alternatively, `pushPayload` will accept a model type which\n    will determine which serializer will process the payload.\n\n    ```app/serializers/application.js\n    import RESTSerializer from '@ember-data/serializer/rest';\n\n     export default class ApplicationSerializer extends RESTSerializer;\n    ```\n\n    ```app/serializers/post.js\n    import JSONSerializer from '@ember-data/serializer/json';\n\n    export default JSONSerializer;\n    ```\n\n    ```js\n    store.pushPayload(pushData); // Will use the application serializer\n    store.pushPayload('post', pushData); // Will use the post serializer\n    ```\n\n    @method pushPayload\n    @public\n    @param {String} modelName Optionally, a model type used to determine which serializer will be used\n    @param {Object} inputPayload\n  */// TODO @runspired @deprecate pushPayload in favor of looking up the serializer\nfunction pushPayload(modelName,inputPayload){(test=>{if(!test){throw new Error(`Attempted to call store.pushPayload(), but the store instance has already been destroyed.`);}})(!(this.isDestroying||this.isDestroyed));const payload=inputPayload||modelName;const normalizedModelName=inputPayload?(0,_ember_data_store_private__WEBPACK_IMPORTED_MODULE_2__._deprecatingNormalize)(modelName):'application';const serializer=this.serializerFor(normalizedModelName);(test=>{if(!test){throw new Error(`You cannot use 'store.pushPayload(<type>, <payload>)' unless the serializer for '${normalizedModelName}' defines 'pushPayload'`);}})(serializer&&typeof serializer.pushPayload==='function');serializer.pushPayload(this,payload);}// TODO @runspired @deprecate records should implement their own serialization if desired\nfunction serializeRecord(record,options){// TODO we used to check if the record was destroyed here\nif(!this._fetchManager){this._fetchManager=new _private_Dlia0pw1_js__WEBPACK_IMPORTED_MODULE_3__.F(this);}return this._fetchManager.createSnapshot((0,_ember_data_store__WEBPACK_IMPORTED_MODULE_1__.recordIdentifierFor)(record)).serialize(options);}function cleanup(){// enqueue destruction of any adapters/serializers we have created\nfor(const adapterName in this._adapterCache){const adapter=this._adapterCache[adapterName];if(typeof adapter.destroy==='function'){adapter.destroy();}}for(const serializerName in this._serializerCache){const serializer=this._serializerCache[serializerName];if(typeof serializer.destroy==='function'){serializer.destroy();}}}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@ember-data/legacy-compat/dist/index.js?");

/***/ }),

/***/ "./node_modules/@ember-data/model/dist/has-many-B4g8UjGD.js":
/*!******************************************************************!*\
  !*** ./node_modules/@ember-data/model/dist/has-many-B4g8UjGD.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ attr),\n/* harmony export */   b: () => (/* binding */ belongsTo),\n/* harmony export */   h: () => (/* binding */ hasMany)\n/* harmony export */ });\n/* harmony import */ var _ember_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ember/object */ \"@ember/object\");\n/* harmony import */ var _ember_object__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ember_object__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ember_data_store__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ember-data/store */ \"./node_modules/@ember-data/store/dist/index.js\");\n/* harmony import */ var _ember_data_store_private__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ember-data/store/-private */ \"./node_modules/@ember-data/store/dist/-private.js\");\n/* harmony import */ var _model_CrihGN_B_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./model-CrihGN_B.js */ \"./node_modules/@ember-data/model/dist/model-CrihGN_B.js\");\n/* harmony import */ var _ember_debug__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ember/debug */ \"@ember/debug\");\n/* harmony import */ var _ember_debug__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_ember_debug__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _warp_drive_core_types_symbols__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @warp-drive/core-types/symbols */ \"./node_modules/@warp-drive/core-types/dist/symbols.js\");\n/* harmony import */ var _ember_data_request_utils_string__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ember-data/request-utils/string */ \"./node_modules/@ember-data/request-utils/dist/string.js\");\n/**\n  @module @ember-data/model\n*/function _attr(type,options){if(typeof type==='object'){options=type;type=undefined;}else{options=options||{};}const meta={type:type,kind:'attribute',isAttribute:true,options:options,key:null};return (0,_ember_object__WEBPACK_IMPORTED_MODULE_0__.computed)({get(key){{if(['currentState'].includes(key)){throw new Error(`'${key}' is a reserved property name on instances of classes extending Model. Please choose a different property name for your attr on ${this.constructor.toString()}`);}}if(this.isDestroyed||this.isDestroying){return;}return (0,_ember_data_store_private__WEBPACK_IMPORTED_MODULE_2__.peekCache)(this).getAttr((0,_ember_data_store__WEBPACK_IMPORTED_MODULE_1__.recordIdentifierFor)(this),key);},set(key,value){{if(['currentState'].includes(key)){throw new Error(`'${key}' is a reserved property name on instances of classes extending Model. Please choose a different property name for your attr on ${this.constructor.toString()}`);}}const identifier=(0,_ember_data_store__WEBPACK_IMPORTED_MODULE_1__.recordIdentifierFor)(this);(test=>{if(!test){throw new Error(`Attempted to set '${key}' on the deleted record ${identifier.type}:${identifier.id} (${identifier.lid})`);}})(!this.currentState.isDeleted);const cache=(0,_ember_data_store_private__WEBPACK_IMPORTED_MODULE_2__.peekCache)(this);const currentValue=cache.getAttr(identifier,key);if(currentValue!==value){cache.setAttr(identifier,key,value);if(!this.isValid){const{errors}=this;if(errors.get(key)){errors.remove(key);this.currentState.cleanErrorRequests();}}}return value;}}).meta(meta);}// NOTE: Usage of Explicit ANY\n// -------------------------------------------------------------------\n// any is required here because we are the maximal not the minimal\n// subset of options allowed. If we used unknown, object, or\n// Record<string, unknown> we would get type errors when we try to\n// assert against a more specific implementation with precise options.\n// -------------------------------------------------------------------\n// see note on Explicit ANY above\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n/**\n * The return type of `void` is a lie to appease TypeScript. The actual return type\n * is a descriptor, but typescript incorrectly insists that decorator functions return\n * `void` or `any`.\n *\n * @typedoc\n *//**\n  `attr` defines an attribute on a [Model](/ember-data/release/classes/Model).\n  By default, attributes are passed through as-is, however you can specify an\n  optional type to have the value automatically transformed.\n  EmberData ships with four basic transform types: `string`, `number`,\n  `boolean` and `date`. You can define your own transforms by subclassing\n  [Transform](/ember-data/release/classes/Transform).\n\n  Note that you cannot use `attr` to define an attribute of `id`.\n\n  `attr` takes an optional hash as a second parameter, currently\n  supported options are:\n\n  - `defaultValue`: Pass a string or a function to be called to set the attribute\n  to a default value if and only if the key is absent from the payload response.\n\n  Example\n\n  ```app/models/user.js\n  import Model, { attr } from '@ember-data/model';\n\n  export default class UserModel extends Model {\n    @attr('string') username;\n    @attr('string') email;\n    @attr('boolean', { defaultValue: false }) verified;\n  }\n  ```\n\n  Default value can also be a function. This is useful it you want to return\n  a new object for each attribute.\n\n  ```app/models/user.js\n  import Model, { attr } from '@ember-data/model';\n\n  export default class UserModel extends Model {\n    @attr('string') username;\n    @attr('string') email;\n\n    @attr({\n      defaultValue() {\n        return {};\n      }\n    })\n    settings;\n  }\n  ```\n\n  The `options` hash is passed as second argument to a transforms'\n  `serialize` and `deserialize` method. This allows to configure a\n  transformation and adapt the corresponding value, based on the config:\n\n  ```app/models/post.js\n  import Model, { attr } from '@ember-data/model';\n\n  export default class PostModel extends Model {\n    @attr('text', {\n      uppercase: true\n    })\n    text;\n  }\n  ```\n\n  ```app/transforms/text.js\n  export default class TextTransform {\n    serialize(value, options) {\n      if (options.uppercase) {\n        return value.toUpperCase();\n      }\n\n      return value;\n    }\n\n    deserialize(value) {\n      return value;\n    }\n\n    static create() {\n      return new this();\n    }\n  }\n  ```\n\n  @method attr\n  @public\n  @static\n  @for @ember-data/model\n  @param {String|Object} type the attribute type\n  @param {Object} options a hash of options\n  @return {Attribute}\n*/// see note on DataDecorator for why void\nfunction attr(type,options,desc){const args=[type,options,desc];// see note on DataDecorator for why void\nreturn (0,_model_CrihGN_B_js__WEBPACK_IMPORTED_MODULE_3__.k)(args)?_attr()(...args):_attr(type,options);}//   get: () => getT;\n//   // set: (value: Awaited<getT>) => void;\n//   set: (value: getT) => void;\n//   // init: () => getT;\n// };\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n// BelongsToDecoratorObject<getT>;\nfunction _belongsTo(type,options){(test=>{if(!test){throw new Error(`Expected options.async from @belongsTo('${type}', options) to be a boolean`);}})(options&&typeof options.async==='boolean');(test=>{if(!test){throw new Error(`Expected options.inverse from @belongsTo('${type}', options) to be either null or the string type of the related resource.`);}})(options.inverse===null||typeof options.inverse==='string'&&options.inverse.length>0);const meta={type:(0,_model_CrihGN_B_js__WEBPACK_IMPORTED_MODULE_3__.n)(type),options:options,kind:'belongsTo',name:'<Unknown BelongsTo>'};return (0,_ember_object__WEBPACK_IMPORTED_MODULE_0__.computed)({get(key){// this is a legacy behavior we may not carry into a new model setup\n// it's better to error on disconnected records so users find errors\n// in their logic.\nif(this.isDestroying||this.isDestroyed){return null;}const support=(0,_model_CrihGN_B_js__WEBPACK_IMPORTED_MODULE_3__.l)(this);{if(['currentState'].includes(key)){throw new Error(`'${key}' is a reserved property name on instances of classes extending Model. Please choose a different property name for your belongsTo on ${this.constructor.toString()}`);}if(Object.prototype.hasOwnProperty.call(options,'serialize')){(0,_ember_debug__WEBPACK_IMPORTED_MODULE_4__.warn)(`You provided a serialize option on the \"${key}\" property in the \"${support.identifier.type}\" class, this belongs in the serializer. See Serializer and it's implementations https://api.emberjs.com/ember-data/release/classes/Serializer`,false,{id:'ds.model.serialize-option-in-belongs-to'});}if(Object.prototype.hasOwnProperty.call(options,'embedded')){(0,_ember_debug__WEBPACK_IMPORTED_MODULE_4__.warn)(`You provided an embedded option on the \"${key}\" property in the \"${support.identifier.type}\" class, this belongs in the serializer. See EmbeddedRecordsMixin https://api.emberjs.com/ember-data/release/classes/EmbeddedRecordsMixin`,false,{id:'ds.model.embedded-option-in-belongs-to'});}}return support.getBelongsTo(key);},set(key,value){const support=(0,_model_CrihGN_B_js__WEBPACK_IMPORTED_MODULE_3__.l)(this);{if(['currentState'].includes(key)){throw new Error(`'${key}' is a reserved property name on instances of classes extending Model. Please choose a different property name for your belongsTo on ${this.constructor.toString()}`);}}this[_warp_drive_core_types_symbols__WEBPACK_IMPORTED_MODULE_5__.RecordStore]._join(()=>{support.setDirtyBelongsTo(key,value);});return support.getBelongsTo(key);}}).meta(meta);}/**\n  `belongsTo` is used to define One-To-One and One-To-Many, and One-To-None\n  relationships on a [Model](/ember-data/release/classes/Model).\n\n  `belongsTo` takes a configuration hash as a second parameter, currently\n  supported options are:\n\n  - `async`: (*required*) A boolean value used to declare whether this is a sync (false) or async (true) relationship.\n  - `inverse`: (*required*)  A string used to identify the inverse property on a related model, or `null`.\n  - `polymorphic`: (*optional*) A boolean value to mark the relationship as polymorphic\n  - `as`: (*optional*) A string used to declare the abstract type \"this\" record satisfies for polymorphism.\n\n  ### Examples\n\n  To declare a **one-to-many** (or many-to-many) relationship, use\n  `belongsTo` in combination with `hasMany`:\n\n  ```js\n  // app/models/comment.js\n  import Model, { belongsTo } from '@ember-data/model';\n\n  export default class Comment extends Model {\n    @belongsTo('post', { async: false, inverse: 'comments' }) post;\n  }\n\n  // app/models/post.js\n  import Model, { hasMany } from '@ember-data/model';\n\n  export default class Post extends Model {\n    @hasMany('comment', { async: false, inverse: 'post' }) comments;\n  }\n  ```\n\n  To declare a **one-to-one** relationship with managed inverses, use `belongsTo` for both sides:\n\n  ```js\n  // app/models/author.js\n  import Model, { belongsTo } from '@ember-data/model';\n\n  export default class Author extends Model {\n    @belongsTo('address', { async: true, inverse: 'owner' }) address;\n  }\n\n  // app/models/address.js\n  import Model, { belongsTo } from '@ember-data/model';\n\n  export default class Address extends Model {\n    @belongsTo('author', { async: true, inverse: 'address' }) owner;\n  }\n  ```\n\n  To declare a **one-to-one** relationship without managed inverses, use `belongsTo` for both sides\n  with `null` as the inverse:\n\n  ```js\n  // app/models/author.js\n  import Model, { belongsTo } from '@ember-data/model';\n\n  export default class Author extends Model {\n    @belongsTo('address', { async: true, inverse: null }) address;\n  }\n\n  // app/models/address.js\n  import Model, { belongsTo } from '@ember-data/model';\n\n  export default class Address extends Model {\n    @belongsTo('author', { async: true, inverse: null }) owner;\n  }\n  ```\n\n  To declare a one-to-none relationship between two models, use\n  `belongsTo` with inverse set to `null` on just one side::\n\n  ```js\n  // app/models/person.js\n  import Model, { belongsTo } from '@ember-data/model';\n\n  export default class Person extends Model {\n    @belongsTo('person', { async: false, inverse: null }) bestFriend;\n  }\n  ```\n\n  #### Sync vs Async Relationships\n\n  EmberData fulfills relationships using resource data available in\n  the cache.\n\n  Sync relationships point directly to the known related resources.\n\n  When a relationship is declared as async, if any of the known related\n  resources have not been loaded, they will be fetched. The property\n  on the record when accessed provides a promise that resolves once\n  all resources are loaded.\n\n  Async relationships may take advantage of links. On access, if the related\n  link has not been loaded, or if any known resources are not available in\n  the cache, the fresh state will be fetched using the link.\n\n  In contrast to async relationship, accessing a sync relationship\n  will error on access when any of the known related resources have\n  not been loaded.\n\n  If you are using `links` with sync relationships, you have to use\n  the BelongsTo reference API to fetch or refresh related resources\n  that aren't loaded. For instance, for a `bestFriend` relationship:\n\n  ```js\n  person.belongsTo('bestFriend').reload();\n  ```\n\n  #### Polymorphic Relationships\n\n  To declare a polymorphic relationship, use `hasMany` with the `polymorphic`\n  option set to `true`:\n\n  ```js\n  // app/models/comment.js\n  import Model, { belongsTo } from '@ember-data/model';\n\n  export default class Comment extends Model {\n    @belongsTo('commentable', { async: false, inverse: 'comments', polymorphic: true }) parent;\n  }\n  ```\n\n  `'commentable'` here is referred to as the \"abstract type\" for the polymorphic\n  relationship.\n\n  Polymorphic relationships with `inverse: null` will accept any type of record as their content.\n  Polymorphic relationships with `inverse` set to a string will only accept records with a matching\n  inverse relationships declaring itself as satisfying the abstract type.\n\n  Below, 'as' is used to declare the that 'post' record satisfies the abstract type 'commentable'\n  for this relationship.\n\n  ```js\n  // app/models/post.js\n  import Model, { hasMany } from '@ember-data/model';\n\n  export default class Post extends Model {\n    @hasMany('comment', { async: false, inverse: 'parent', as: 'commentable' }) comments;\n  }\n  ```\n\n  Note: every Model that declares an inverse to a polymorphic relationship must\n  declare itself exactly the same. This is because polymorphism is based on structural\n  traits.\n\n  Polymorphic to polymorphic relationships are supported. Both sides of the relationship\n  must be declared as polymorphic, and the `as` option must be used to declare the abstract\n  type each record satisfies on both sides.\n\n  @method belongsTo\n  @public\n  @static\n  @for @ember-data/model\n  @param {string} type (optional) the name of the related resource\n  @param {object} options (optional) a hash of options\n  @return {PropertyDescriptor} relationship\n*/// export function belongsTo<K extends Promise<unknown>, T extends Awaited<K> = Awaited<K>>(\n//   type: TypeFromInstance<NoNull<T>>,\n//   options: RelationshipOptions<T, true>\n// ): RelationshipDecorator<K>;\nfunction belongsTo(type,options){{(test=>{if(!test){throw new Error(`belongsTo must be invoked with a type and options. Did you mean \\`@belongsTo(${type}, { async: false, inverse: null })\\`?`);}})(!(0,_model_CrihGN_B_js__WEBPACK_IMPORTED_MODULE_3__.k)(arguments));}return _belongsTo(type,options);}/**\n  @module @ember-data/model\n*/function normalizeType(type){{const result=(0,_ember_data_request_utils_string__WEBPACK_IMPORTED_MODULE_6__.singularize)((0,_ember_data_request_utils_string__WEBPACK_IMPORTED_MODULE_6__.dasherize)(type));(0,_ember_debug__WEBPACK_IMPORTED_MODULE_4__.deprecate)(`The resource type '${type}' is not normalized. Update your application code to use '${result}' instead of '${type}'.`,result===type,{id:'ember-data:deprecate-non-strict-types',until:'6.0',for:'ember-data',since:{available:'5.3',enabled:'5.3'}});return result;}return type;}function _hasMany(type,options){(test=>{if(!test){throw new Error(`Expected hasMany options.async to be a boolean`);}})(options&&typeof options.async==='boolean');// Metadata about relationships is stored on the meta of\n// the relationship. This is used for introspection and\n// serialization. Note that `key` is populated lazily\n// the first time the CP is called.\nconst meta={type:normalizeType(type),options,kind:'hasMany',name:'<Unknown BelongsTo>'};return (0,_ember_object__WEBPACK_IMPORTED_MODULE_0__.computed)({get(key){{if(['currentState'].includes(key)){throw new Error(`'${key}' is a reserved property name on instances of classes extending Model. Please choose a different property name for your hasMany on ${this.constructor.toString()}`);}}if(this.isDestroying||this.isDestroyed){return[];}return (0,_model_CrihGN_B_js__WEBPACK_IMPORTED_MODULE_3__.l)(this).getHasMany(key);},set(key,records){{if(['currentState'].includes(key)){throw new Error(`'${key}' is a reserved property name on instances of classes extending Model. Please choose a different property name for your hasMany on ${this.constructor.toString()}`);}}const support=(0,_model_CrihGN_B_js__WEBPACK_IMPORTED_MODULE_3__.l)(this);const manyArray=support.getManyArray(key);(test=>{if(!test){throw new Error(`You must pass an array of records to set a hasMany relationship`);}})(Array.isArray(records));this[_warp_drive_core_types_symbols__WEBPACK_IMPORTED_MODULE_5__.RecordStore]._join(()=>{manyArray.splice(0,manyArray.length,...records);});return support.getHasMany(key);}}).meta(meta);}/**\n  `hasMany` is used to define Many-To-One and Many-To-Many, and Many-To-None\n  relationships on a [Model](/ember-data/release/classes/Model).\n\n  `hasMany` takes a configuration hash as a second parameter, currently\n  supported options are:\n\n  - `async`: (*required*) A boolean value used to declare whether this is a sync (false) or async (true) relationship.\n  - `inverse`: (*required*)  A string used to identify the inverse property on a related model, or `null`.\n  - `polymorphic`: (*optional*) A boolean value to mark the relationship as polymorphic\n  - `as`: (*optional*) A string used to declare the abstract type \"this\" record satisfies for polymorphism.\n\n  ### Examples\n\n  To declare a **many-to-one** (or one-to-many) relationship, use\n  `belongsTo` in combination with `hasMany`:\n\n  ```js\n  // app/models/post.js\n  import Model, { hasMany } from '@ember-data/model';\n\n  export default class Post extends Model {\n    @hasMany('comment', { async: false, inverse: 'post' }) comments;\n  }\n\n\n  // app/models/comment.js\n  import Model, { belongsTo } from '@ember-data/model';\n\n  export default class Comment extends Model {\n    @belongsTo('post', { async: false, inverse: 'comments' }) post;\n  }\n  ```\n\n  To declare a **many-to-many** relationship with managed inverses, use `hasMany` for both sides:\n\n  ```js\n  // app/models/post.js\n  import Model, { hasMany } from '@ember-data/model';\n\n  export default class Post extends Model {\n    @hasMany('tag', { async: true, inverse: 'posts' }) tags;\n  }\n\n  // app/models/tag.js\n  import Model, { hasMany } from '@ember-data/model';\n\n  export default class Tag extends Model {\n    @hasMany('post', { async: true, inverse: 'tags' }) posts;\n  }\n  ```\n\n  To declare a **many-to-many** relationship without managed inverses, use `hasMany` for both sides\n  with `null` as the inverse:\n\n  ```js\n  // app/models/post.js\n  import Model, { hasMany } from '@ember-data/model';\n\n  export default class Post extends Model {\n    @hasMany('tag', { async: true, inverse: null }) tags;\n  }\n\n  // app/models/tag.js\n  import Model, { hasMany } from '@ember-data/model';\n\n  export default class Tag extends Model {\n    @hasMany('post', { async: true, inverse: null }) posts;\n  }\n  ```\n\n  To declare a many-to-none relationship between two models, use\n  `hasMany` with inverse set to `null` on just one side::\n\n  ```js\n  // app/models/post.js\n  import Model, { hasMany } from '@ember-data/model';\n\n  export default class Post extends Model {\n    @hasMany('category', { async: true, inverse: null }) categories;\n  }\n  ```\n\n  #### Sync vs Async Relationships\n\n  EmberData fulfills relationships using resource data available in\n  the cache.\n\n  Sync relationships point directly to the known related resources.\n\n  When a relationship is declared as async, if any of the known related\n  resources have not been loaded, they will be fetched. The property\n  on the record when accessed provides a promise that resolves once\n  all resources are loaded.\n\n  Async relationships may take advantage of links. On access, if the related\n  link has not been loaded, or if any known resources are not available in\n  the cache, the fresh state will be fetched using the link.\n\n  In contrast to async relationship, accessing a sync relationship\n  will error on access when any of the known related resources have\n  not been loaded.\n\n  If you are using `links` with sync relationships, you have to use\n  the HasMany reference API to fetch or refresh related resources\n  that aren't loaded. For instance, for a `comments` relationship:\n\n  ```js\n  post.hasMany('comments').reload();\n  ```\n\n  #### Polymorphic Relationships\n\n  To declare a polymorphic relationship, use `hasMany` with the `polymorphic`\n  option set to `true`:\n\n  ```js\n  // app/models/comment.js\n  import Model, { belongsTo } from '@ember-data/model';\n\n  export default class Comment extends Model {\n    @belongsTo('commentable', { async: false, inverse: 'comments', polymorphic: true }) parent;\n  }\n  ```\n\n  `'commentable'` here is referred to as the \"abstract type\" for the polymorphic\n  relationship.\n\n  Polymorphic relationships with `inverse: null` will accept any type of record as their content.\n  Polymorphic relationships with `inverse` set to a string will only accept records with a matching\n  inverse relationships declaring itself as satisfying the abstract type.\n\n  Below, 'as' is used to declare the that 'post' record satisfies the abstract type 'commentable'\n  for this relationship.\n\n  ```js\n  // app/models/post.js\n  import Model, { hasMany } from '@ember-data/model';\n\n  export default class Post extends Model {\n    @hasMany('comment', { async: false, inverse: 'parent', as: 'commentable' }) comments;\n  }\n  ```\n\n  Note: every Model that declares an inverse to a polymorphic relationship must\n  declare itself exactly the same. This is because polymorphism is based on structural\n  traits.\n\n  Polymorphic to polymorphic relationships are supported. Both sides of the relationship\n  must be declared as polymorphic, and the `as` option must be used to declare the abstract\n  type each record satisfies on both sides.\n\n  @method hasMany\n  @public\n  @static\n  @for @ember-data/model\n  @param {string} type (optional) the name of the related resource\n  @param {object} options (optional) a hash of options\n  @return {PropertyDescriptor} relationship\n*/// export function hasMany<K extends Promise<unknown>, T extends Awaited<K> = Awaited<K>>(\n//   type: TypeFromInstance<NoNull<T>>,\n//   options: RelationshipOptions<T, true>\n// ): RelationshipDecorator<K>;\nfunction hasMany(type,options){{(test=>{if(!test){throw new Error(`hasMany must be invoked with a type and options. Did you mean \\`@hasMany(${type}, { async: false, inverse: null })\\`?`);}})(!(0,_model_CrihGN_B_js__WEBPACK_IMPORTED_MODULE_3__.k)(arguments));}return _hasMany(type,options);}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@ember-data/model/dist/has-many-B4g8UjGD.js?");

/***/ }),

/***/ "./node_modules/@ember-data/model/dist/hooks-BfTsqpsG.js":
/*!***************************************************************!*\
  !*** ./node_modules/@ember-data/model/dist/hooks-BfTsqpsG.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   i: () => (/* binding */ instantiateRecord),\n/* harmony export */   m: () => (/* binding */ modelFor),\n/* harmony export */   t: () => (/* binding */ teardownRecord)\n/* harmony export */ });\n/* harmony import */ var _ember_application__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ember/application */ \"@ember/application\");\n/* harmony import */ var _ember_application__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ember_application__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ember_data_store_private__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ember-data/store/-private */ \"./node_modules/@ember-data/store/dist/-private.js\");\n/* harmony import */ var _schema_provider_CB0q21oL_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./schema-provider-CB0q21oL.js */ \"./node_modules/@ember-data/model/dist/schema-provider-CB0q21oL.js\");\n/* harmony import */ var _model_CrihGN_B_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./model-CrihGN_B.js */ \"./node_modules/@ember-data/model/dist/model-CrihGN_B.js\");\nfunction instantiateRecord(identifier,createRecordArgs){const type=identifier.type;const cache=this.cache;// TODO deprecate allowing unknown args setting\nconst createOptions={_createProps:createRecordArgs,// TODO @deprecate consider deprecating accessing record properties during init which the below is necessary for\n_secretInit:{identifier,cache,store:this,cb:secretInit}};// ensure that `getOwner(this)` works inside a model instance\n(0,_ember_application__WEBPACK_IMPORTED_MODULE_0__.setOwner)(createOptions,(0,_ember_application__WEBPACK_IMPORTED_MODULE_0__.getOwner)(this));const factory=(0,_schema_provider_CB0q21oL_js__WEBPACK_IMPORTED_MODULE_2__.g)(this,type);(test=>{if(!test){throw new Error(`No model was found for '${type}'`);}})(factory);return factory.class.create(createOptions);}function teardownRecord(record){(test=>{if(!test){throw new Error(`expected to receive an instance of Model from @ember-data/model. If using a custom model make sure you implement teardownRecord`);}})('destroy'in record);record.destroy();}function modelFor(modelName){(test=>{if(!test){throw new Error(`Attempted to call store.modelFor(), but the store instance has already been destroyed.`);}})(!this.isDestroyed&&!this.isDestroying);(test=>{if(!test){throw new Error(`You need to pass a model name to the store's modelFor method`);}})(modelName);(test=>{if(!test){throw new Error(`Please pass a proper model name to the store's modelFor method`);}})(typeof modelName==='string'&&modelName.length);const type=(0,_model_CrihGN_B_js__WEBPACK_IMPORTED_MODULE_3__.n)(modelName);const maybeFactory=(0,_schema_provider_CB0q21oL_js__WEBPACK_IMPORTED_MODULE_2__.g)(this,type);const klass=maybeFactory&&maybeFactory.class?maybeFactory.class:null;const ignoreType=!klass||!klass.isModel||this._forceShim;if(!ignoreType){return klass;}(test=>{if(!test){throw new Error(`No model was found for '${type}' and no schema handles the type`);}})(this.schema.hasResource({type}));}function secretInit(record,cache,identifier,store){(0,_ember_data_store_private__WEBPACK_IMPORTED_MODULE_1__.setRecordIdentifier)(record,identifier);_ember_data_store_private__WEBPACK_IMPORTED_MODULE_1__.StoreMap.set(record,store);(0,_ember_data_store_private__WEBPACK_IMPORTED_MODULE_1__.setCacheFor)(record,cache);}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@ember-data/model/dist/hooks-BfTsqpsG.js?");

/***/ }),

/***/ "./node_modules/@ember-data/model/dist/hooks.js":
/*!******************************************************!*\
  !*** ./node_modules/@ember-data/model/dist/hooks.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildSchema: () => (/* reexport safe */ _schema_provider_CB0q21oL_js__WEBPACK_IMPORTED_MODULE_1__.b),\n/* harmony export */   instantiateRecord: () => (/* reexport safe */ _hooks_BfTsqpsG_js__WEBPACK_IMPORTED_MODULE_0__.i),\n/* harmony export */   modelFor: () => (/* reexport safe */ _hooks_BfTsqpsG_js__WEBPACK_IMPORTED_MODULE_0__.m),\n/* harmony export */   teardownRecord: () => (/* reexport safe */ _hooks_BfTsqpsG_js__WEBPACK_IMPORTED_MODULE_0__.t)\n/* harmony export */ });\n/* harmony import */ var _hooks_BfTsqpsG_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hooks-BfTsqpsG.js */ \"./node_modules/@ember-data/model/dist/hooks-BfTsqpsG.js\");\n/* harmony import */ var _schema_provider_CB0q21oL_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./schema-provider-CB0q21oL.js */ \"./node_modules/@ember-data/model/dist/schema-provider-CB0q21oL.js\");\n\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@ember-data/model/dist/hooks.js?");

/***/ }),

/***/ "./node_modules/@ember-data/model/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@ember-data/model/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ModelSchemaProvider: () => (/* reexport safe */ _schema_provider_CB0q21oL_js__WEBPACK_IMPORTED_MODULE_3__.M),\n/* harmony export */   attr: () => (/* reexport safe */ _has_many_B4g8UjGD_js__WEBPACK_IMPORTED_MODULE_0__.a),\n/* harmony export */   belongsTo: () => (/* reexport safe */ _has_many_B4g8UjGD_js__WEBPACK_IMPORTED_MODULE_0__.b),\n/* harmony export */   \"default\": () => (/* reexport safe */ _model_CrihGN_B_js__WEBPACK_IMPORTED_MODULE_1__.M),\n/* harmony export */   hasMany: () => (/* reexport safe */ _has_many_B4g8UjGD_js__WEBPACK_IMPORTED_MODULE_0__.h),\n/* harmony export */   instantiateRecord: () => (/* reexport safe */ _hooks_BfTsqpsG_js__WEBPACK_IMPORTED_MODULE_2__.i),\n/* harmony export */   modelFor: () => (/* reexport safe */ _hooks_BfTsqpsG_js__WEBPACK_IMPORTED_MODULE_2__.m),\n/* harmony export */   teardownRecord: () => (/* reexport safe */ _hooks_BfTsqpsG_js__WEBPACK_IMPORTED_MODULE_2__.t)\n/* harmony export */ });\n/* harmony import */ var _has_many_B4g8UjGD_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./has-many-B4g8UjGD.js */ \"./node_modules/@ember-data/model/dist/has-many-B4g8UjGD.js\");\n/* harmony import */ var _model_CrihGN_B_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./model-CrihGN_B.js */ \"./node_modules/@ember-data/model/dist/model-CrihGN_B.js\");\n/* harmony import */ var _hooks_BfTsqpsG_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hooks-BfTsqpsG.js */ \"./node_modules/@ember-data/model/dist/hooks-BfTsqpsG.js\");\n/* harmony import */ var _schema_provider_CB0q21oL_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./schema-provider-CB0q21oL.js */ \"./node_modules/@ember-data/model/dist/schema-provider-CB0q21oL.js\");\n\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@ember-data/model/dist/index.js?");

/***/ }),

/***/ "./node_modules/@ember-data/model/dist/model-CrihGN_B.js":
/*!***************************************************************!*\
  !*** ./node_modules/@ember-data/model/dist/model-CrihGN_B.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   E: () => (/* binding */ Errors),\n/* harmony export */   L: () => (/* binding */ LEGACY_SUPPORT),\n/* harmony export */   M: () => (/* binding */ Model),\n/* harmony export */   P: () => (/* binding */ PromiseBelongsTo),\n/* harmony export */   R: () => (/* binding */ RelatedCollection),\n/* harmony export */   a: () => (/* binding */ PromiseManyArray),\n/* harmony export */   b: () => (/* binding */ save),\n/* harmony export */   c: () => (/* binding */ reload),\n/* harmony export */   d: () => (/* binding */ destroyRecord),\n/* harmony export */   e: () => (/* binding */ deleteRecord),\n/* harmony export */   f: () => (/* binding */ RecordState),\n/* harmony export */   g: () => (/* binding */ changedAttributes),\n/* harmony export */   h: () => (/* binding */ hasMany),\n/* harmony export */   i: () => (/* binding */ belongsTo),\n/* harmony export */   j: () => (/* binding */ createSnapshot),\n/* harmony export */   k: () => (/* binding */ isElementDescriptor),\n/* harmony export */   l: () => (/* binding */ lookupLegacySupport),\n/* harmony export */   n: () => (/* binding */ normalizeModelName),\n/* harmony export */   r: () => (/* binding */ rollbackAttributes),\n/* harmony export */   s: () => (/* binding */ serialize),\n/* harmony export */   u: () => (/* binding */ unloadRecord)\n/* harmony export */ });\n/* harmony import */ var _ember_debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ember/debug */ \"@ember/debug\");\n/* harmony import */ var _ember_debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ember_debug__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ember_data_request_utils_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ember-data/request-utils/string */ \"./node_modules/@ember-data/request-utils/dist/string.js\");\n/* harmony import */ var _ember_object__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ember/object */ \"@ember/object\");\n/* harmony import */ var _ember_object__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_ember_object__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _ember_data_store__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ember-data/store */ \"./node_modules/@ember-data/store/dist/index.js\");\n/* harmony import */ var _ember_data_store_private__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ember-data/store/-private */ \"./node_modules/@ember-data/store/dist/-private.js\");\n/* harmony import */ var _ember_data_tracking__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ember-data/tracking */ \"./node_modules/@ember-data/tracking/dist/index.js\");\n/* harmony import */ var _ember_data_tracking_private__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ember-data/tracking/-private */ \"./node_modules/@ember-data/tracking/dist/-private.js\");\n/* harmony import */ var _warp_drive_core_types_symbols__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @warp-drive/core-types/symbols */ \"./node_modules/@warp-drive/core-types/dist/symbols.js\");\n/* harmony import */ var _ember_array__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ember/array */ \"@ember/array\");\n/* harmony import */ var _ember_array__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_ember_array__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _ember_array_proxy__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ember/array/proxy */ \"@ember/array/proxy\");\n/* harmony import */ var _ember_array_proxy__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_ember_array_proxy__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var _ember_object_computed__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ember/object/computed */ \"@ember/object/computed\");\n/* harmony import */ var _ember_object_computed__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_ember_object_computed__WEBPACK_IMPORTED_MODULE_10__);\n/* harmony import */ var _ember_data_legacy_compat_private__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @ember-data/legacy-compat/-private */ \"./node_modules/@ember-data/legacy-compat/dist/-private.js\");\n/* harmony import */ var _warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @warp-drive/core-types/-private */ \"./node_modules/@warp-drive/core-types/dist/-private.js\");\n/* harmony import */ var _ember_object_promise_proxy_mixin__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @ember/object/promise-proxy-mixin */ \"@ember/object/promise-proxy-mixin\");\n/* harmony import */ var _ember_object_promise_proxy_mixin__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_ember_object_promise_proxy_mixin__WEBPACK_IMPORTED_MODULE_13__);\n/* harmony import */ var _ember_object_proxy__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @ember/object/proxy */ \"@ember/object/proxy\");\n/* harmony import */ var _ember_object_proxy__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(_ember_object_proxy__WEBPACK_IMPORTED_MODULE_14__);\n/* harmony import */ var _ember_object_internals__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @ember/object/internals */ \"@ember/object/internals\");\n/* harmony import */ var _ember_object_internals__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(_ember_object_internals__WEBPACK_IMPORTED_MODULE_15__);\n/* harmony import */ var _embroider_macros_src_addon_es_compat2__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../../@embroider/macros/src/addon/es-compat2 */ \"./node_modules/@embroider/macros/src/addon/es-compat2.js\");\nvar _PromiseBelongsTo,_PromiseManyArray,_HasManyReference,_BelongsToReference,_Errors,_RecordState,_Model;function _classPrivateFieldInitSpec(e,t,a){_checkPrivateRedeclaration(e,t),t.set(e,a);}function _checkPrivateRedeclaration(e,t){if(t.has(e))throw new TypeError(\"Cannot initialize the same private elements twice on an object\");}function _defineProperty(e,r,t){return(r=_toPropertyKey(r))in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e;}function _toPropertyKey(t){var i=_toPrimitive(t,\"string\");return\"symbol\"==typeof i?i:i+\"\";}function _toPrimitive(t,r){if(\"object\"!=typeof t||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e.call(t,r||\"default\");if(\"object\"!=typeof i)return i;throw new TypeError(\"@@toPrimitive must return a primitive value.\");}return(\"string\"===r?String:Number)(t);}function isElementDescriptor(args){const[maybeTarget,maybeKey,maybeDesc]=args;return(// Ensure we have the right number of args\nargs.length===3&&(// Make sure the target is a class or object (prototype)\ntypeof maybeTarget==='function'||typeof maybeTarget==='object'&&maybeTarget!==null)&&// Make sure the key is a string\ntypeof maybeKey==='string'&&(// Make sure the descriptor is the right shape\ntypeof maybeDesc==='object'&&maybeDesc!==null&&'enumerable'in maybeDesc&&'configurable'in maybeDesc||// TS compatibility\nmaybeDesc===undefined));}function normalizeModelName(type){{const result=(0,_ember_data_request_utils_string__WEBPACK_IMPORTED_MODULE_1__.dasherize)(type);(0,_ember_debug__WEBPACK_IMPORTED_MODULE_0__.deprecate)(`The resource type '${type}' is not normalized. Update your application code to use '${result}' instead of '${type}'.`,result===type,{id:'ember-data:deprecate-non-strict-types',until:'6.0',for:'ember-data',since:{available:'5.3',enabled:'5.3'}});return result;}return type;}/**\n  @module @ember-data/store\n*//**\n  A `ManyArray` is a `MutableArray` that represents the contents of a has-many\n  relationship.\n\n  The `ManyArray` is instantiated lazily the first time the relationship is\n  requested.\n\n  This class is not intended to be directly instantiated by consuming applications.\n\n  ### Inverses\n\n  Often, the relationships in Ember Data applications will have\n  an inverse. For example, imagine the following models are\n  defined:\n\n  ```app/models/post.js\n  import Model, { hasMany } from '@ember-data/model';\n\n  export default class PostModel extends Model {\n    @hasMany('comment') comments;\n  }\n  ```\n\n  ```app/models/comment.js\n  import Model, { belongsTo } from '@ember-data/model';\n\n  export default class CommentModel extends Model {\n    @belongsTo('post') post;\n  }\n  ```\n\n  If you created a new instance of `Post` and added\n  a `Comment` record to its `comments` has-many\n  relationship, you would expect the comment's `post`\n  property to be set to the post that contained\n  the has-many.\n\n  We call the record to which a relationship belongs-to the\n  relationship's _owner_.\n\n  @class ManyArray\n  @public\n*/class RelatedCollection extends _ember_data_store_private__WEBPACK_IMPORTED_MODULE_4__.LiveArray{/**\n    The loading state of this array\n     @property {Boolean} isLoaded\n    @public\n    *//**\n    `true` if the relationship is polymorphic, `false` otherwise.\n     @property {Boolean} isPolymorphic\n    @private\n    *//**\n    Metadata associated with the request for async hasMany relationships.\n     Example\n     Given that the server returns the following JSON payload when fetching a\n    hasMany relationship:\n     ```js\n    {\n      \"comments\": [{\n        \"id\": 1,\n        \"comment\": \"This is the first comment\",\n      }, {\n    // ...\n      }],\n       \"meta\": {\n        \"page\": 1,\n        \"total\": 5\n      }\n    }\n    ```\n     You can then access the meta data via the `meta` property:\n     ```js\n    let comments = await post.comments;\n    let meta = comments.meta;\n     // meta.page => 1\n    // meta.total => 5\n    ```\n     @property {Object | null} meta\n    @public\n    *//**\n     * Retrieve the links for this relationship\n     *\n     @property {Object | null} links\n     @public\n     */constructor(options){super(options);this.isLoaded=options.isLoaded||false;this.isAsync=options.isAsync||false;this.isPolymorphic=options.isPolymorphic||false;this.identifier=options.identifier;this.key=options.key;}[_ember_data_store_private__WEBPACK_IMPORTED_MODULE_4__.MUTATE](target,receiver,prop,args,_SIGNAL){switch(prop){case'length 0':{Reflect.set(target,'length',0);mutateReplaceRelatedRecords(this,[],_SIGNAL);return true;}case'replace cell':{const[index,prior,value]=args;target[index]=value;mutateReplaceRelatedRecord(this,{value,prior,index},_SIGNAL);return true;}case'push':{const newValues=extractIdentifiersFromRecords(args);assertNoDuplicates(this,target,currentState=>currentState.push(...newValues),`Cannot push duplicates to a hasMany's state.`);{// dedupe\nconst seen=new Set(target);const unique=new Set();args.forEach(item=>{const identifier=(0,_ember_data_store_private__WEBPACK_IMPORTED_MODULE_4__.recordIdentifierFor)(item);if(!seen.has(identifier)){seen.add(identifier);unique.add(item);}});const newArgs=Array.from(unique);const result=Reflect.apply(target[prop],receiver,newArgs);if(newArgs.length){mutateAddToRelatedRecords(this,{value:extractIdentifiersFromRecords(newArgs)},_SIGNAL);}return result;}// else, no dedupe, error on duplicates\nconst result=Reflect.apply(target[prop],receiver,args);if(newValues.length){mutateAddToRelatedRecords(this,{value:newValues},_SIGNAL);}return result;}case'pop':{const result=Reflect.apply(target[prop],receiver,args);if(result){mutateRemoveFromRelatedRecords(this,{value:(0,_ember_data_store_private__WEBPACK_IMPORTED_MODULE_4__.recordIdentifierFor)(result)},_SIGNAL);}return result;}case'unshift':{const newValues=extractIdentifiersFromRecords(args);assertNoDuplicates(this,target,currentState=>currentState.unshift(...newValues),`Cannot unshift duplicates to a hasMany's state.`);{// dedupe\nconst seen=new Set(target);const unique=new Set();args.forEach(item=>{const identifier=(0,_ember_data_store_private__WEBPACK_IMPORTED_MODULE_4__.recordIdentifierFor)(item);if(!seen.has(identifier)){seen.add(identifier);unique.add(item);}});const newArgs=Array.from(unique);const result=Reflect.apply(target[prop],receiver,newArgs);if(newArgs.length){mutateAddToRelatedRecords(this,{value:extractIdentifiersFromRecords(newArgs),index:0},_SIGNAL);}return result;}// else, no dedupe, error on duplicates\nconst result=Reflect.apply(target[prop],receiver,args);if(newValues.length){mutateAddToRelatedRecords(this,{value:newValues,index:0},_SIGNAL);}return result;}case'shift':{const result=Reflect.apply(target[prop],receiver,args);if(result){mutateRemoveFromRelatedRecords(this,{value:(0,_ember_data_store_private__WEBPACK_IMPORTED_MODULE_4__.recordIdentifierFor)(result),index:0},_SIGNAL);}return result;}case'sort':{const result=Reflect.apply(target[prop],receiver,args);mutateSortRelatedRecords(this,result.map(_ember_data_store_private__WEBPACK_IMPORTED_MODULE_4__.recordIdentifierFor),_SIGNAL);return result;}case'splice':{const[start,deleteCount,...adds]=args;// detect a full replace\nif(start===0&&deleteCount===this[_ember_data_store_private__WEBPACK_IMPORTED_MODULE_4__.SOURCE].length){const newValues=extractIdentifiersFromRecords(adds);assertNoDuplicates(this,target,currentState=>currentState.splice(start,deleteCount,...newValues),`Cannot replace a hasMany's state with a new state that contains duplicates.`);{// dedupe\nconst current=new Set(adds);const unique=Array.from(current);const newArgs=[start,deleteCount].concat(unique);const result=Reflect.apply(target[prop],receiver,newArgs);mutateReplaceRelatedRecords(this,extractIdentifiersFromRecords(unique),_SIGNAL);return result;}// else, no dedupe, error on duplicates\nconst result=Reflect.apply(target[prop],receiver,args);mutateReplaceRelatedRecords(this,newValues,_SIGNAL);return result;}const newValues=extractIdentifiersFromRecords(adds);assertNoDuplicates(this,target,currentState=>currentState.splice(start,deleteCount,...newValues),`Cannot splice a hasMany's state with a new state that contains duplicates.`);{// dedupe\nconst currentState=target.slice();currentState.splice(start,deleteCount);const seen=new Set(currentState);const unique=[];adds.forEach(item=>{const identifier=(0,_ember_data_store_private__WEBPACK_IMPORTED_MODULE_4__.recordIdentifierFor)(item);if(!seen.has(identifier)){seen.add(identifier);unique.push(item);}});const newArgs=[start,deleteCount,...unique];const result=Reflect.apply(target[prop],receiver,newArgs);if(deleteCount>0){mutateRemoveFromRelatedRecords(this,{value:result.map(_ember_data_store_private__WEBPACK_IMPORTED_MODULE_4__.recordIdentifierFor),index:start},_SIGNAL);}if(unique.length>0){mutateAddToRelatedRecords(this,{value:extractIdentifiersFromRecords(unique),index:start},_SIGNAL);}return result;}// else, no dedupe, error on duplicates\nconst result=Reflect.apply(target[prop],receiver,args);if(deleteCount>0){mutateRemoveFromRelatedRecords(this,{value:result.map(_ember_data_store_private__WEBPACK_IMPORTED_MODULE_4__.recordIdentifierFor),index:start},_SIGNAL);}if(newValues.length>0){mutateAddToRelatedRecords(this,{value:newValues,index:start},_SIGNAL);}return result;}default:(test=>{{throw new Error(`unable to convert ${prop} into a transaction that updates the cache state for this record array`);}})();}}notify(){const signal=this[_ember_data_store_private__WEBPACK_IMPORTED_MODULE_4__.ARRAY_SIGNAL];signal.shouldReset=true;(0,_ember_data_store_private__WEBPACK_IMPORTED_MODULE_4__.notifyArray)(this);}/**\n    Reloads all of the records in the manyArray. If the manyArray\n    holds a relationship that was originally fetched using a links url\n    EmberData will revisit the original links url to repopulate the\n    relationship.\n     If the ManyArray holds the result of a `store.query()` reload will\n    re-run the original query.\n     Example\n     ```javascript\n    let user = store.peekRecord('user', '1')\n    await login(user);\n     let permissions = await user.permissions;\n    await permissions.reload();\n    ```\n     @method reload\n    @public\n  */reload(options){// TODO this is odd, we don't ask the store for anything else like this?\nreturn this._manager.reloadHasMany(this.key,options);}/**\n    Saves all of the records in the `ManyArray`.\n     Example\n     ```javascript\n    let inbox = await store.findRecord('inbox', '1');\n    let messages = await inbox.messages;\n    messages.forEach((message) => {\n      message.isRead = true;\n    });\n    messages.save();\n    ```\n     @method save\n    @public\n    @return {PromiseArray} promise\n  *//**\n    Create a child record within the owner\n     @method createRecord\n    @public\n    @param {Object} hash\n    @return {Model} record\n  */createRecord(hash){const{store}=this;(test=>{if(!test){throw new Error(`Expected modelName to be set`);}})(this.modelName);const record=store.createRecord(this.modelName,hash);this.push(record);return record;}destroy(){super.destroy(false);}}RelatedCollection.prototype.isAsync=false;RelatedCollection.prototype.isPolymorphic=false;RelatedCollection.prototype.identifier=null;RelatedCollection.prototype.cache=null;RelatedCollection.prototype._inverseIsAsync=false;RelatedCollection.prototype.key='';RelatedCollection.prototype.DEPRECATED_CLASS_NAME='ManyArray';function assertRecordPassedToHasMany(record){(test=>{if(!test){throw new Error(`All elements of a hasMany relationship must be instances of Model, you passed $${typeof record}`);}})(function(){try{(0,_ember_data_store_private__WEBPACK_IMPORTED_MODULE_4__.recordIdentifierFor)(record);return true;}catch{return false;}}());}function extractIdentifiersFromRecords(records){return records.map(extractIdentifierFromRecord$1);}function extractIdentifierFromRecord$1(recordOrPromiseRecord){assertRecordPassedToHasMany(recordOrPromiseRecord);return (0,_ember_data_store_private__WEBPACK_IMPORTED_MODULE_4__.recordIdentifierFor)(recordOrPromiseRecord);}function assertNoDuplicates(collection,target,callback,reason){const state=target.slice();callback(state);if(state.length!==new Set(state).size){const duplicates=state.filter((currentValue,currentIndex)=>state.indexOf(currentValue)!==currentIndex);{(0,_ember_debug__WEBPACK_IMPORTED_MODULE_0__.deprecate)(`${reason} This behavior is deprecated. Found duplicates for the following records within the new state provided to \\`<${collection.identifier.type}:${collection.identifier.id||collection.identifier.lid}>.${collection.key}\\`\\n\\t- ${Array.from(new Set(duplicates)).map(r=>(0,_ember_data_store_private__WEBPACK_IMPORTED_MODULE_4__.isStableIdentifier)(r)?r.lid:(0,_ember_data_store_private__WEBPACK_IMPORTED_MODULE_4__.recordIdentifierFor)(r).lid).sort((a,b)=>a.localeCompare(b)).join('\\n\\t- ')}`,false,{id:'ember-data:deprecate-many-array-duplicates',for:'ember-data',until:'6.0',since:{enabled:'5.3',available:'5.3'}});}}}function mutateAddToRelatedRecords(collection,operationInfo,_SIGNAL){mutate(collection,{op:'addToRelatedRecords',record:collection.identifier,field:collection.key,...operationInfo},_SIGNAL);}function mutateRemoveFromRelatedRecords(collection,operationInfo,_SIGNAL){mutate(collection,{op:'removeFromRelatedRecords',record:collection.identifier,field:collection.key,...operationInfo},_SIGNAL);}function mutateReplaceRelatedRecord(collection,operationInfo,_SIGNAL){mutate(collection,{op:'replaceRelatedRecord',record:collection.identifier,field:collection.key,...operationInfo},_SIGNAL);}function mutateReplaceRelatedRecords(collection,value,_SIGNAL){mutate(collection,{op:'replaceRelatedRecords',record:collection.identifier,field:collection.key,value},_SIGNAL);}function mutateSortRelatedRecords(collection,value,_SIGNAL){mutate(collection,{op:'sortRelatedRecords',record:collection.identifier,field:collection.key,value},_SIGNAL);}function mutate(collection,mutation,_SIGNAL){collection._manager.mutate(mutation);(0,_ember_data_tracking_private__WEBPACK_IMPORTED_MODULE_6__.addToTransaction)(_SIGNAL);}const PromiseObject=_ember_object_proxy__WEBPACK_IMPORTED_MODULE_14___default().extend((_ember_object_promise_proxy_mixin__WEBPACK_IMPORTED_MODULE_13___default()));var __defProp=Object.defineProperty;var __export=(target,all)=>{for(var name in all)__defProp(target,name,{get:all[name],enumerable:true});};// src/runtime.ts\nvar runtime_exports={};__export(runtime_exports,{c:()=>decorateClass,f:()=>decorateFieldV1,g:()=>decorateFieldV2,i:()=>initializeDeferredDecorator,m:()=>decorateMethodV1,n:()=>decorateMethodV2,p:()=>decoratePOJO});var deferred=/* @__PURE__ */new WeakMap();function deferDecorator(proto,prop,desc){let map=deferred.get(proto);if(!map){map=/* @__PURE__ */new Map();deferred.set(proto,map);}map.set(prop,desc);}function findDeferredDecorator(target,prop){let cursor=target.prototype;while(cursor){let desc=deferred.get(cursor)?.get(prop);if(desc){return desc;}cursor=cursor.prototype;}}function decorateFieldV1(target,prop,decorators,initializer){return decorateFieldV2(target.prototype,prop,decorators,initializer);}function decorateFieldV2(prototype,prop,decorators,initializer){let desc={configurable:true,enumerable:true,writable:true,initializer:null};if(initializer){desc.initializer=initializer;}for(let decorator of decorators){desc=decorator(prototype,prop,desc)||desc;}if(desc.initializer===void 0){Object.defineProperty(prototype,prop,desc);}else{deferDecorator(prototype,prop,desc);}}function decorateMethodV1({prototype},prop,decorators){return decorateMethodV2(prototype,prop,decorators);}function decorateMethodV2(prototype,prop,decorators){const origDesc=Object.getOwnPropertyDescriptor(prototype,prop);let desc={...origDesc};for(let decorator of decorators){desc=decorator(prototype,prop,desc)||desc;}if(desc.initializer!==void 0){desc.value=desc.initializer?desc.initializer.call(prototype):void 0;desc.initializer=void 0;}Object.defineProperty(prototype,prop,desc);}function initializeDeferredDecorator(target,prop){let desc=findDeferredDecorator(target.constructor,prop);if(desc){Object.defineProperty(target,prop,{enumerable:desc.enumerable,configurable:desc.configurable,writable:desc.writable,value:desc.initializer?desc.initializer.call(target):void 0});}}function decorateClass(target,decorators){return decorators.reduce((accum,decorator)=>decorator(accum)||accum,target);}function decoratePOJO(pojo,decorated){for(let[type,prop,decorators]of decorated){if(type===\"field\"){decoratePojoField(pojo,prop,decorators);}else{decorateMethodV2(pojo,prop,decorators);}}return pojo;}function decoratePojoField(pojo,prop,decorators){let desc={configurable:true,enumerable:true,writable:true,initializer:()=>Object.getOwnPropertyDescriptor(pojo,prop)?.value};for(let decorator of decorators){desc=decorator(pojo,prop,desc)||desc;}if(desc.initializer){desc.value=desc.initializer.call(pojo);delete desc.initializer;}Object.defineProperty(pojo,prop,desc);}const LegacyPromiseProxy=Symbol.for('LegacyPromiseProxy');// eslint-disable-next-line @typescript-eslint/no-unused-vars, @typescript-eslint/no-extraneous-class\nconst Extended=PromiseObject;/**\n @module @ember-data/model\n *//**\n  A PromiseBelongsTo is a PromiseObject that also proxies certain method calls\n  to the underlying belongsTo model.\n  Right now we proxy:\n    * `reload()`\n  @class PromiseBelongsTo\n  @extends PromiseObject\n  @private\n*/class PromiseBelongsTo extends Extended{constructor(...args){super(...args);_defineProperty(this,LegacyPromiseProxy,true);}get id(){const{key,legacySupport}=this._belongsToState;const ref=legacySupport.referenceFor('belongsTo',key);return ref.id();}// we don't proxy meta because we would need to proxy it to the relationship state container\n//  however, meta on relationships does not trigger change notifications.\n//  if you need relationship meta, you should do `record.belongsTo(relationshipName).meta()`\nget meta(){// eslint-disable-next-line no-constant-condition\n{(test=>{{throw new Error('You attempted to access meta on the promise for the async belongsTo relationship '+`${this._belongsToState.modelName}:${this._belongsToState.key}'.`+'\\nUse `record.belongsTo(relationshipName).meta()` instead.');}})();}return;}async reload(options){(test=>{if(!test){throw new Error('You are trying to reload an async belongsTo before it has been created');}})(this.content!==undefined);const{key,legacySupport}=this._belongsToState;await legacySupport.reloadBelongsTo(key,options);return this;}}/**\n @module @ember-data/model\n *//**\n  This class is returned as the result of accessing an async hasMany relationship\n  on an instance of a Model extending from `@ember-data/model`.\n\n  A PromiseManyArray is an iterable proxy that allows templates to consume related\n  ManyArrays and update once their contents are no longer pending.\n\n  In your JS code you should resolve the promise first.\n\n  ```js\n  const comments = await post.comments;\n  ```\n\n  @class PromiseManyArray\n  @public\n*/_PromiseBelongsTo=PromiseBelongsTo;decorateMethodV2(_PromiseBelongsTo.prototype,\"id\",[_ember_data_tracking__WEBPACK_IMPORTED_MODULE_5__.cached]);decorateMethodV2(_PromiseBelongsTo.prototype,\"meta\",[(0,_ember_object__WEBPACK_IMPORTED_MODULE_2__.computed)()]);class PromiseManyArray{constructor(promise,content){_defineProperty(this,LegacyPromiseProxy,true);this._update(promise,content);this.isDestroyed=false;}/**\n   * Retrieve the length of the content\n   * @property length\n   * @public\n   */get length(){// shouldn't be needed, but ends up being needed\n// for computed chains even in 4.x\n{// eslint-disable-next-line @typescript-eslint/no-unused-expressions\nthis['[]'];}return this.content?this.content.length:0;}/**\n   * Iterate the proxied content. Called by the glimmer iterator in #each\n   * We do not guarantee that forEach will always be available. This\n   * may eventually be made to use Symbol.Iterator once glimmer supports it.\n   *\n   * @method forEach\n   * @param cb\n   * @return\n   * @private\n   */forEach(cb){if(this.content&&this.length){this.content.forEach(cb);}}/**\n   * Reload the relationship\n   * @method reload\n   * @public\n   * @param options\n   * @return\n   */reload(options){(test=>{if(!test){throw new Error('You are trying to reload an async manyArray before it has been created');}})(this.content);void this.content.reload(options);return this;}//----  Properties/Methods from the PromiseProxyMixin that we will keep as our API\n/**\n   * Whether the loading promise is still pending\n   *\n   * @property {boolean} isPending\n   * @public\n   *//**\n   * Whether the loading promise rejected\n   *\n   * @property {boolean} isRejected\n   * @public\n   *//**\n   * Whether the loading promise succeeded\n   *\n   * @property {boolean} isFulfilled\n   * @public\n   *//**\n   * Whether the loading promise completed (resolved or rejected)\n   *\n   * @property {boolean} isSettled\n   * @public\n   *//**\n   * chain this promise\n   *\n   * @method then\n   * @public\n   * @param success\n   * @param fail\n   * @return Promise\n   */then(s,f){return this.promise.then(s,f);}/**\n   * catch errors thrown by this promise\n   * @method catch\n   * @public\n   * @param callback\n   * @return Promise\n   */catch(cb){return this.promise.catch(cb);}/**\n   * run cleanup after this promise completes\n   *\n   * @method finally\n   * @public\n   * @param callback\n   * @return Promise\n   */finally(cb){return this.promise.finally(cb);}//---- Methods on EmberObject that we should keep\ndestroy(){this.isDestroyed=true;this.content=null;this.promise=null;}//---- Methods/Properties on ManyArray that we own and proxy to\n/**\n   * Retrieve the links for this relationship\n   * @property links\n   * @public\n   */get links(){return this.content?this.content.links:undefined;}/**\n   * Retrieve the meta for this relationship\n   * @property meta\n   * @public\n   */get meta(){return this.content?this.content.meta:undefined;}//---- Our own stuff\n_update(promise,content){if(content!==undefined){this.content=content;}this.promise=tapPromise(this,promise);}static create({promise,content}){return new this(promise,content);}}_PromiseManyArray=PromiseManyArray;decorateMethodV2(_PromiseManyArray.prototype,\"length\",[_ember_data_tracking__WEBPACK_IMPORTED_MODULE_5__.compat]);decorateMethodV2(_PromiseManyArray.prototype,\"links\",[_ember_data_tracking__WEBPACK_IMPORTED_MODULE_5__.compat]);decorateMethodV2(_PromiseManyArray.prototype,\"meta\",[_ember_data_tracking__WEBPACK_IMPORTED_MODULE_5__.compat]);(0,_ember_data_tracking_private__WEBPACK_IMPORTED_MODULE_6__.defineSignal)(PromiseManyArray.prototype,'content',null);(0,_ember_data_tracking_private__WEBPACK_IMPORTED_MODULE_6__.defineSignal)(PromiseManyArray.prototype,'isPending',false);(0,_ember_data_tracking_private__WEBPACK_IMPORTED_MODULE_6__.defineSignal)(PromiseManyArray.prototype,'isRejected',false);(0,_ember_data_tracking_private__WEBPACK_IMPORTED_MODULE_6__.defineSignal)(PromiseManyArray.prototype,'isFulfilled',false);(0,_ember_data_tracking_private__WEBPACK_IMPORTED_MODULE_6__.defineSignal)(PromiseManyArray.prototype,'isSettled',false);// this will error if someone tries to call\n// A(identifierArray) since it is not configurable\n// which is preferrable to the `meta` override we used\n// before which required importing all of Ember\n{const desc={enumerable:true,configurable:false,get:function(){return this.content?.length&&this.content;}};(0,_ember_data_tracking__WEBPACK_IMPORTED_MODULE_5__.compat)(desc);// ember-source < 3.23 (e.g. 3.20 lts)\n// requires that the tag `'[]'` be notified\n// on the ArrayProxy in order for `{{#each}}`\n// to recompute. We entangle the '[]' tag from content\nObject.defineProperty(PromiseManyArray.prototype,'[]',desc);}function tapPromise(proxy,promise){proxy.isPending=true;proxy.isSettled=false;proxy.isFulfilled=false;proxy.isRejected=false;return Promise.resolve(promise).then(content=>{proxy.isPending=false;proxy.isFulfilled=true;proxy.isSettled=true;proxy.content=content;return content;},error=>{proxy.isPending=false;proxy.isFulfilled=false;proxy.isRejected=true;proxy.isSettled=true;throw error;});}/*\n  Assert that `addedRecord` has a valid type so it can be added to the\n  relationship of the `record`.\n\n  The assert basically checks if the `addedRecord` can be added to the\n  relationship (specified via `relationshipMeta`) of the `record`.\n\n  This utility should only be used internally, as both record parameters must\n  be stable record identifiers and the `relationshipMeta` needs to be the meta\n  information about the relationship, retrieved via\n  `record.relationshipFor(key)`.\n*/let assertPolymorphicType;{// eslint-disable-next-line @typescript-eslint/no-shadow\nassertPolymorphicType=function assertPolymorphicType(parentIdentifier,parentDefinition,addedIdentifier,store){if(parentDefinition.inverseIsImplicit){return;}if(parentDefinition.isPolymorphic){const meta=store.schema.fields(addedIdentifier)?.get(parentDefinition.inverseKey);(test=>{if(!test){throw new Error(`Expected the schema for the field ${parentDefinition.inverseKey} on ${addedIdentifier.type} to be for a legacy relationship`);}})(!meta||meta.kind==='belongsTo'||meta.kind==='hasMany');(test=>{if(!test){throw new Error(`The schema for the relationship '${parentDefinition.inverseKey}' on '${addedIdentifier.type}' type does not implement '${parentDefinition.type}' and thus cannot be assigned to the '${parentDefinition.key}' relationship in '${parentIdentifier.type}'. The definition should specify 'as: \"${parentDefinition.type}\"' in options.`);}})(meta?.options.as===parentDefinition.type);}};}function isResourceIdentiferWithRelatedLinks$1(value){return Boolean(value&&value.links&&value.links.related);}/**\n A `HasManyReference` is a low-level API that allows access\n and manipulation of a hasMany relationship.\n\n It is especially useful when you're dealing with `async` relationships\n from `@ember-data/model` as it allows synchronous access to\n the relationship data if loaded, as well as APIs for loading, reloading\n the data or accessing available information without triggering a load.\n\n It may also be useful when using `sync` relationships with `@ember-data/model`\n that need to be loaded/reloaded with more precise timing than marking the\n relationship as `async` and relying on autofetch would have allowed.\n\n However,keep in mind that marking a relationship as `async: false` will introduce\n bugs into your application if the data is not always guaranteed to be available\n by the time the relationship is accessed. Ergo, it is recommended when using this\n approach to utilize `links` for unloaded relationship state instead of identifiers.\n\n Reference APIs are entangled with the relationship's underlying state,\n thus any getters or cached properties that utilize these will properly\n invalidate if the relationship state changes.\n\n References are \"stable\", meaning that multiple calls to retrieve the reference\n  for a given relationship will always return the same HasManyReference.\n\n @class HasManyReference\n @public\n */class HasManyReference{constructor(store,graph,parentIdentifier,hasManyRelationship,key){/**\n   * The field name on the parent record for this has-many relationship.\n   *\n   * @property {String} key\n   * @public\n   *//**\n   * The type of resource this relationship will contain.\n   *\n   * @property {String} type\n   * @public\n   */// unsubscribe tokens given to us by the notification manager\n_defineProperty(this,\"___token\",void 0);_defineProperty(this,\"___identifier\",void 0);_defineProperty(this,\"___relatedTokenMap\",void 0);this.graph=graph;this.key=key;this.hasManyRelationship=hasManyRelationship;this.type=hasManyRelationship.definition.type;this.store=store;this.___identifier=parentIdentifier;this.___token=store.notifications.subscribe(parentIdentifier,(_,bucket,notifiedKey)=>{if(bucket==='relationships'&&notifiedKey===key){this._ref++;}});this.___relatedTokenMap=new Map();// TODO inverse\n}/**\n   * This method should never be called by user code.\n   *\n   * @internal\n   */destroy(){this.store.notifications.unsubscribe(this.___token);this.___relatedTokenMap.forEach(token=>{this.store.notifications.unsubscribe(token);});this.___relatedTokenMap.clear();}/**\n   * An array of identifiers for the records that this reference refers to.\n   *\n   * @property {StableRecordIdentifier[]} identifiers\n   * @public\n   */get identifiers(){// eslint-disable-next-line @typescript-eslint/no-unused-expressions\nthis._ref;// consume the tracked prop\nconst resource=this._resource();const map=this.___relatedTokenMap;this.___relatedTokenMap=new Map();if(resource&&resource.data){return resource.data.map(resourceIdentifier=>{const identifier=this.store.identifierCache.getOrCreateRecordIdentifier(resourceIdentifier);let token=map.get(identifier);if(token){map.delete(identifier);}else{token=this.store.notifications.subscribe(identifier,(_,bucket,notifiedKey)=>{if(bucket==='identity'||bucket==='attributes'&&notifiedKey==='id'){this._ref++;}});}this.___relatedTokenMap.set(identifier,token);return identifier;});}map.forEach(token=>{this.store.notifications.unsubscribe(token);});map.clear();return[];}_resource(){const cache=this.store.cache;return cache.getRelationship(this.___identifier,this.key);}/**\n   This returns a string that represents how the reference will be\n   looked up when it is loaded. If the relationship has a link it will\n   use the \"link\" otherwise it defaults to \"id\".\n    Example\n    ```app/models/post.js\n   import Model, { hasMany } from '@ember-data/model';\n    export default class PostModel extends Model {\n     @hasMany('comment', { async: true, inverse: null }) comments;\n   }\n   ```\n    ```javascript\n   let post = store.push({\n     data: {\n       type: 'post',\n       id: 1,\n       relationships: {\n         comments: {\n           data: [{ type: 'comment', id: 1 }]\n         }\n       }\n     }\n   });\n    let commentsRef = post.hasMany('comments');\n    // get the identifier of the reference\n   if (commentsRef.remoteType() === \"ids\") {\n     let ids = commentsRef.ids();\n   } else if (commentsRef.remoteType() === \"link\") {\n     let link = commentsRef.link();\n   }\n   ```\n    @method remoteType\n   @public\n   @return {String} The name of the remote type. This should either be `link` or `ids`\n   */remoteType(){const value=this._resource();if(value&&value.links&&value.links.related){return'link';}return'ids';}/**\n   `ids()` returns an array of the record IDs in this relationship.\n    Example\n    ```app/models/post.js\n   import Model, { hasMany } from '@ember-data/model';\n    export default class PostModel extends Model {\n     @hasMany('comment', { async: true, inverse: null }) comments;\n   }\n   ```\n    ```javascript\n   let post = store.push({\n     data: {\n       type: 'post',\n       id: 1,\n       relationships: {\n         comments: {\n           data: [{ type: 'comment', id: 1 }]\n         }\n       }\n     }\n   });\n    let commentsRef = post.hasMany('comments');\n    commentsRef.ids(); // ['1']\n   ```\n    @method ids\n    @public\n   @return {Array} The ids in this has-many relationship\n   */ids(){return this.identifiers.map(identifier=>identifier.id);}/**\n   The link Ember Data will use to fetch or reload this belongs-to\n   relationship. By default it uses only the \"related\" resource linkage.\n    Example\n    ```javascript\n   // models/blog.js\n   import Model, { belongsTo } from '@ember-data/model';\n   export default Model.extend({\n      user: belongsTo('user', { async: true, inverse: null })\n    });\n    let blog = store.push({\n      data: {\n        type: 'blog',\n        id: 1,\n        relationships: {\n          user: {\n            links: {\n              related: '/articles/1/author'\n            }\n          }\n        }\n      }\n    });\n   let userRef = blog.belongsTo('user');\n    // get the identifier of the reference\n   if (userRef.remoteType() === \"link\") {\n      let link = userRef.link();\n    }\n   ```\n    @method link\n   @public\n   @return {String} The link Ember Data will use to fetch or reload this belongs-to relationship.\n   */link(){const resource=this._resource();if(isResourceIdentiferWithRelatedLinks$1(resource)){if(resource.links){const related=resource.links.related;return!related||typeof related==='string'?related:related.href;}}return null;}/**\n   * any links that have been received for this relationship\n   *\n   * @method links\n   * @public\n   * @return\n   */links(){const resource=this._resource();return resource&&resource.links?resource.links:null;}/**\n   The meta data for the has-many relationship.\n    Example\n    ```javascript\n   // models/blog.js\n   import Model, { hasMany } from '@ember-data/model';\n   export default Model.extend({\n      users: hasMany('user', { async: true, inverse: null })\n    });\n    let blog = store.push({\n      data: {\n        type: 'blog',\n        id: 1,\n        relationships: {\n          users: {\n            links: {\n              related: {\n                href: '/articles/1/authors'\n              },\n            },\n            meta: {\n              lastUpdated: 1458014400000\n            }\n          }\n        }\n      }\n    });\n    let usersRef = blog.hasMany('user');\n    usersRef.meta() // { lastUpdated: 1458014400000 }\n   ```\n   @method meta\n  @public\n  @return {Object|null} The meta information for the belongs-to relationship.\n  */meta(){let meta=null;const resource=this._resource();if(resource&&resource.meta&&typeof resource.meta==='object'){meta=resource.meta;}return meta;}/**\n   `push` can be used to update the data in the relationship and EmberData\n   will treat the new data as the canonical value of this relationship on\n   the backend. An empty array will signify the canonical value should be\n   empty.\n    Example model\n    ```app/models/post.js\n   import Model, { hasMany } from '@ember-data/model';\n    export default class PostModel extends Model {\n     @hasMany('comment', { async: true, inverse: null }) comments;\n   }\n   ```\n    Setup some initial state, note we haven't loaded the comments yet:\n    ```js\n   const post = store.push({\n     data: {\n       type: 'post',\n       id: '1',\n       relationships: {\n         comments: {\n           data: [{ type: 'comment', id: '1' }]\n         }\n       }\n     }\n   });\n    const commentsRef = post.hasMany('comments');\n   commentsRef.ids(); // ['1']\n   ```\n    Update the state using `push`, note we can do this even without\n   having loaded these comments yet by providing resource identifiers.\n    Both full resources and resource identifiers are supported.\n    ```js\n   await commentsRef.push({\n    data: [\n     { type: 'comment', id: '2' },\n     { type: 'comment', id: '3' },\n    ]\n   });\n    commentsRef.ids(); // ['2', '3']\n   ```\n    For convenience, you can also pass in an array of resources or resource identifiers\n   without wrapping them in the `data` property:\n    ```js\n   await commentsRef.push([\n     { type: 'comment', id: '4' },\n     { type: 'comment', id: '5' },\n   ]);\n    commentsRef.ids(); // ['4', '5']\n   ```\n    When using the `data` property, you may also include other resource data via included,\n   as well as provide new links and meta to the relationship.\n    ```js\n   await commentsRef.push({\n     links: {\n       related: '/posts/1/comments'\n     },\n     meta: {\n       total: 2\n     },\n     data: [\n       { type: 'comment', id: '4' },\n       { type: 'comment', id: '5' },\n     ],\n     included: [\n       { type: 'other-thing', id: '1', attributes: { foo: 'bar' },\n     ]\n   });\n   ```\n    By default, the store will attempt to fetch any unloaded records before resolving\n   the returned promise with the ManyArray.\n    Alternatively, pass `true` as the second argument to avoid fetching unloaded records\n   and instead the promise will resolve with void without attempting to fetch. This is\n   particularly useful if you want to update the state of the relationship without\n   forcing the load of all of the associated records.\n    @method push\n   @public\n   @param {Array|Object} doc a JSONAPI document object describing the new value of this relationship.\n   @param {Boolean} [skipFetch] if `true`, do not attempt to fetch unloaded records\n   @return {Promise<ManyArray | void>}\n  */async push(doc,skipFetch){const{store}=this;const dataDoc=Array.isArray(doc)?{data:doc}:doc;const isResourceData=Array.isArray(dataDoc.data)&&dataDoc.data.length>0&&isMaybeResource(dataDoc.data[0]);// enforce that one of links, meta or data is present\n(test=>{if(!test){throw new Error(`You must provide at least one of 'links', 'meta' or 'data' when calling hasManyReference.push`);}})('links'in dataDoc||'meta'in dataDoc||'data'in dataDoc);const identifiers=!Array.isArray(dataDoc.data)?[]:isResourceData?store._push(dataDoc,true):dataDoc.data.map(i=>store.identifierCache.getOrCreateRecordIdentifier(i));const{identifier}=this.hasManyRelationship;{const relationshipMeta=this.hasManyRelationship.definition;identifiers.forEach(added=>{assertPolymorphicType(identifier,relationshipMeta,added,store);});}const newData={};// only set data if it was passed in\nif(Array.isArray(dataDoc.data)){newData.data=identifiers;}if('links'in dataDoc){newData.links=dataDoc.links;}if('meta'in dataDoc){newData.meta=dataDoc.meta;}store._join(()=>{this.graph.push({op:'updateRelationship',record:identifier,field:this.key,value:newData});});if(!skipFetch)return this.load();}_isLoaded(){const hasRelationshipDataProperty=this.hasManyRelationship.state.hasReceivedData;if(!hasRelationshipDataProperty){return false;}const relationship=this.graph.getData(this.hasManyRelationship.identifier,this.key);return relationship.data?.every(identifier=>{return this.store._instanceCache.recordIsLoaded(identifier,true)===true;});}/**\n   `value()` synchronously returns the current value of the has-many\n   relationship. Unlike `record.relationshipName`, calling\n   `value()` on a reference does not trigger a fetch if the async\n   relationship is not yet loaded. If the relationship is not loaded\n   it will always return `null`.\n    Example\n    ```app/models/post.js\n   import Model, { hasMany } from '@ember-data/model';\n    export default class PostModel extends Model {\n     @hasMany('comment', { async: true, inverse: null }) comments;\n   }\n   ```\n    ```javascript\n   let post = store.push({\n     data: {\n       type: 'post',\n       id: 1,\n       relationships: {\n         comments: {\n           data: [{ type: 'comment', id: 1 }]\n         }\n       }\n     }\n   });\n    let commentsRef = post.hasMany('comments');\n    post.comments.then(function(comments) {\n     commentsRef.value() === comments\n   })\n   ```\n    @method value\n    @public\n   @return {ManyArray}\n   */value(){const support=LEGACY_SUPPORT.get(this.___identifier);const loaded=this._isLoaded();if(!loaded){// subscribe to changes\n// for when we are not loaded yet\n// eslint-disable-next-line @typescript-eslint/no-unused-expressions\nthis._ref;return null;}return support.getManyArray(this.key);}/**\n   Loads the relationship if it is not already loaded.  If the\n   relationship is already loaded this method does not trigger a new\n   load. This causes a request to the specified\n   relationship link or reloads all items currently in the relationship.\n    Example\n    ```app/models/post.js\n   import Model, { hasMany } from '@ember-data/model';\n    export default class PostModel extends Model {\n     @hasMany('comment', { async: true, inverse: null }) comments;\n   }\n   ```\n    ```javascript\n   let post = store.push({\n     data: {\n       type: 'post',\n       id: 1,\n       relationships: {\n         comments: {\n           data: [{ type: 'comment', id: 1 }]\n         }\n       }\n     }\n   });\n    let commentsRef = post.hasMany('comments');\n    commentsRef.load().then(function(comments) {\n     //...\n   });\n   ```\n    You may also pass in an options object whose properties will be\n   fed forward. This enables you to pass `adapterOptions` into the\n   request given to the adapter via the reference.\n    Example\n    ```javascript\n   commentsRef.load({ adapterOptions: { isPrivate: true } })\n     .then(function(comments) {\n       //...\n     });\n   ```\n    ```app/adapters/comment.js\n   export default ApplicationAdapter.extend({\n     findMany(store, type, id, snapshots) {\n       // In the adapter you will have access to adapterOptions.\n       let adapterOptions = snapshots[0].adapterOptions;\n     }\n   });\n   ```\n    @method load\n   @public\n   @param {Object} options the options to pass in.\n   @return {Promise} a promise that resolves with the ManyArray in\n   this has-many relationship.\n   */async load(options){const support=LEGACY_SUPPORT.get(this.___identifier);const fetchSyncRel=!this.hasManyRelationship.definition.isAsync&&!areAllInverseRecordsLoaded(this.store,this._resource());return fetchSyncRel?support.reloadHasMany(this.key,options):// we cast to fix the return type since typescript and eslint don't understand async functions\n// properly\nsupport.getHasMany(this.key,options);}/**\n   Reloads this has-many relationship. This causes a request to the specified\n   relationship link or reloads all items currently in the relationship.\n    Example\n    ```app/models/post.js\n   import Model, { hasMany } from '@ember-data/model';\n    export default class PostModel extends Model {\n     @hasMany('comment', { async: true, inverse: null }) comments;\n   }\n   ```\n    ```javascript\n   let post = store.push({\n     data: {\n       type: 'post',\n       id: 1,\n       relationships: {\n         comments: {\n           data: [{ type: 'comment', id: 1 }]\n         }\n       }\n     }\n   });\n    let commentsRef = post.hasMany('comments');\n    commentsRef.reload().then(function(comments) {\n     //...\n   });\n   ```\n    You may also pass in an options object whose properties will be\n   fed forward. This enables you to pass `adapterOptions` into the\n   request given to the adapter via the reference. A full example\n   can be found in the `load` method.\n    Example\n    ```javascript\n   commentsRef.reload({ adapterOptions: { isPrivate: true } })\n   ```\n    @method reload\n    @public\n   @param {Object} options the options to pass in.\n   @return {Promise} a promise that resolves with the ManyArray in this has-many relationship.\n   */reload(options){const support=LEGACY_SUPPORT.get(this.___identifier);return support.reloadHasMany(this.key,options);}}_HasManyReference=HasManyReference;decorateMethodV2(_HasManyReference.prototype,\"identifiers\",[_ember_data_tracking__WEBPACK_IMPORTED_MODULE_5__.compat,_ember_data_tracking__WEBPACK_IMPORTED_MODULE_5__.cached]);(0,_ember_data_tracking_private__WEBPACK_IMPORTED_MODULE_6__.defineSignal)(HasManyReference.prototype,'_ref',0);function isMaybeResource(object){const keys=Object.keys(object).filter(k=>k!=='id'&&k!=='type'&&k!=='lid');return keys.length>0;}function isResourceIdentiferWithRelatedLinks(value){return Boolean(value&&value.links&&value.links.related);}/**\n A `BelongsToReference` is a low-level API that allows access\n and manipulation of a belongsTo relationship.\n\n It is especially useful when you're dealing with `async` relationships\n from `@ember-data/model` as it allows synchronous access to\n the relationship data if loaded, as well as APIs for loading, reloading\n the data or accessing available information without triggering a load.\n\n It may also be useful when using `sync` relationships with `@ember-data/model`\n that need to be loaded/reloaded with more precise timing than marking the\n relationship as `async` and relying on autofetch would have allowed.\n\n However,keep in mind that marking a relationship as `async: false` will introduce\n bugs into your application if the data is not always guaranteed to be available\n by the time the relationship is accessed. Ergo, it is recommended when using this\n approach to utilize `links` for unloaded relationship state instead of identifiers.\n\n Reference APIs are entangled with the relationship's underlying state,\n thus any getters or cached properties that utilize these will properly\n invalidate if the relationship state changes.\n\n References are \"stable\", meaning that multiple calls to retrieve the reference\n  for a given relationship will always return the same HasManyReference.\n\n @class BelongsToReference\n @public\n */class BelongsToReference{/**\n   * The field name on the parent record for this has-many relationship.\n   *\n   * @property {String} key\n   * @public\n   *//**\n   * The type of resource this relationship will contain.\n   *\n   * @property {String} type\n   * @public\n   */// unsubscribe tokens given to us by the notification manager\nconstructor(store,graph,parentIdentifier,belongsToRelationship,key){this.graph=graph;this.key=key;this.belongsToRelationship=belongsToRelationship;this.type=belongsToRelationship.definition.type;this.store=store;this.___identifier=parentIdentifier;this.___relatedToken=null;this.___token=store.notifications.subscribe(parentIdentifier,(_,bucket,notifiedKey)=>{if(bucket==='relationships'&&notifiedKey===key){this._ref++;}});// TODO inverse\n}destroy(){// TODO @feature we need the notification manager often enough\n// we should potentially just expose it fully public\nthis.store.notifications.unsubscribe(this.___token);this.___token=null;if(this.___relatedToken){this.store.notifications.unsubscribe(this.___relatedToken);this.___relatedToken=null;}}/**\n   * The identifier of the record that this reference refers to.\n   * `null` if no related record is known.\n   *\n   * @property {StableRecordIdentifier | null} identifier\n   * @public\n   */get identifier(){if(this.___relatedToken){this.store.notifications.unsubscribe(this.___relatedToken);this.___relatedToken=null;}const resource=this._resource();if(resource&&resource.data){const identifier=this.store.identifierCache.getOrCreateRecordIdentifier(resource.data);this.___relatedToken=this.store.notifications.subscribe(identifier,(_,bucket,notifiedKey)=>{if(bucket==='identity'||bucket==='attributes'&&notifiedKey==='id'){this._ref++;}});return identifier;}return null;}/**\n   The `id` of the record that this reference refers to. Together, the\n   `type()` and `id()` methods form a composite key for the identity\n   map. This can be used to access the id of an async relationship\n   without triggering a fetch that would normally happen if you\n   attempted to use `record.relationship.id`.\n    Example\n    ```javascript\n   // models/blog.js\n   import Model, { belongsTo } from '@ember-data/model';\n    export default class BlogModel extends Model {\n    @belongsTo('user', { async: true, inverse: null }) user;\n   }\n    let blog = store.push({\n      data: {\n        type: 'blog',\n        id: 1,\n        relationships: {\n          user: {\n            data: { type: 'user', id: 1 }\n          }\n        }\n      }\n    });\n   let userRef = blog.belongsTo('user');\n    // get the identifier of the reference\n   if (userRef.remoteType() === \"id\") {\n      let id = userRef.id();\n    }\n   ```\n    @method id\n   @public\n   @return {String} The id of the record in this belongsTo relationship.\n   */id(){return this.identifier?.id||null;}/**\n   The link Ember Data will use to fetch or reload this belongs-to\n   relationship. By default it uses only the \"related\" resource linkage.\n    Example\n    ```javascript\n   // models/blog.js\n   import Model, { belongsTo } from '@ember-data/model';\n   export default Model.extend({\n      user: belongsTo('user', { async: true, inverse: null })\n    });\n    let blog = store.push({\n      data: {\n        type: 'blog',\n        id: 1,\n        relationships: {\n          user: {\n            links: {\n              related: '/articles/1/author'\n            }\n          }\n        }\n      }\n    });\n   let userRef = blog.belongsTo('user');\n    // get the identifier of the reference\n   if (userRef.remoteType() === \"link\") {\n      let link = userRef.link();\n    }\n   ```\n    @method link\n   @public\n   @return {String} The link Ember Data will use to fetch or reload this belongs-to relationship.\n   */link(){const resource=this._resource();if(isResourceIdentiferWithRelatedLinks(resource)){if(resource.links){const related=resource.links.related;return!related||typeof related==='string'?related:related.href;}}return null;}/**\n   * any links that have been received for this relationship\n   *\n   * @method links\n   * @public\n   * @return\n   */links(){const resource=this._resource();return resource&&resource.links?resource.links:null;}/**\n   The meta data for the belongs-to relationship.\n    Example\n    ```javascript\n   // models/blog.js\n   import Model, { belongsTo } from '@ember-data/model';\n   export default Model.extend({\n      user: belongsTo('user', { async: true, inverse: null })\n    });\n    let blog = store.push({\n      data: {\n        type: 'blog',\n        id: 1,\n        relationships: {\n          user: {\n            links: {\n              related: {\n                href: '/articles/1/author'\n              },\n            },\n            meta: {\n              lastUpdated: 1458014400000\n            }\n          }\n        }\n      }\n    });\n    let userRef = blog.belongsTo('user');\n    userRef.meta() // { lastUpdated: 1458014400000 }\n   ```\n    @method meta\n    @public\n   @return {Object} The meta information for the belongs-to relationship.\n   */meta(){let meta=null;const resource=this._resource();if(resource&&resource.meta&&typeof resource.meta==='object'){meta=resource.meta;}return meta;}_resource(){// eslint-disable-next-line @typescript-eslint/no-unused-expressions\nthis._ref;// subscribe\nconst cache=this.store.cache;return cache.getRelationship(this.___identifier,this.key);}/**\n   This returns a string that represents how the reference will be\n   looked up when it is loaded. If the relationship has a link it will\n   use the \"link\" otherwise it defaults to \"id\".\n    Example\n    ```app/models/post.js\n   import Model, { hasMany } from '@ember-data/model';\n    export default class PostModel extends Model {\n     @hasMany('comment', { async: true, inverse: null }) comments;\n   }\n   ```\n    ```javascript\n   let post = store.push({\n     data: {\n       type: 'post',\n       id: 1,\n       relationships: {\n         comments: {\n           data: [{ type: 'comment', id: 1 }]\n         }\n       }\n     }\n   });\n    let commentsRef = post.hasMany('comments');\n    // get the identifier of the reference\n   if (commentsRef.remoteType() === \"ids\") {\n     let ids = commentsRef.ids();\n   } else if (commentsRef.remoteType() === \"link\") {\n     let link = commentsRef.link();\n   }\n   ```\n    @method remoteType\n   @public\n   @return {String} The name of the remote type. This should either be `link` or `id`\n   */remoteType(){const value=this._resource();if(isResourceIdentiferWithRelatedLinks(value)){return'link';}return'id';}/**\n   `push` can be used to update the data in the relationship and EmberData\n   will treat the new data as the canonical value of this relationship on\n   the backend. A value of `null` (e.g. `{ data: null }`) can be passed to\n   clear the relationship.\n    Example model\n    ```app/models/blog.js\n   import Model, { belongsTo } from '@ember-data/model';\n    export default class BlogModel extends Model {\n      @belongsTo('user', { async: true, inverse: null }) user;\n    }\n   ```\n    Setup some initial state, note we haven't loaded the user yet:\n    ```js\n   const blog = store.push({\n      data: {\n        type: 'blog',\n        id: '1',\n        relationships: {\n          user: {\n            data: { type: 'user', id: '1' }\n          }\n        }\n      }\n   });\n    const userRef = blog.belongsTo('user');\n   userRef.id(); // '1'\n   ```\n    Update the state using `push`, note we can do this even without\n   having loaded the user yet by providing a resource-identifier.\n    Both full a resource and a resource-identifier are supported.\n    ```js\n   await userRef.push({\n      data: {\n        type: 'user',\n        id: '2',\n      }\n    });\n     userRef.id(); // '2'\n   ```\n    You may also pass in links and meta fore the relationship, and sideload\n   additional resources that might be required.\n    ```js\n    await userRef.push({\n        data: {\n          type: 'user',\n          id: '2',\n        },\n        links: {\n          related: '/articles/1/author'\n        },\n        meta: {\n          lastUpdated: Date.now()\n        },\n        included: [\n          {\n            type: 'user-preview',\n            id: '2',\n            attributes: {\n              username: '@runspired'\n            }\n          }\n        ]\n      });\n    ```\n    By default, the store will attempt to fetch the record if it is not loaded or its\n   resource data is not included in the call to `push` before resolving the returned\n   promise with the new state..\n    Alternatively, pass `true` as the second argument to avoid fetching unloaded records\n   and instead the promise will resolve with void without attempting to fetch. This is\n   particularly useful if you want to update the state of the relationship without\n   forcing the load of all of the associated record.\n    @method push\n   @public\n   @param {Object} doc a JSONAPI document object describing the new value of this relationship.\n   @param {Boolean} [skipFetch] if `true`, do not attempt to fetch unloaded records\n   @return {Promise<OpaqueRecordInstance | null | void>}\n  */async push(doc,skipFetch){const{store}=this;const isResourceData=doc.data&&isMaybeResource(doc.data);const added=isResourceData?store._push(doc,true):doc.data?store.identifierCache.getOrCreateRecordIdentifier(doc.data):null;const{identifier}=this.belongsToRelationship;{if(added){assertPolymorphicType(identifier,this.belongsToRelationship.definition,added,store);}}const newData={};// only set data if it was passed in\nif(doc.data||doc.data===null){newData.data=added;}if('links'in doc){newData.links=doc.links;}if('meta'in doc){newData.meta=doc.meta;}store._join(()=>{this.graph.push({op:'updateRelationship',record:identifier,field:this.key,value:newData});});if(!skipFetch)return this.load();}/**\n   `value()` synchronously returns the current value of the belongs-to\n   relationship. Unlike `record.relationshipName`, calling\n   `value()` on a reference does not trigger a fetch if the async\n   relationship is not yet loaded. If the relationship is not loaded\n   it will always return `null`.\n    Example\n    ```javascript\n   // models/blog.js\n   import Model, { belongsTo } from '@ember-data/model';\n    export default class BlogModel extends Model {\n     @belongsTo('user', { async: true, inverse: null }) user;\n   }\n    let blog = store.push({\n      data: {\n        type: 'blog',\n        id: 1,\n        relationships: {\n          user: {\n            data: { type: 'user', id: 1 }\n          }\n        }\n      }\n    });\n   let userRef = blog.belongsTo('user');\n    userRef.value(); // null\n    // provide data for reference\n   userRef.push({\n      data: {\n        type: 'user',\n        id: 1,\n        attributes: {\n          username: \"@user\"\n        }\n      }\n    }).then(function(user) {\n      userRef.value(); // user\n    });\n   ```\n    @method value\n    @public\n   @return {Model} the record in this relationship\n   */value(){const resource=this._resource();return resource&&resource.data?this.store.peekRecord(resource.data):null;}/**\n   Loads a record in a belongs-to relationship if it is not already\n   loaded. If the relationship is already loaded this method does not\n   trigger a new load.\n    Example\n    ```javascript\n   // models/blog.js\n   import Model, { belongsTo } from '@ember-data/model';\n    export default class BlogModel extends Model {\n     @belongsTo('user', { async: true, inverse: null }) user;\n   }\n    let blog = store.push({\n      data: {\n        type: 'blog',\n        id: 1,\n        relationships: {\n          user: {\n            data: { type: 'user', id: 1 }\n          }\n        }\n      }\n    });\n   let userRef = blog.belongsTo('user');\n    userRef.value(); // null\n    userRef.load().then(function(user) {\n      userRef.value() === user\n    });\n   ```\n    You may also pass in an options object whose properties will be\n   fed forward. This enables you to pass `adapterOptions` into the\n   request given to the adapter via the reference.\n    Example\n    ```javascript\n   userRef.load({ adapterOptions: { isPrivate: true } }).then(function(user) {\n     userRef.value() === user;\n   });\n   ```\n   ```app/adapters/user.js\n   import Adapter from '@ember-data/adapter';\n    export default class UserAdapter extends Adapter {\n     findRecord(store, type, id, snapshot) {\n       // In the adapter you will have access to adapterOptions.\n       let adapterOptions = snapshot.adapterOptions;\n     }\n   });\n   ```\n    @method load\n    @public\n   @param {Object} options the options to pass in.\n   @return {Promise} a promise that resolves with the record in this belongs-to relationship.\n   */async load(options){const support=LEGACY_SUPPORT.get(this.___identifier);const fetchSyncRel=!this.belongsToRelationship.definition.isAsync&&!areAllInverseRecordsLoaded(this.store,this._resource());return fetchSyncRel?support.reloadBelongsTo(this.key,options).then(()=>this.value()):// we cast to fix the return type since typescript and eslint don't understand async functions\n// properly\nsupport.getBelongsTo(this.key,options);}/**\n   Triggers a reload of the value in this relationship. If the\n   remoteType is `\"link\"` Ember Data will use the relationship link to\n   reload the relationship. Otherwise it will reload the record by its\n   id.\n    Example\n    ```javascript\n   // models/blog.js\n   import Model, { belongsTo } from '@ember-data/model';\n    export default class BlogModel extends Model {\n     @belongsTo('user', { async: true, inverse: null }) user;\n   }\n    let blog = store.push({\n      data: {\n        type: 'blog',\n        id: 1,\n        relationships: {\n          user: {\n            data: { type: 'user', id: 1 }\n          }\n        }\n      }\n    });\n   let userRef = blog.belongsTo('user');\n    userRef.reload().then(function(user) {\n      userRef.value() === user\n    });\n   ```\n    You may also pass in an options object whose properties will be\n   fed forward. This enables you to pass `adapterOptions` into the\n   request given to the adapter via the reference. A full example\n   can be found in the `load` method.\n    Example\n    ```javascript\n   userRef.reload({ adapterOptions: { isPrivate: true } })\n   ```\n    @method reload\n    @public\n   @param {Object} options the options to pass in.\n   @return {Promise} a promise that resolves with the record in this belongs-to relationship after the reload has completed.\n   */reload(options){const support=LEGACY_SUPPORT.get(this.___identifier);return support.reloadBelongsTo(this.key,options).then(()=>this.value());}}_BelongsToReference=BelongsToReference;decorateMethodV2(_BelongsToReference.prototype,\"identifier\",[_ember_data_tracking__WEBPACK_IMPORTED_MODULE_5__.compat,_ember_data_tracking__WEBPACK_IMPORTED_MODULE_5__.cached]);(0,_ember_data_tracking_private__WEBPACK_IMPORTED_MODULE_6__.defineSignal)(BelongsToReference.prototype,'_ref',0);const LEGACY_SUPPORT=(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_12__.getOrSetGlobal)('LEGACY_SUPPORT',new Map());function lookupLegacySupport(record){const identifier=(0,_ember_data_store_private__WEBPACK_IMPORTED_MODULE_4__.recordIdentifierFor)(record);(test=>{if(!test){throw new Error(`Expected a record`);}})(identifier);let support=LEGACY_SUPPORT.get(identifier);if(!support){(test=>{if(!test){throw new Error(`Memory Leak Detected`);}})(!record.isDestroyed&&!record.isDestroying);support=new LegacySupport(record);LEGACY_SUPPORT.set(identifier,support);LEGACY_SUPPORT.set(record,support);}return support;}class LegacySupport{constructor(record){this.record=record;this.store=(0,_ember_data_store_private__WEBPACK_IMPORTED_MODULE_4__.storeFor)(record);this.identifier=(0,_ember_data_store_private__WEBPACK_IMPORTED_MODULE_4__.recordIdentifierFor)(record);this.cache=(0,_ember_data_store_private__WEBPACK_IMPORTED_MODULE_4__.peekCache)(record);{const graphFor=(0,_embroider_macros_src_addon_es_compat2__WEBPACK_IMPORTED_MODULE_16__[\"default\"])(__webpack_require__(/*! @ember-data/graph/-private */ \"./node_modules/@ember-data/graph/dist/-private.js\")).graphFor;this.graph=graphFor(this.store);}this._manyArrayCache=Object.create(null);this._relationshipPromisesCache=Object.create(null);this._relationshipProxyCache=Object.create(null);this._pending=Object.create(null);this.references=Object.create(null);}_syncArray(array){// It’s possible the parent side of the relationship may have been destroyed by this point\nif(this.isDestroyed||this.isDestroying){return;}const currentState=array[_ember_data_store_private__WEBPACK_IMPORTED_MODULE_4__.SOURCE];const identifier=this.identifier;const[identifiers,jsonApi]=this._getCurrentState(identifier,array.key);if(jsonApi.meta){array.meta=jsonApi.meta;}if(jsonApi.links){array.links=jsonApi.links;}currentState.length=0;(0,_ember_data_store_private__WEBPACK_IMPORTED_MODULE_4__.fastPush)(currentState,identifiers);}mutate(mutation){this.cache.mutate(mutation);}_findBelongsTo(key,resource,relationship,options){// TODO @runspired follow up if parent isNew then we should not be attempting load here\n// TODO @runspired follow up on whether this should be in the relationship requests cache\nreturn this._findBelongsToByJsonApiResource(resource,this.identifier,relationship,options).then(identifier=>handleCompletedRelationshipRequest(this,key,relationship,identifier),e=>handleCompletedRelationshipRequest(this,key,relationship,null,e));}reloadBelongsTo(key,options){const loadingPromise=this._relationshipPromisesCache[key];if(loadingPromise){return loadingPromise;}const relationship=this.graph.get(this.identifier,key);(test=>{if(!test){throw new Error(`Expected ${key} to be a belongs-to relationship`);}})(isBelongsTo(relationship));const resource=this.cache.getRelationship(this.identifier,key);relationship.state.hasFailedLoadAttempt=false;relationship.state.shouldForceReload=true;const promise=this._findBelongsTo(key,resource,relationship,options);if(this._relationshipProxyCache[key]){// @ts-expect-error\nreturn this._updatePromiseProxyFor('belongsTo',key,{promise});}return promise;}getBelongsTo(key,options){const{identifier,cache}=this;const resource=cache.getRelationship(this.identifier,key);const relatedIdentifier=resource&&resource.data?resource.data:null;(test=>{if(!test){throw new Error(`Expected a stable identifier`);}})(!relatedIdentifier||(0,_ember_data_store_private__WEBPACK_IMPORTED_MODULE_4__.isStableIdentifier)(relatedIdentifier));const store=this.store;const relationship=this.graph.get(this.identifier,key);(test=>{if(!test){throw new Error(`Expected ${key} to be a belongs-to relationship`);}})(isBelongsTo(relationship));const isAsync=relationship.definition.isAsync;const _belongsToState={key,store,legacySupport:this,modelName:relationship.definition.type};if(isAsync){if(relationship.state.hasFailedLoadAttempt){return this._relationshipProxyCache[key];}const promise=this._findBelongsTo(key,resource,relationship,options);const isLoaded=relatedIdentifier&&store._instanceCache.recordIsLoaded(relatedIdentifier);return this._updatePromiseProxyFor('belongsTo',key,{promise,content:isLoaded?store._instanceCache.getRecord(relatedIdentifier):null,_belongsToState});}else{if(relatedIdentifier===null){return null;}else{const toReturn=store._instanceCache.getRecord(relatedIdentifier);(test=>{if(!test){throw new Error(`You looked up the '${key}' relationship on a '${identifier.type}' with id ${identifier.id||'null'} but some of the associated records were not loaded. Either make sure they are all loaded together with the parent record, or specify that the relationship is async (\\`belongsTo(<type>, { async: true, inverse: <inverse> })\\`)`);}})(toReturn===null||store._instanceCache.recordIsLoaded(relatedIdentifier,true));return toReturn;}}}setDirtyBelongsTo(key,value){return this.cache.mutate({op:'replaceRelatedRecord',record:this.identifier,field:key,value:extractIdentifierFromRecord(value)},// @ts-expect-error\ntrue);}_getCurrentState(identifier,field){const jsonApi=this.cache.getRelationship(identifier,field);const cache=this.store._instanceCache;const identifiers=[];if(jsonApi.data){for(let i=0;i<jsonApi.data.length;i++){const relatedIdentifier=jsonApi.data[i];(test=>{if(!test){throw new Error(`Expected a stable identifier`);}})((0,_ember_data_store_private__WEBPACK_IMPORTED_MODULE_4__.isStableIdentifier)(relatedIdentifier));if(cache.recordIsLoaded(relatedIdentifier,true)){identifiers.push(relatedIdentifier);}}}return[identifiers,jsonApi];}getManyArray(key,definition){{let manyArray=this._manyArrayCache[key];if(!definition){definition=this.graph.get(this.identifier,key).definition;}if(!manyArray){const[identifiers,doc]=this._getCurrentState(this.identifier,key);manyArray=new RelatedCollection({store:this.store,type:definition.type,identifier:this.identifier,cache:this.cache,identifiers,key,meta:doc.meta||null,links:doc.links||null,isPolymorphic:definition.isPolymorphic,isAsync:definition.isAsync,_inverseIsAsync:definition.inverseIsAsync,manager:this,isLoaded:!definition.isAsync,allowMutation:true});this._manyArrayCache[key]=manyArray;}return manyArray;}(test=>{{throw new Error('hasMany only works with the @ember-data/json-api package');}})();}fetchAsyncHasMany(key,relationship,manyArray,options){{let loadingPromise=this._relationshipPromisesCache[key];if(loadingPromise){return loadingPromise;}const jsonApi=this.cache.getRelationship(this.identifier,key);const promise=this._findHasManyByJsonApiResource(jsonApi,this.identifier,relationship,options);if(!promise){manyArray.isLoaded=true;return Promise.resolve(manyArray);}loadingPromise=promise.then(()=>handleCompletedRelationshipRequest(this,key,relationship,manyArray),e=>handleCompletedRelationshipRequest(this,key,relationship,manyArray,e));this._relationshipPromisesCache[key]=loadingPromise;return loadingPromise;}(test=>{{throw new Error('hasMany only works with the @ember-data/json-api package');}})();}reloadHasMany(key,options){{const loadingPromise=this._relationshipPromisesCache[key];if(loadingPromise){return loadingPromise;}const relationship=this.graph.get(this.identifier,key);const{definition,state}=relationship;state.hasFailedLoadAttempt=false;state.shouldForceReload=true;const manyArray=this.getManyArray(key,definition);const promise=this.fetchAsyncHasMany(key,relationship,manyArray,options);if(this._relationshipProxyCache[key]){return this._updatePromiseProxyFor('hasMany',key,{promise});}return promise;}(test=>{{throw new Error(`hasMany only works with the @ember-data/json-api package`);}})();}getHasMany(key,options){{const relationship=this.graph.get(this.identifier,key);const{definition,state}=relationship;const manyArray=this.getManyArray(key,definition);if(definition.isAsync){if(state.hasFailedLoadAttempt){return this._relationshipProxyCache[key];}const promise=this.fetchAsyncHasMany(key,relationship,manyArray,options);return this._updatePromiseProxyFor('hasMany',key,{promise,content:manyArray});}else{(test=>{if(!test){throw new Error(`You looked up the '${key}' relationship on a '${this.identifier.type}' with id ${this.identifier.id||'null'} but some of the associated records were not loaded. Either make sure they are all loaded together with the parent record, or specify that the relationship is async ('hasMany(<type>, { async: true, inverse: <inverse> })')`);}})(!anyUnloaded(this.store,relationship));return manyArray;}}(test=>{{throw new Error(`hasMany only works with the @ember-data/json-api package`);}})();}_updatePromiseProxyFor(kind,key,args){let promiseProxy=this._relationshipProxyCache[key];if(kind==='hasMany'){const{promise,content}=args;if(promiseProxy){(test=>{if(!test){throw new Error(`Expected a PromiseManyArray`);}})('_update'in promiseProxy);promiseProxy._update(promise,content);}else{promiseProxy=this._relationshipProxyCache[key]=new PromiseManyArray(promise,content);}return promiseProxy;}if(promiseProxy){const{promise,content}=args;(test=>{if(!test){throw new Error(`Expected a PromiseBelongsTo`);}})('_belongsToState'in promiseProxy);if(content!==undefined){promiseProxy.set('content',content);}void promiseProxy.set('promise',promise);}else{promiseProxy=PromiseBelongsTo.create(args);this._relationshipProxyCache[key]=promiseProxy;}return promiseProxy;}referenceFor(kind,name){let reference=this.references[name];if(!reference){const{graph,identifier}=this;const relationship=graph.get(identifier,name);{if(kind){const modelName=identifier.type;const actualRelationshipKind=relationship.definition.kind;(test=>{if(!test){throw new Error(`You tried to get the '${name}' relationship on a '${modelName}' via record.${kind}('${name}'), but the relationship is of kind '${actualRelationshipKind}'. Use record.${actualRelationshipKind}('${name}') instead.`);}})(actualRelationshipKind===kind);}}const relationshipKind=relationship.definition.kind;if(relationshipKind==='belongsTo'){reference=new BelongsToReference(this.store,graph,identifier,relationship,name);}else if(relationshipKind==='hasMany'){reference=new HasManyReference(this.store,graph,identifier,relationship,name);}this.references[name]=reference;}return reference;}_findHasManyByJsonApiResource(resource,parentIdentifier,relationship,options={}){{if(!resource){return;}const{definition,state}=relationship;(0,_ember_data_legacy_compat_private__WEBPACK_IMPORTED_MODULE_11__.upgradeStore)(this.store);const adapter=this.store.adapterFor?.(definition.type);const{isStale,hasDematerializedInverse,hasReceivedData,isEmpty,shouldForceReload}=state;const allInverseRecordsAreLoaded=areAllInverseRecordsLoaded(this.store,resource);const identifiers=resource.data;const shouldFindViaLink=resource.links&&resource.links.related&&(typeof adapter?.findHasMany==='function'||typeof identifiers==='undefined')&&(shouldForceReload||hasDematerializedInverse||isStale||!allInverseRecordsAreLoaded&&!isEmpty);const field=this.store.schema.fields({type:definition.inverseType}).get(definition.key);(test=>{if(!test){throw new Error(`Expected a hasMany field definition for ${definition.inverseType}.${definition.key}`);}})(field&&field.kind==='hasMany');const request={useLink:shouldFindViaLink,field,links:resource.links,meta:resource.meta,options,record:parentIdentifier};// fetch via link\nif(shouldFindViaLink){(test=>{if(!test){throw new Error(`Expected collection to be an array`);}})(!identifiers||Array.isArray(identifiers));(test=>{if(!test){throw new Error(`Expected stable identifiers`);}})(!identifiers||identifiers.every(_ember_data_store_private__WEBPACK_IMPORTED_MODULE_4__.isStableIdentifier));return this.store.request({op:'findHasMany',records:identifiers||[],data:request,cacheOptions:{[Symbol.for('wd:skip-cache')]:true}});}const preferLocalCache=hasReceivedData&&!isEmpty;const hasLocalPartialData=hasDematerializedInverse||isEmpty&&Array.isArray(identifiers)&&identifiers.length>0;const attemptLocalCache=!shouldForceReload&&!isStale&&(preferLocalCache||hasLocalPartialData);if(attemptLocalCache&&allInverseRecordsAreLoaded){return;}const hasData=hasReceivedData&&!isEmpty;if(attemptLocalCache||hasData||hasLocalPartialData){(test=>{if(!test){throw new Error(`Expected collection to be an array`);}})(Array.isArray(identifiers));(test=>{if(!test){throw new Error(`Expected stable identifiers`);}})(identifiers.every(_ember_data_store_private__WEBPACK_IMPORTED_MODULE_4__.isStableIdentifier));options.reload=options.reload||!attemptLocalCache||undefined;return this.store.request({op:'findHasMany',records:identifiers,data:request,cacheOptions:{[Symbol.for('wd:skip-cache')]:true}});}// we were explicitly told we have no data and no links.\n//   TODO if the relationshipIsStale, should we hit the adapter anyway?\nreturn;}(test=>{{throw new Error(`hasMany only works with the @ember-data/json-api package`);}})();}_findBelongsToByJsonApiResource(resource,parentIdentifier,relationship,options={}){if(!resource){return Promise.resolve(null);}const key=relationship.definition.key;// interleaved promises mean that we MUST cache this here\n// in order to prevent infinite re-render if the request\n// fails.\nif(this._pending[key]){return this._pending[key];}const identifier=resource.data?resource.data:null;(test=>{if(!test){throw new Error(`Expected a stable identifier`);}})(!identifier||(0,_ember_data_store_private__WEBPACK_IMPORTED_MODULE_4__.isStableIdentifier)(identifier));const{isStale,hasDematerializedInverse,hasReceivedData,isEmpty,shouldForceReload}=relationship.state;const allInverseRecordsAreLoaded=areAllInverseRecordsLoaded(this.store,resource);const shouldFindViaLink=resource.links?.related&&(shouldForceReload||hasDematerializedInverse||isStale||!allInverseRecordsAreLoaded&&!isEmpty);const field=this.store.schema.fields(this.identifier).get(relationship.definition.key);(test=>{if(!test){throw new Error(`Attempted to access a belongsTo relationship but no definition exists for it`);}})(field&&field.kind==='belongsTo');const request={useLink:shouldFindViaLink,field,links:resource.links,meta:resource.meta,options,record:parentIdentifier};// fetch via link\nif(shouldFindViaLink){const future=this.store.request({op:'findBelongsTo',records:identifier?[identifier]:[],data:request,cacheOptions:{[Symbol.for('wd:skip-cache')]:true}});this._pending[key]=future.then(doc=>doc.content).finally(()=>{this._pending[key]=undefined;});return this._pending[key];}const preferLocalCache=hasReceivedData&&allInverseRecordsAreLoaded&&!isEmpty;const hasLocalPartialData=hasDematerializedInverse||isEmpty&&resource.data;// null is explicit empty, undefined is \"we don't know anything\"\nconst localDataIsEmpty=!identifier;const attemptLocalCache=!shouldForceReload&&!isStale&&(preferLocalCache||hasLocalPartialData);// we dont need to fetch and are empty\nif(attemptLocalCache&&localDataIsEmpty){return Promise.resolve(null);}// we dont need to fetch because we are local state\nconst resourceIsLocal=identifier?.id===null;if(attemptLocalCache&&allInverseRecordsAreLoaded||resourceIsLocal){return Promise.resolve(identifier);}// we may need to fetch\nif(identifier){(test=>{if(!test){throw new Error(`Cannot fetch belongs-to relationship with no information`);}})(identifier);options.reload=options.reload||!attemptLocalCache||undefined;this._pending[key]=this.store.request({op:'findBelongsTo',records:[identifier],data:request,cacheOptions:{[Symbol.for('wd:skip-cache')]:true}}).then(doc=>doc.content).finally(()=>{this._pending[key]=undefined;});return this._pending[key];}// we were explicitly told we have no data and no links.\n//   TODO if the relationshipIsStale, should we hit the adapter anyway?\nreturn Promise.resolve(null);}destroy(){this.isDestroying=true;let cache=this._manyArrayCache;this._manyArrayCache=Object.create(null);Object.keys(cache).forEach(key=>{cache[key].destroy();});cache=this._relationshipProxyCache;this._relationshipProxyCache=Object.create(null);Object.keys(cache).forEach(key=>{const proxy=cache[key];if(proxy.destroy){proxy.destroy();}});cache=this.references;this.references=Object.create(null);Object.keys(cache).forEach(key=>{cache[key].destroy();});this.isDestroyed=true;}}function handleCompletedRelationshipRequest(recordExt,key,relationship,value,error){delete recordExt._relationshipPromisesCache[key];relationship.state.shouldForceReload=false;const isHasMany=relationship.definition.kind==='hasMany';if(isHasMany){// we don't notify the record property here to avoid refetch\n// only the many array\nvalue.notify();}if(error){relationship.state.hasFailedLoadAttempt=true;const proxy=recordExt._relationshipProxyCache[key];// belongsTo relationships are sometimes unloaded\n// when a load fails, in this case we need\n// to make sure that we aren't proxying\n// to destroyed content\n// for the sync belongsTo reload case there will be no proxy\n// for the async reload case there will be no proxy if the ui\n// has never been accessed\nif(proxy&&!isHasMany){// @ts-expect-error unsure why this is not resolving the boolean but async belongsTo is weird\nif(proxy.content&&proxy.content.isDestroying){proxy.set('content',null);}recordExt.store.notifications._flush();}throw error;}if(isHasMany){value.isLoaded=true;}else{recordExt.store.notifications._flush();}relationship.state.hasFailedLoadAttempt=false;// only set to not stale if no error is thrown\nrelationship.state.isStale=false;return isHasMany||!value?value:recordExt.store.peekRecord(value);}function extractIdentifierFromRecord(record){if(!record){return null;}return (0,_ember_data_store_private__WEBPACK_IMPORTED_MODULE_4__.recordIdentifierFor)(record);}function anyUnloaded(store,relationship){const graph=store._graph;(test=>{if(!test){throw new Error(`Expected a Graph instance to be available`);}})(graph);const relationshipData=graph.getData(relationship.identifier,relationship.definition.key);const state=relationshipData.data;const cache=store._instanceCache;const unloaded=state?.find(s=>{const isLoaded=cache.recordIsLoaded(s,true);return!isLoaded;});return unloaded||false;}function areAllInverseRecordsLoaded(store,resource){const instanceCache=store._instanceCache;const identifiers=resource.data;if(Array.isArray(identifiers)){(test=>{if(!test){throw new Error(`Expected stable identifiers`);}})(identifiers.every(_ember_data_store_private__WEBPACK_IMPORTED_MODULE_4__.isStableIdentifier));// treat as collection\n// check for unloaded records\nreturn identifiers.every(identifier=>instanceCache.recordIsLoaded(identifier));}// treat as single resource\nif(!identifiers)return true;(test=>{if(!test){throw new Error(`Expected stable identifiers`);}})((0,_ember_data_store_private__WEBPACK_IMPORTED_MODULE_4__.isStableIdentifier)(identifiers));return instanceCache.recordIsLoaded(identifiers);}function isBelongsTo(relationship){return relationship.definition.kind==='belongsTo';}// we force the type here to our own construct because mixin and extend patterns\n// lose generic signatures. We also do this because we need to Omit `clear` from\n// the type of ArrayProxy as we override it's signature.\nconst ArrayProxyWithCustomOverrides=(_ember_array_proxy__WEBPACK_IMPORTED_MODULE_9___default());/**\n  Holds validation errors for a given record, organized by attribute names.\n\n  This class is not directly instantiable.\n\n  Every `Model` has an `errors` property that is an instance of\n  `Errors`. This can be used to display validation error\n  messages returned from the server when a `record.save()` rejects.\n\n  For Example, if you had a `User` model that looked like this:\n\n  ```app/models/user.js\n  import Model, { attr } from '@ember-data/model';\n\n  export default class UserModel extends Model {\n    @attr('string') username;\n    @attr('string') email;\n  }\n  ```\n  And you attempted to save a record that did not validate on the backend:\n\n  ```javascript\n  let user = store.createRecord('user', {\n    username: 'tomster',\n    email: 'invalidEmail'\n  });\n  user.save();\n  ```\n\n  Your backend would be expected to return an error response that described\n  the problem, so that error messages can be generated on the app.\n\n  API responses will be translated into instances of `Errors` differently,\n  depending on the specific combination of adapter and serializer used. You\n  may want to check the documentation or the source code of the libraries\n  that you are using, to know how they expect errors to be communicated.\n\n  Errors can be displayed to the user by accessing their property name\n  to get an array of all the error objects for that property. Each\n  error object is a JavaScript object with two keys:\n\n  - `message` A string containing the error message from the backend\n  - `attribute` The name of the property associated with this error message\n\n  ```handlebars\n  <label>Username: <Input @value={{@model.username}} /> </label>\n  {{#each @model.errors.username as |error|}}\n    <div class=\"error\">\n      {{error.message}}\n    </div>\n  {{/each}}\n\n  <label>Email: <Input @value={{@model.email}} /> </label>\n  {{#each @model.errors.email as |error|}}\n    <div class=\"error\">\n      {{error.message}}\n    </div>\n  {{/each}}\n  ```\n\n  You can also access the special `messages` property on the error\n  object to get an array of all the error strings.\n\n  ```handlebars\n  {{#each @model.errors.messages as |message|}}\n    <div class=\"error\">\n      {{message}}\n    </div>\n  {{/each}}\n  ```\n\n  @class Errors\n  @public\n  @extends Ember.ArrayProxy\n */var _messages2=/*#__PURE__*/new WeakMap();var _isEmpty=/*#__PURE__*/new WeakMap();class Errors extends ArrayProxyWithCustomOverrides{constructor(...args){super(...args);_classPrivateFieldInitSpec(this,_messages2,(initializeDeferredDecorator(this,\"messages\"),void 0));_classPrivateFieldInitSpec(this,_isEmpty,(initializeDeferredDecorator(this,\"isEmpty\"),void 0));}/**\n    @property errorsByAttributeName\n    @type {MapWithDefault}\n    @private\n  */get errorsByAttributeName(){return new Map();}/**\n    Returns errors for a given attribute\n     ```javascript\n    let user = store.createRecord('user', {\n      username: 'tomster',\n      email: 'invalidEmail'\n    });\n    user.save().catch(function(){\n      user.errors.errorsFor('email'); // returns:\n      // [{attribute: \"email\", message: \"Doesn't look like a valid email.\"}]\n    });\n    ```\n     @method errorsFor\n    @public\n    @param {String} attribute\n    @return {Array}\n  */errorsFor(attribute){const map=this.errorsByAttributeName;let errors=map.get(attribute);if(errors===undefined){errors=(0,_ember_array__WEBPACK_IMPORTED_MODULE_8__.A)();map.set(attribute,errors);}// Errors may be a native array with extensions turned on. Since we access\n// the array via a method, and not a computed or using `Ember.get`, it does\n// not entangle properly with autotracking, so we entangle manually by\n// getting the `[]` property.\n(0,_ember_object__WEBPACK_IMPORTED_MODULE_2__.get)(errors,'[]');return errors;}/**\n    An array containing all of the error messages for this\n    record. This is useful for displaying all errors to the user.\n     ```handlebars\n    {{#each @model.errors.messages as |message|}}\n      <div class=\"error\">\n        {{message}}\n      </div>\n    {{/each}}\n    ```\n     @property messages\n    @public\n    @type {Array}\n  *//**\n    @property content\n    @type {Array}\n    @private\n  */get content(){return (0,_ember_array__WEBPACK_IMPORTED_MODULE_8__.A)();}/**\n    @method unknownProperty\n    @private\n  */unknownProperty(attribute){const errors=this.errorsFor(attribute);if(errors.length===0){return undefined;}return errors;}/**\n    Total number of errors.\n     @property length\n    @type {Number}\n    @public\n    @readOnly\n  *//**\n    `true` if we have no errors.\n     @property isEmpty\n    @type {Boolean}\n    @public\n    @readOnly\n  *//**\n   Manually adds errors to the record. This will trigger the `becameInvalid` event/ lifecycle method on\n    the record and transition the record into an `invalid` state.\n    Example\n   ```javascript\n    let errors = user.errors;\n     // add multiple errors\n    errors.add('password', [\n      'Must be at least 12 characters',\n      'Must contain at least one symbol',\n      'Cannot contain your name'\n    ]);\n     errors.errorsFor('password');\n    // =>\n    // [\n    //   { attribute: 'password', message: 'Must be at least 12 characters' },\n    //   { attribute: 'password', message: 'Must contain at least one symbol' },\n    //   { attribute: 'password', message: 'Cannot contain your name' },\n    // ]\n     // add a single error\n    errors.add('username', 'This field is required');\n     errors.errorsFor('username');\n    // =>\n    // [\n    //   { attribute: 'username', message: 'This field is required' },\n    // ]\n   ```\n    @method add\n    @public\n    @param {string} attribute - the property name of an attribute or relationship\n    @param {string[]|string} messages - an error message or array of error messages for the attribute\n   */add(attribute,messages){const errors=this._findOrCreateMessages(attribute,messages);this.addObjects(errors);this.errorsFor(attribute).addObjects(errors);this.__record.currentState.notify('isValid');this.notifyPropertyChange(attribute);}/**\n    @method _findOrCreateMessages\n    @private\n  */_findOrCreateMessages(attribute,messages){const errors=this.errorsFor(attribute);const messagesArray=Array.isArray(messages)?messages:[messages];const _messages=new Array(messagesArray.length);for(let i=0;i<messagesArray.length;i++){const message=messagesArray[i];const err=errors.findBy('message',message);if(err){_messages[i]=err;}else{_messages[i]={attribute:attribute,message};}}return _messages;}/**\n   Manually removes all errors for a given member from the record.\n     This will transition the record into a `valid` state, and\n    triggers the `becameValid` event and lifecycle method.\n    Example:\n    ```javascript\n    let errors = user.errors;\n    errors.add('phone', ['error-1', 'error-2']);\n     errors.errorsFor('phone');\n    // =>\n    // [\n    //   { attribute: 'phone', message: 'error-1' },\n    //   { attribute: 'phone', message: 'error-2' },\n    // ]\n     errors.remove('phone');\n     errors.errorsFor('phone');\n    // => undefined\n   ```\n   @method remove\n    @public\n   @param {string} member - the property name of an attribute or relationship\n   */remove(attribute){if(this.isEmpty){return;}const content=this.rejectBy('attribute',attribute);this.content.setObjects(content);// Although errorsByAttributeName.delete is technically enough to sync errors state, we also\n// must mutate the array as well for autotracking\nconst errors=this.errorsFor(attribute);for(let i=0;i<errors.length;i++){if(errors[i].attribute===attribute){// .replace from Ember.NativeArray is necessary. JS splice will not work.\nerrors.replace(i,1);}}this.errorsByAttributeName.delete(attribute);this.__record.currentState.notify('isValid');this.notifyPropertyChange(attribute);this.notifyPropertyChange('length');}/**\n   Manually clears all errors for the record.\n     This will transition the record into a `valid` state, and\n     will trigger the `becameValid` event and lifecycle method.\n   Example:\n    ```javascript\n   let errors = user.errors;\n   errors.add('username', ['error-a']);\n   errors.add('phone', ['error-1', 'error-2']);\n    errors.errorsFor('username');\n   // =>\n   // [\n   //   { attribute: 'username', message: 'error-a' },\n   // ]\n    errors.errorsFor('phone');\n   // =>\n   // [\n   //   { attribute: 'phone', message: 'error-1' },\n   //   { attribute: 'phone', message: 'error-2' },\n   // ]\n    errors.clear();\n    errors.errorsFor('username');\n   // => undefined\n    errors.errorsFor('phone');\n   // => undefined\n    errors.messages\n   // => []\n   ```\n   @method clear\n   @public\n   */clear(){if(this.isEmpty){return;}const errorsByAttributeName=this.errorsByAttributeName;const attributes=[];errorsByAttributeName.forEach(function(_,attribute){attributes.push(attribute);});errorsByAttributeName.clear();attributes.forEach(attribute=>{this.notifyPropertyChange(attribute);});this.__record.currentState.notify('isValid');super.clear();}/**\n    Checks if there are error messages for the given attribute.\n     ```app/controllers/user/edit.js\n    export default class UserEditController extends Controller {\n      @action\n      save(user) {\n        if (user.errors.has('email')) {\n          return alert('Please update your email before attempting to save.');\n        }\n        user.save();\n      }\n    }\n    ```\n     @method has\n    @public\n    @param {String} attribute\n    @return {Boolean} true if there some errors on given attribute\n  */has(attribute){return this.errorsFor(attribute).length>0;}}_Errors=Errors;decorateMethodV2(_Errors.prototype,\"errorsByAttributeName\",[(0,_ember_object__WEBPACK_IMPORTED_MODULE_2__.computed)()]);decorateFieldV2(_Errors.prototype,\"messages\",[(0,_ember_object_computed__WEBPACK_IMPORTED_MODULE_10__.mapBy)('content','message')]);decorateMethodV2(_Errors.prototype,\"content\",[(0,_ember_object__WEBPACK_IMPORTED_MODULE_2__.computed)()]);decorateFieldV2(_Errors.prototype,\"isEmpty\",[(0,_ember_object_computed__WEBPACK_IMPORTED_MODULE_10__.not)('length')]);function rollbackAttributes(){const{currentState}=this;const{isNew}=currentState;this[_warp_drive_core_types_symbols__WEBPACK_IMPORTED_MODULE_7__.RecordStore]._join(()=>{(0,_ember_data_store_private__WEBPACK_IMPORTED_MODULE_4__.peekCache)(this).rollbackAttrs((0,_ember_data_store__WEBPACK_IMPORTED_MODULE_3__.recordIdentifierFor)(this));this.errors.clear();currentState.cleanErrorRequests();if(isNew){this.unloadRecord();}});}function unloadRecord(){if(this.currentState.isNew&&(this.isDestroyed||this.isDestroying)){return;}this[_warp_drive_core_types_symbols__WEBPACK_IMPORTED_MODULE_7__.RecordStore].unloadRecord(this);}function belongsTo(prop){return lookupLegacySupport(this).referenceFor('belongsTo',prop);}function hasMany(prop){return lookupLegacySupport(this).referenceFor('hasMany',prop);}function reload(options={}){options.isReloading=true;options.reload=true;const identifier=(0,_ember_data_store__WEBPACK_IMPORTED_MODULE_3__.recordIdentifierFor)(this);(test=>{if(!test){throw new Error(`You cannot reload a record without an ID`);}})(identifier.id);this.isReloading=true;const promise=this[_warp_drive_core_types_symbols__WEBPACK_IMPORTED_MODULE_7__.RecordStore].request({op:'findRecord',data:{options,record:identifier},cacheOptions:{[Symbol.for('wd:skip-cache')]:true}}).then(()=>this).finally(()=>{this.isReloading=false;});return promise;}function changedAttributes(){return (0,_ember_data_store_private__WEBPACK_IMPORTED_MODULE_4__.peekCache)(this).changedAttrs((0,_ember_data_store__WEBPACK_IMPORTED_MODULE_3__.recordIdentifierFor)(this));}function serialize(options){(0,_ember_data_legacy_compat_private__WEBPACK_IMPORTED_MODULE_11__.upgradeStore)(this[_warp_drive_core_types_symbols__WEBPACK_IMPORTED_MODULE_7__.RecordStore]);return this[_warp_drive_core_types_symbols__WEBPACK_IMPORTED_MODULE_7__.RecordStore].serializeRecord(this,options);}function deleteRecord(){// ensure we've populated currentState prior to deleting a new record\nif(this.currentState){this[_warp_drive_core_types_symbols__WEBPACK_IMPORTED_MODULE_7__.RecordStore].deleteRecord(this);}}function save(options){let promise;if(this.currentState.isNew&&this.currentState.isDeleted){promise=Promise.resolve(this);}else{this.errors.clear();promise=this[_warp_drive_core_types_symbols__WEBPACK_IMPORTED_MODULE_7__.RecordStore].saveRecord(this,options);}return promise;}function destroyRecord(options){const{isNew}=this.currentState;this.deleteRecord();if(isNew){return Promise.resolve(this);}return this.save(options).then(_=>{this.unloadRecord();return this;});}function createSnapshot(){const store=this[_warp_drive_core_types_symbols__WEBPACK_IMPORTED_MODULE_7__.RecordStore];(0,_ember_data_legacy_compat_private__WEBPACK_IMPORTED_MODULE_11__.upgradeStore)(store);if(!store._fetchManager){const FetchManager=(0,_embroider_macros_src_addon_es_compat2__WEBPACK_IMPORTED_MODULE_16__[\"default\"])(__webpack_require__(/*! @ember-data/legacy-compat/-private */ \"./node_modules/@ember-data/legacy-compat/dist/-private.js\")).FetchManager;store._fetchManager=new FetchManager(store);}// @ts-expect-error Typescript isn't able to curry narrowed args that are divorced from each other.\nreturn store._fetchManager.createSnapshot((0,_ember_data_store__WEBPACK_IMPORTED_MODULE_3__.recordIdentifierFor)(this));}function notifyChanges(identifier,value,key,record,store){if(value==='attributes'){if(key){notifyAttribute(store,identifier,key,record);}else{record.eachAttribute(name=>{notifyAttribute(store,identifier,name,record);});}}else if(value==='relationships'){if(key){const meta=record.constructor.relationshipsByName.get(key);(test=>{if(!test){throw new Error(`Expected to find a relationship for ${key} on ${identifier.type}`);}})(meta);notifyRelationship(identifier,key,record,meta);}else{record.eachRelationship((name,meta)=>{notifyRelationship(identifier,name,record,meta);});}}else if(value==='identity'){record.notifyPropertyChange('id');}}function notifyRelationship(identifier,key,record,meta){if(meta.kind==='belongsTo'){record.notifyPropertyChange(key);}else if(meta.kind==='hasMany'){const support=LEGACY_SUPPORT.get(identifier);const manyArray=support&&support._manyArrayCache[key];const hasPromise=support&&support._relationshipPromisesCache[key];if(manyArray&&hasPromise){// do nothing, we will notify the ManyArray directly\n// once the fetch has completed.\nreturn;}if(manyArray){manyArray.notify();//We need to notifyPropertyChange in the adding case because we need to make sure\n//we fetch the newly added record in case it is unloaded\n//TODO(Igor): Consider whether we could do this only if the record state is unloaded\n(test=>{if(!test){throw new Error(`Expected options to exist on relationship meta`);}})(meta.options);(test=>{if(!test){throw new Error(`Expected async to exist on relationship meta options`);}})('async'in meta.options);if(meta.options.async){record.notifyPropertyChange(key);}}}}function notifyAttribute(store,identifier,key,record){const currentValue=(0,_ember_object_internals__WEBPACK_IMPORTED_MODULE_15__.cacheFor)(record,key);const cache=store.cache;if(currentValue!==cache.getAttr(identifier,key)){record.notifyPropertyChange(key);}}const SOURCE_POINTER_REGEXP=/^\\/?data\\/(attributes|relationships)\\/(.*)/;const SOURCE_POINTER_PRIMARY_REGEXP=/^\\/?data/;const PRIMARY_ATTRIBUTE_KEY='base';function isInvalidError(error){return!!error&&error instanceof Error&&'isAdapterError'in error&&error.isAdapterError===true&&'code'in error&&error.code==='InvalidError';}/**\n * A decorator that caches a getter while\n * providing the ability to bust that cache\n * when we so choose in a way that notifies\n * tracking systems.\n *\n * @internal\n */function tagged(_target,key,desc){// eslint-disable-next-line @typescript-eslint/unbound-method\nconst getter=desc.get;// eslint-disable-next-line @typescript-eslint/unbound-method\nconst setter=desc.set;desc.get=function(){const signal=(0,_ember_data_tracking_private__WEBPACK_IMPORTED_MODULE_6__.getSignal)(this,key,true);(0,_ember_data_tracking_private__WEBPACK_IMPORTED_MODULE_6__.subscribe)(signal);if(signal.shouldReset){signal.shouldReset=false;signal.lastValue=getter.call(this);}return signal.lastValue;};desc.set=function(v){(0,_ember_data_tracking_private__WEBPACK_IMPORTED_MODULE_6__.getSignal)(this,key,true);// ensure signal is setup in case we want to use it.\n// probably notify here but not yet.\nsetter.call(this,v);};(0,_ember_data_tracking__WEBPACK_IMPORTED_MODULE_5__.compat)(desc);return desc;}function notifySignal(obj,key){const signal=(0,_ember_data_tracking_private__WEBPACK_IMPORTED_MODULE_6__.peekSignal)(obj,key);if(signal){signal.shouldReset=true;(0,_ember_data_tracking_private__WEBPACK_IMPORTED_MODULE_6__.addToTransaction)(signal);}}/**\nHistorically EmberData managed a state machine\nfor each record, the localState for which\nwas reflected onto Model.\n\nThis implements the flags and stateName for backwards compat\nwith the state tree that used to be possible (listed below).\n\nstateName and dirtyType are candidates for deprecation.\n\nroot\n  empty\n    deleted    // hidden from stateName\n    preloaded  // hidden from stateName\n\n  loading\n     empty     // hidden from stateName\n     preloaded // hidden from stateName\n\n  loaded\n    saved\n    updated\n      uncommitted\n      invalid\n      inFlight\n    created\n      uncommitted\n      invalid\n      inFlight\n\n  deleted\n    saved\n      new      // hidden from stateName\n    uncommitted\n    invalid\n    inFlight\n\n  @internal\n*/class RecordState{constructor(record){const store=(0,_ember_data_store__WEBPACK_IMPORTED_MODULE_3__.storeFor)(record);const identity=(0,_ember_data_store_private__WEBPACK_IMPORTED_MODULE_4__.recordIdentifierFor)(record);this.identifier=identity;this.record=record;this.cache=store.cache;this.pendingCount=0;this.fulfilledCount=0;this.rejectedCount=0;this._errorRequests=[];this._lastError=null;const requests=store.getRequestStateService();const notifications=store.notifications;const handleRequest=req=>{if(req.type==='mutation'){switch(req.state){case'pending':this.isSaving=true;break;case'rejected':this.isSaving=false;this._lastError=req;if(!(req.response&&isInvalidError(req.response.data))){this._errorRequests.push(req);}notifyErrorsStateChanged(this);break;case'fulfilled':this._errorRequests=[];this._lastError=null;this.isSaving=false;this.notify('isDirty');notifyErrorsStateChanged(this);break;}}else{switch(req.state){case'pending':this.pendingCount++;this.notify('isLoading');break;case'rejected':this.pendingCount--;this._lastError=req;if(!(req.response&&isInvalidError(req.response.data))){this._errorRequests.push(req);}this.notify('isLoading');notifyErrorsStateChanged(this);break;case'fulfilled':this.pendingCount--;this.fulfilledCount++;this.notify('isLoading');this.notify('isDirty');notifyErrorsStateChanged(this);this._errorRequests=[];this._lastError=null;break;}}};requests.subscribeForRecord(identity,handleRequest);// we instantiate lazily\n// so we grab anything we don't have yet\nconst lastRequest=requests.getLastRequestForRecord(identity);if(lastRequest){handleRequest(lastRequest);}this.handler=notifications.subscribe(identity,(identifier,type,key)=>{switch(type){case'state':this.notify('isSaved');this.notify('isNew');this.notify('isDeleted');this.notify('isDirty');break;case'attributes':this.notify('isEmpty');this.notify('isDirty');break;case'errors':this.updateInvalidErrors(this.record.errors);this.notify('isValid');break;}});}destroy(){(0,_ember_data_store__WEBPACK_IMPORTED_MODULE_3__.storeFor)(this.record).notifications.unsubscribe(this.handler);}notify(key){notifySignal(this,key);}updateInvalidErrors(errors){(test=>{if(!test){throw new Error(`Expected the Cache instance for ${this.identifier.lid}  to implement getErrors(identifier)`);}})(typeof this.cache.getErrors==='function');const jsonApiErrors=this.cache.getErrors(this.identifier);errors.clear();for(let i=0;i<jsonApiErrors.length;i++){const error=jsonApiErrors[i];if(error.source&&error.source.pointer){const keyMatch=error.source.pointer.match(SOURCE_POINTER_REGEXP);let key;if(keyMatch){key=keyMatch[2];}else if(error.source.pointer.search(SOURCE_POINTER_PRIMARY_REGEXP)!==-1){key=PRIMARY_ATTRIBUTE_KEY;}if(key){const errMsg=error.detail||error.title;(test=>{if(!test){throw new Error(`Expected field error to have a detail or title to use as the message`);}})(errMsg);errors.add(key,errMsg);}}}}cleanErrorRequests(){this.notify('isValid');this.notify('isError');this.notify('adapterError');this._errorRequests=[];this._lastError=null;}get isLoading(){return!this.isLoaded&&this.pendingCount>0&&this.fulfilledCount===0;}get isLoaded(){if(this.isNew){return true;}return this.fulfilledCount>0||!this.isEmpty;}get isSaved(){const rd=this.cache;if(this.isDeleted){(test=>{if(!test){throw new Error(`Expected Cache to implement isDeletionCommitted()`);}})(typeof rd.isDeletionCommitted==='function');return rd.isDeletionCommitted(this.identifier);}if(this.isNew||this.isEmpty||!this.isValid||this.isDirty||this.isLoading){return false;}return true;}get isEmpty(){const rd=this.cache;// TODO this is not actually an RFC'd concept. Determine the\n// correct heuristic to replace this with.\n(test=>{if(!test){throw new Error(`Expected Cache to implement isEmpty()`);}})(typeof rd.isEmpty==='function');return!this.isNew&&rd.isEmpty(this.identifier);}get isNew(){const rd=this.cache;(test=>{if(!test){throw new Error(`Expected Cache to implement isNew()`);}})(typeof rd.isNew==='function');return rd.isNew(this.identifier);}get isDeleted(){const rd=this.cache;(test=>{if(!test){throw new Error(`Expected Cache to implement isDeleted()`);}})(typeof rd.isDeleted==='function');return rd.isDeleted(this.identifier);}get isValid(){return this.record.errors.length===0;}get isDirty(){const rd=this.cache;if(this.isEmpty||rd.isDeletionCommitted(this.identifier)||this.isDeleted&&this.isNew){return false;}return this.isDeleted||this.isNew||rd.hasChangedAttrs(this.identifier);}get isError(){const errorReq=this._errorRequests[this._errorRequests.length-1];if(!errorReq){return false;}else{return true;}}get adapterError(){const request=this._lastError;if(!request){return null;}return request.state==='rejected'&&request.response.data;}get isPreloaded(){return!this.isEmpty&&this.isLoading;}get stateName(){// we might be empty while loading so check this first\nif(this.isLoading){return'root.loading';// got nothing yet or were unloaded\n}else if(this.isEmpty){return'root.empty';// deleted substates\n}else if(this.isDeleted){if(this.isSaving){return'root.deleted.inFlight';}else if(this.isSaved){// TODO ensure isSaved isn't true from previous requests\nreturn'root.deleted.saved';}else if(!this.isValid){return'root.deleted.invalid';}else{return'root.deleted.uncommitted';}// loaded.created substates\n}else if(this.isNew){if(this.isSaving){return'root.loaded.created.inFlight';}else if(!this.isValid){return'root.loaded.created.invalid';}return'root.loaded.created.uncommitted';// loaded.updated substates\n}else if(this.isSaving){return'root.loaded.updated.inFlight';}else if(!this.isValid){return'root.loaded.updated.invalid';}else if(this.isDirty){return'root.loaded.updated.uncommitted';// if nothing remains, we are loaded saved!\n}else{return'root.loaded.saved';}}get dirtyType(){// we might be empty while loading so check this first\nif(this.isLoading||this.isEmpty){return'';// deleted substates\n}else if(this.isDirty&&this.isDeleted){return'deleted';// loaded.created substates\n}else if(this.isNew){return'created';// loaded.updated substates\n}else if(this.isSaving||!this.isValid||this.isDirty){return'updated';// if nothing remains, we are loaded saved!\n}else{return'';}}}_RecordState=RecordState;decorateMethodV2(_RecordState.prototype,\"isLoading\",[tagged]);decorateMethodV2(_RecordState.prototype,\"isLoaded\",[tagged]);decorateMethodV2(_RecordState.prototype,\"isSaved\",[tagged]);decorateMethodV2(_RecordState.prototype,\"isEmpty\",[tagged]);decorateMethodV2(_RecordState.prototype,\"isNew\",[tagged]);decorateMethodV2(_RecordState.prototype,\"isDeleted\",[tagged]);decorateMethodV2(_RecordState.prototype,\"isValid\",[tagged]);decorateMethodV2(_RecordState.prototype,\"isDirty\",[tagged]);decorateMethodV2(_RecordState.prototype,\"isError\",[tagged]);decorateMethodV2(_RecordState.prototype,\"adapterError\",[tagged]);decorateMethodV2(_RecordState.prototype,\"isPreloaded\",[_ember_data_tracking__WEBPACK_IMPORTED_MODULE_5__.cached]);decorateMethodV2(_RecordState.prototype,\"stateName\",[_ember_data_tracking__WEBPACK_IMPORTED_MODULE_5__.cached]);decorateMethodV2(_RecordState.prototype,\"dirtyType\",[_ember_data_tracking__WEBPACK_IMPORTED_MODULE_5__.cached]);(0,_ember_data_tracking_private__WEBPACK_IMPORTED_MODULE_6__.defineSignal)(RecordState.prototype,'isSaving',false);function notifyErrorsStateChanged(state){state.notify('isValid');state.notify('isError');state.notify('adapterError');}/**\n  @module @ember-data/model\n *//*\n * This decorator allows us to lazily compute\n * an expensive getter on first-access and thereafter\n * never recompute it.\n */function computeOnce(target,propertyName,desc){const cache=new WeakMap();// eslint-disable-next-line @typescript-eslint/unbound-method\nconst getter=desc.get;desc.get=function(){let meta=cache.get(this);if(!meta){meta={hasComputed:false,value:undefined};cache.set(this,meta);}if(!meta.hasComputed){meta.value=getter.call(this);meta.hasComputed=true;}return meta.value;};return desc;}/**\n  Base class from which Models can be defined.\n\n  ```js\n  import Model, { attr } from '@ember-data/model';\n\n  export default class User extends Model {\n    @attr name;\n  }\n  ```\n\n  Models are used both to define the static schema for a\n  particular resource type as well as the class to instantiate\n  to present that data from cache.\n\n  @class Model\n  @public\n  @extends Ember.EmberObject\n*/class Model extends (_ember_object__WEBPACK_IMPORTED_MODULE_2___default()){// set during create by the store\ninit(options){{if(!options?._secretInit&&!options?._createProps){throw new Error('You should not call `create` on a model. Instead, call `store.createRecord` with the attributes you would like to set.');}}const createProps=options._createProps;const _secretInit=options._secretInit;options._createProps=null;options._secretInit=null;const store=this.store=_secretInit.store;super.init(options);this[_warp_drive_core_types_symbols__WEBPACK_IMPORTED_MODULE_7__.RecordStore]=store;const identity=_secretInit.identifier;_secretInit.cb(this,_secretInit.cache,identity,_secretInit.store);this.___recordState=new RecordState(this);this.setProperties(createProps);const notifications=store.notifications;this.___private_notifications=notifications.subscribe(identity,(identifier,type,field)=>{notifyChanges(identifier,type,field,this,store);});}// @ts-expect-error destroy should not return a value, but ember's types force it to\ndestroy(){const identifier=(0,_ember_data_store__WEBPACK_IMPORTED_MODULE_3__.recordIdentifierFor)(this);this.___recordState?.destroy();const store=(0,_ember_data_store__WEBPACK_IMPORTED_MODULE_3__.storeFor)(this);store.notifications.unsubscribe(this.___private_notifications);// Legacy behavior is to notify the relationships on destroy\n// such that they \"clear\". It's uncertain this behavior would\n// be good for a new model paradigm, likely cheaper and safer\n// to simply not notify, for this reason the store does not itself\n// notify individual changes once the delete has been signaled,\n// this decision is left to model instances.\nthis.eachRelationship((name,meta)=>{if(meta.kind==='belongsTo'){this.notifyPropertyChange(name);}});LEGACY_SUPPORT.get(this)?.destroy();LEGACY_SUPPORT.delete(this);LEGACY_SUPPORT.delete(identifier);super.destroy();}/**\n    If this property is `true` the record is in the `empty`\n    state. Empty is the first state all records enter after they have\n    been created. Most records created by the store will quickly\n    transition to the `loading` state if data needs to be fetched from\n    the server or the `created` state if the record is created on the\n    client. A record can also enter the empty state if the adapter is\n    unable to locate the record.\n     @property isEmpty\n    @public\n    @type {Boolean}\n    @readOnly\n  */get isEmpty(){return this.currentState.isEmpty;}/**\n    If this property is `true` the record is in the `loading` state. A\n    record enters this state when the store asks the adapter for its\n    data. It remains in this state until the adapter provides the\n    requested data.\n     @property isLoading\n    @public\n    @type {Boolean}\n    @readOnly\n  */get isLoading(){return this.currentState.isLoading;}/**\n    If this property is `true` the record is in the `loaded` state. A\n    record enters this state when its data is populated. Most of a\n    record's lifecycle is spent inside substates of the `loaded`\n    state.\n     Example\n     ```javascript\n    let record = store.createRecord('model');\n    record.isLoaded; // true\n     store.findRecord('model', 1).then(function(model) {\n      model.isLoaded; // true\n    });\n    ```\n     @property isLoaded\n    @public\n    @type {Boolean}\n    @readOnly\n  */get isLoaded(){return this.currentState.isLoaded;}/**\n    If this property is `true` the record is in the `dirty` state. The\n    record has local changes that have not yet been saved by the\n    adapter. This includes records that have been created (but not yet\n    saved) or deleted.\n     Example\n     ```javascript\n    let record = store.createRecord('model');\n    record.hasDirtyAttributes; // true\n     store.findRecord('model', 1).then(function(model) {\n      model.hasDirtyAttributes; // false\n      model.set('foo', 'some value');\n      model.hasDirtyAttributes; // true\n    });\n    ```\n     @since 1.13.0\n    @property hasDirtyAttributes\n    @public\n    @type {Boolean}\n    @readOnly\n  */get hasDirtyAttributes(){return this.currentState.isDirty;}/**\n    If this property is `true` the record is in the `saving` state. A\n    record enters the saving state when `save` is called, but the\n    adapter has not yet acknowledged that the changes have been\n    persisted to the backend.\n     Example\n     ```javascript\n    let record = store.createRecord('model');\n    record.isSaving; // false\n    let promise = record.save();\n    record.isSaving; // true\n    promise.then(function() {\n      record.isSaving; // false\n    });\n    ```\n     @property isSaving\n    @public\n    @type {Boolean}\n    @readOnly\n  */get isSaving(){return this.currentState.isSaving;}/**\n    If this property is `true` the record is in the `deleted` state\n    and has been marked for deletion. When `isDeleted` is true and\n    `hasDirtyAttributes` is true, the record is deleted locally but the deletion\n    was not yet persisted. When `isSaving` is true, the change is\n    in-flight. When both `hasDirtyAttributes` and `isSaving` are false, the\n    change has persisted.\n     Example\n     ```javascript\n    let record = store.createRecord('model');\n    record.isDeleted;    // false\n    record.deleteRecord();\n     // Locally deleted\n    record.isDeleted;           // true\n    record.hasDirtyAttributes;  // true\n    record.isSaving;            // false\n     // Persisting the deletion\n    let promise = record.save();\n    record.isDeleted;    // true\n    record.isSaving;     // true\n     // Deletion Persisted\n    promise.then(function() {\n      record.isDeleted;          // true\n      record.isSaving;           // false\n      record.hasDirtyAttributes; // false\n    });\n    ```\n     @property isDeleted\n    @public\n    @type {Boolean}\n    @readOnly\n  */get isDeleted(){return this.currentState.isDeleted;}/**\n    If this property is `true` the record is in the `new` state. A\n    record will be in the `new` state when it has been created on the\n    client and the adapter has not yet report that it was successfully\n    saved.\n     Example\n     ```javascript\n    let record = store.createRecord('model');\n    record.isNew; // true\n     record.save().then(function(model) {\n      model.isNew; // false\n    });\n    ```\n     @property isNew\n    @public\n    @type {Boolean}\n    @readOnly\n  */get isNew(){return this.currentState.isNew;}/**\n    If this property is `true` the record is in the `valid` state.\n     A record will be in the `valid` state when the adapter did not report any\n    server-side validation failures.\n     @property isValid\n    @public\n    @type {Boolean}\n    @readOnly\n  */get isValid(){return this.currentState.isValid;}/**\n    If the record is in the dirty state this property will report what\n    kind of change has caused it to move into the dirty\n    state. Possible values are:\n     - `created` The record has been created by the client and not yet saved to the adapter.\n    - `updated` The record has been updated by the client and not yet saved to the adapter.\n    - `deleted` The record has been deleted by the client and not yet saved to the adapter.\n     Example\n     ```javascript\n    let record = store.createRecord('model');\n    record.dirtyType; // 'created'\n    ```\n     @property dirtyType\n    @public\n    @type {String}\n    @readOnly\n  */get dirtyType(){return this.currentState.dirtyType;}/**\n    If `true` the adapter reported that it was unable to save local\n    changes to the backend for any reason other than a server-side\n    validation error.\n     Example\n     ```javascript\n    record.isError; // false\n    record.set('foo', 'valid value');\n    record.save().then(null, function() {\n      record.isError; // true\n    });\n    ```\n     @property isError\n    @public\n    @type {Boolean}\n    @readOnly\n  */get isError(){return this.currentState.isError;}set isError(v){{throw new Error(`isError is not directly settable`);}}/**\n    If `true` the store is attempting to reload the record from the adapter.\n     Example\n     ```javascript\n    record.isReloading; // false\n    record.reload();\n    record.isReloading; // true\n    ```\n     @property isReloading\n    @public\n    @type {Boolean}\n    @readOnly\n  *//**\n    All ember models have an id property. This is an identifier\n    managed by an external source. These are always coerced to be\n    strings before being used internally. Note when declaring the\n    attributes for a model it is an error to declare an id\n    attribute.\n     ```javascript\n    let record = store.createRecord('model');\n    record.id; // null\n     store.findRecord('model', 1).then(function(model) {\n      model.id; // '1'\n    });\n    ```\n     @property id\n    @public\n    @type {String}\n  */get id(){// this guard exists, because some dev-only deprecation code\n// (addListener via validatePropertyInjections) invokes toString before the\n// object is real.\n{try{return (0,_ember_data_store__WEBPACK_IMPORTED_MODULE_3__.recordIdentifierFor)(this).id;}catch{return null;}}return (0,_ember_data_store__WEBPACK_IMPORTED_MODULE_3__.recordIdentifierFor)(this).id;}set id(id){const normalizedId=(0,_ember_data_store_private__WEBPACK_IMPORTED_MODULE_4__.coerceId)(id);const identifier=(0,_ember_data_store__WEBPACK_IMPORTED_MODULE_3__.recordIdentifierFor)(this);const didChange=normalizedId!==identifier.id;(test=>{if(!test){throw new Error(`Cannot set ${identifier.type} record's id to ${id}, because id is already ${identifier.id}`);}})(!didChange||identifier.id===null);if(normalizedId!==null&&didChange){this.store._instanceCache.setRecordId(identifier,normalizedId);this.store.notifications.notify(identifier,'identity');}}toString(){return`<model::${this.constructor.modelName}:${this.id}>`;}/**\n    @property currentState\n    @private\n    @type {Object}\n  */// TODO we can probably make this a computeOnce\n// we likely do not need to notify the currentState root anymore\nget currentState(){// descriptors are called with the wrong `this` context during mergeMixins\n// when using legacy/classic ember classes. Basically: lazy in prod and eager in dev.\n// so we do this to try to steer folks to the nicer \"dont user currentState\"\n// error.\nreturn this.___recordState;}set currentState(_v){throw new Error('cannot set currentState');}/**\n    The store service instance which created this record instance\n    @property store\n    @public\n   *//**\n    When the record is in the `invalid` state this object will contain\n    any errors returned by the adapter. When present the errors hash\n    contains keys corresponding to the invalid property names\n    and values which are arrays of Javascript objects with two keys:\n     - `message` A string containing the error message from the backend\n    - `attribute` The name of the property associated with this error message\n     ```javascript\n    record.errors.length; // 0\n    record.set('foo', 'invalid value');\n    record.save().catch(function() {\n      record.errors.foo;\n      // [{message: 'foo should be a number.', attribute: 'foo'}]\n    });\n    ```\n     The `errors` property is useful for displaying error messages to\n    the user.\n     ```handlebars\n    <label>Username: <Input @value={{@model.username}} /> </label>\n    {{#each @model.errors.username as |error|}}\n      <div class=\"error\">\n        {{error.message}}\n      </div>\n    {{/each}}\n    <label>Email: <Input @value={{@model.email}} /> </label>\n    {{#each @model.errors.email as |error|}}\n      <div class=\"error\">\n        {{error.message}}\n      </div>\n    {{/each}}\n    ```\n      You can also access the special `messages` property on the error\n    object to get an array of all the error strings.\n     ```handlebars\n    {{#each @model.errors.messages as |message|}}\n      <div class=\"error\">\n        {{message}}\n      </div>\n    {{/each}}\n    ```\n     @property errors\n    @public\n    @type {Errors}\n  */get errors(){const errors=Errors.create({__record:this});this.currentState.updateInvalidErrors(errors);return errors;}/**\n    This property holds the `AdapterError` object with which\n    last adapter operation was rejected.\n     @property adapterError\n    @public\n    @type {AdapterError}\n  */get adapterError(){return this.currentState.adapterError;}set adapterError(v){throw new Error(`adapterError is not directly settable`);}/**\n    Create a JSON representation of the record, using the serialization\n    strategy of the store's adapter.\n    `serialize` takes an optional hash as a parameter, currently\n    supported options are:\n    - `includeId`: `true` if the record's ID should be included in the\n      JSON representation.\n     @method serialize\n    @public\n    @param {Object} options\n    @return {Object} an object whose values are primitive JSON values only\n  *//*\n    We hook the default implementation to ensure\n    our tagged properties are properly notified\n    as well. We still super for everything because\n    sync observers require a direct call occuring\n    to trigger their flush. We wouldn't need to\n    super in 4.0+ where sync observers are removed.\n   */// @ts-expect-error no return is necessary, but Ember's types are forcing it\nnotifyPropertyChange(prop){notifySignal(this,prop);super.notifyPropertyChange(prop);}/**\n    Marks the record as deleted but does not save it. You must call\n    `save` afterwards if you want to persist it. You might use this\n    method if you want to allow the user to still `rollbackAttributes()`\n    after a delete was made.\n     Example\n     ```js\n    import Component from '@glimmer/component';\n     export default class extends Component {\n      softDelete = () => {\n        this.args.model.deleteRecord();\n      }\n       confirm = () => {\n        this.args.model.save();\n      }\n       undo = () => {\n        this.args.model.rollbackAttributes();\n      }\n    }\n    ```\n     @method deleteRecord\n    @public\n  *//**\n    Same as `deleteRecord`, but saves the record immediately.\n     Example\n     ```js\n    import Component from '@glimmer/component';\n     export default class extends Component {\n      delete = () => {\n        this.args.model.destroyRecord().then(function() {\n          this.transitionToRoute('model.index');\n        });\n      }\n    }\n    ```\n     If you pass an object on the `adapterOptions` property of the options\n    argument it will be passed to your adapter via the snapshot\n     ```js\n    record.destroyRecord({ adapterOptions: { subscribe: false } });\n    ```\n     ```app/adapters/post.js\n    import MyCustomAdapter from './custom-adapter';\n     export default class PostAdapter extends MyCustomAdapter {\n      deleteRecord(store, type, snapshot) {\n        if (snapshot.adapterOptions.subscribe) {\n          // ...\n        }\n        // ...\n      }\n    }\n    ```\n     @method destroyRecord\n    @public\n    @param {Object} options\n    @return {Promise} a promise that will be resolved when the adapter returns\n    successfully or rejected if the adapter returns with an error.\n  *//**\n    Unloads the record from the store. This will not send a delete request\n    to your server, it just unloads the record from memory.\n     @method unloadRecord\n    @public\n  *//**\n    Returns an object, whose keys are changed properties, and value is\n    an [oldProp, newProp] array.\n     The array represents the diff of the canonical state with the local state\n    of the model. Note: if the model is created locally, the canonical state is\n    empty since the adapter hasn't acknowledged the attributes yet:\n     Example\n     ```app/models/mascot.js\n    import Model, { attr } from '@ember-data/model';\n     export default class MascotModel extends Model {\n      @attr('string') name;\n      @attr('boolean', {\n        defaultValue: false\n      })\n      isAdmin;\n    }\n    ```\n     ```javascript\n    let mascot = store.createRecord('mascot');\n     mascot.changedAttributes(); // {}\n     mascot.set('name', 'Tomster');\n    mascot.changedAttributes(); // { name: [undefined, 'Tomster'] }\n     mascot.set('isAdmin', true);\n    mascot.changedAttributes(); // { isAdmin: [undefined, true], name: [undefined, 'Tomster'] }\n     mascot.save().then(function() {\n      mascot.changedAttributes(); // {}\n       mascot.set('isAdmin', false);\n      mascot.changedAttributes(); // { isAdmin: [true, false] }\n    });\n    ```\n     @method changedAttributes\n    @public\n    @return {Object} an object, whose keys are changed properties,\n      and value is an [oldProp, newProp] array.\n  *//**\n    If the model `hasDirtyAttributes` this function will discard any unsaved\n    changes. If the model `isNew` it will be removed from the store.\n     Example\n     ```javascript\n    record.name; // 'Untitled Document'\n    record.set('name', 'Doc 1');\n    record.name; // 'Doc 1'\n    record.rollbackAttributes();\n    record.name; // 'Untitled Document'\n    ```\n     @since 1.13.0\n    @method rollbackAttributes\n    @public\n  *//**\n    @method _createSnapshot\n    @private\n  */// TODO @deprecate in favor of a public API or examples of how to test successfully\n/**\n    Save the record and persist any changes to the record to an\n    external source via the adapter.\n     Example\n     ```javascript\n    record.set('name', 'Tomster');\n    record.save().then(function() {\n      // Success callback\n    }, function() {\n      // Error callback\n    });\n    ```\n    If you pass an object using the `adapterOptions` property of the options\n   argument it will be passed to your adapter via the snapshot.\n     ```js\n    record.save({ adapterOptions: { subscribe: false } });\n    ```\n     ```app/adapters/post.js\n    import MyCustomAdapter from './custom-adapter';\n     export default class PostAdapter extends MyCustomAdapter {\n      updateRecord(store, type, snapshot) {\n        if (snapshot.adapterOptions.subscribe) {\n          // ...\n        }\n        // ...\n      }\n    }\n    ```\n     @method save\n    @public\n    @param {Object} options\n    @return {Promise} a promise that will be resolved when the adapter returns\n    successfully or rejected if the adapter returns with an error.\n  *//**\n    Reload the record from the adapter.\n     This will only work if the record has already finished loading.\n     Example\n     ```js\n    import Component from '@glimmer/component';\n     export default class extends Component {\n      async reload = () => {\n        await this.args.model.reload();\n        // do something with the reloaded model\n      }\n    }\n    ```\n     @method reload\n    @public\n    @param {Object} options optional, may include `adapterOptions` hash which will be passed to adapter request\n    @return {Promise} a promise that will be resolved with the record when the\n    adapter returns successfully or rejected if the adapter returns\n    with an error.\n  */attr(){(test=>{{throw new Error('The `attr` method is not available on Model, a Snapshot was probably expected. Are you passing a Model instead of a Snapshot to your serializer?');}})();}/**\n    Get the reference for the specified belongsTo relationship.\n     For instance, given the following model\n     ```app/models/blog-post.js\n    import Model, { belongsTo } from '@ember-data/model';\n     export default class BlogPost extends Model {\n      @belongsTo('user', { async: true, inverse: null }) author;\n    }\n    ```\n     Then the reference for the author relationship would be\n    retrieved from a record instance like so:\n     ```js\n    blogPost.belongsTo('author');\n    ```\n     A `BelongsToReference` is a low-level API that allows access\n    and manipulation of a belongsTo relationship.\n     It is especially useful when you're dealing with `async` relationships\n    as it allows synchronous access to the relationship data if loaded, as\n    well as APIs for loading, reloading the data or accessing available\n    information without triggering a load.\n     It may also be useful when using `sync` relationships that need to be\n    loaded/reloaded with more precise timing than marking the\n    relationship as `async` and relying on autofetch would have allowed.\n     However,keep in mind that marking a relationship as `async: false` will introduce\n    bugs into your application if the data is not always guaranteed to be available\n    by the time the relationship is accessed. Ergo, it is recommended when using this\n    approach to utilize `links` for unloaded relationship state instead of identifiers.\n     Reference APIs are entangled with the relationship's underlying state,\n    thus any getters or cached properties that utilize these will properly\n    invalidate if the relationship state changes.\n     References are \"stable\", meaning that multiple calls to retrieve the reference\n    for a given relationship will always return the same HasManyReference.\n     @method belongsTo\n    @public\n    @param {String} name of the relationship\n    @since 2.5.0\n    @return {BelongsToReference} reference for this relationship\n  *//**\n    Get the reference for the specified hasMany relationship.\n     For instance, given the following model\n     ```app/models/blog-post.js\n    import Model, { hasMany } from '@ember-data/model';\n     export default class BlogPost extends Model {\n      @hasMany('comment', { async: true, inverse: null }) comments;\n    }\n    ```\n     Then the reference for the comments relationship would be\n    retrieved from a record instance like so:\n     ```js\n    blogPost.hasMany('comments');\n    ```\n     A `HasManyReference` is a low-level API that allows access\n    and manipulation of a hasMany relationship.\n     It is especially useful when you are dealing with `async` relationships\n    as it allows synchronous access to the relationship data if loaded, as\n    well as APIs for loading, reloading the data or accessing available\n    information without triggering a load.\n     It may also be useful when using `sync` relationships with `@ember-data/model`\n    that need to be loaded/reloaded with more precise timing than marking the\n    relationship as `async` and relying on autofetch would have allowed.\n     However,keep in mind that marking a relationship as `async: false` will introduce\n    bugs into your application if the data is not always guaranteed to be available\n    by the time the relationship is accessed. Ergo, it is recommended when using this\n    approach to utilize `links` for unloaded relationship state instead of identifiers.\n     Reference APIs are entangled with the relationship's underlying state,\n    thus any getters or cached properties that utilize these will properly\n    invalidate if the relationship state changes.\n     References are \"stable\", meaning that multiple calls to retrieve the reference\n    for a given relationship will always return the same HasManyReference.\n     @method hasMany\n    @public\n    @param {String} name of the relationship\n    @since 2.5.0\n    @return {HasManyReference} reference for this relationship\n  *//**\n   Given a callback, iterates over each of the relationships in the model,\n   invoking the callback with the name of each relationship and its relationship\n   descriptor.\n     The callback method you provide should have the following signature (all\n   parameters are optional):\n    ```javascript\n   function(name, descriptor);\n   ```\n    - `name` the name of the current property in the iteration\n   - `descriptor` the meta object that describes this relationship\n    The relationship descriptor argument is an object with the following properties.\n    - **name** <span class=\"type\">String</span> the name of this relationship on the Model\n   - **kind** <span class=\"type\">String</span> \"hasMany\" or \"belongsTo\"\n   - **options** <span class=\"type\">Object</span> the original options hash passed when the relationship was declared\n   - **parentType** <span class=\"type\">Model</span> the type of the Model that owns this relationship\n   - **type** <span class=\"type\">String</span> the type name of the related Model\n    Note that in addition to a callback, you can also pass an optional target\n   object that will be set as `this` on the context.\n    Example\n    ```app/serializers/application.js\n   import JSONSerializer from '@ember-data/serializer/json';\n    export default class ApplicationSerializer extends JSONSerializer {\n      serialize(record, options) {\n      let json = {};\n       record.eachRelationship(function(name, descriptor) {\n        if (descriptor.kind === 'hasMany') {\n          let serializedHasManyName = name.toUpperCase() + '_IDS';\n          json[serializedHasManyName] = record.get(name).map(r => r.id);\n        }\n      });\n       return json;\n    }\n  }\n   ```\n    @method eachRelationship\n   @public\n   @param {Function} callback the callback to invoke\n   @param {any} binding the value to which the callback's `this` should be bound\n   */eachRelationship(callback,binding){this.constructor.eachRelationship(callback,binding);}relationshipFor(name){return this.constructor.relationshipsByName.get(name);}inverseFor(name){return this.constructor.inverseFor(name,(0,_ember_data_store__WEBPACK_IMPORTED_MODULE_3__.storeFor)(this));}eachAttribute(callback,binding){this.constructor.eachAttribute(callback,binding);}/*\n   These class methods below provide relationship\n   introspection abilities about relationships.\n    A note about the computed properties contained here:\n    **These properties are effectively sealed once called for the first time.**\n   To avoid repeatedly doing expensive iteration over a model's fields, these\n   values are computed once and then cached for the remainder of the runtime of\n   your application.\n    If your application needs to modify a class after its initial definition\n   (for example, using `reopen()` to add additional attributes), make sure you\n   do it before using your model with the store, which uses these properties\n   extensively.\n   *//**\n   For a given relationship name, returns the model type of the relationship.\n    For example, if you define a model like this:\n    ```app/models/post.js\n   import Model, { hasMany } from '@ember-data/model';\n    export default class PostModel extends Model {\n     @hasMany('comment') comments;\n   }\n   ```\n    Calling `store.modelFor('post').typeForRelationship('comments', store)` will return `Comment`.\n    @method typeForRelationship\n    @public\n   @static\n   @param {String} name the name of the relationship\n   @param {store} store an instance of Store\n   @return {Model} the type of the relationship, or undefined\n   */static typeForRelationship(name,store){(test=>{if(!test){throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);}})(this.modelName);const relationship=this.relationshipsByName.get(name);return relationship&&store.modelFor(relationship.type);}static get inverseMap(){(test=>{if(!test){throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);}})(this.modelName);return Object.create(null);}/**\n   Find the relationship which is the inverse of the one asked for.\n    For example, if you define models like this:\n    ```app/models/post.js\n   import Model, { hasMany } from '@ember-data/model';\n    export default class PostModel extends Model {\n      @hasMany('message') comments;\n    }\n   ```\n    ```app/models/message.js\n   import Model, { belongsTo } from '@ember-data/model';\n    export default class MessageModel extends Model {\n      @belongsTo('post') owner;\n    }\n   ```\n    ``` js\n   store.modelFor('post').inverseFor('comments', store) // { type: 'message', name: 'owner', kind: 'belongsTo' }\n   store.modelFor('message').inverseFor('owner', store) // { type: 'post', name: 'comments', kind: 'hasMany' }\n   ```\n    @method inverseFor\n    @public\n   @static\n   @param {String} name the name of the relationship\n   @param {Store} store\n   @return {Object} the inverse relationship, or null\n   */static inverseFor(name,store){(test=>{if(!test){throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);}})(this.modelName);const inverseMap=this.inverseMap;if(inverseMap[name]){return inverseMap[name];}else{const inverse=this._findInverseFor(name,store);inverseMap[name]=inverse;return inverse;}}//Calculate the inverse, ignoring the cache\nstatic _findInverseFor(name,store){(test=>{if(!test){throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);}})(this.modelName);const relationship=this.relationshipsByName.get(name);(test=>{if(!test){throw new Error(`No relationship named '${name}' on '${this.modelName}' exists.`);}})(relationship);if(!relationship){return null;}const{options}=relationship;(test=>{if(!test){throw new Error(`Expected the relationship ${name} on ${this.modelName} to define an inverse.`);}})(options.inverse===null||typeof options.inverse==='string'&&options.inverse.length>0);if(options.inverse===null){return null;}const schemaExists=store.schema.hasResource(relationship);(test=>{if(!test){throw new Error(`No associated schema found for '${relationship.type}' while calculating the inverse of ${name} on ${this.modelName}`);}})(schemaExists);if(!schemaExists){return null;}const inverseField=store.schema.fields(relationship).get(options.inverse);(test=>{if(!test){throw new Error(`No inverse relationship found for '${name}' on '${this.modelName}'`);}})(inverseField&&(inverseField.kind==='belongsTo'||inverseField.kind==='hasMany'));return inverseField||null;}/**\n   The model's relationships as a map, keyed on the type of the\n   relationship. The value of each entry is an array containing a descriptor\n   for each relationship with that type, describing the name of the relationship\n   as well as the type.\n    For example, given the following model definition:\n    ```app/models/blog.js\n   import Model, { belongsTo, hasMany } from '@ember-data/model';\n    export default class BlogModel extends Model {\n      @hasMany('user') users;\n      @belongsTo('user') owner;\n      @hasMany('post') posts;\n    }\n   ```\n    This computed property would return a map describing these\n   relationships, like this:\n    ```javascript\n   import Blog from 'app/models/blog';\n   import User from 'app/models/user';\n   import Post from 'app/models/post';\n    let relationships = Blog.relationships;\n   relationships.user;\n   //=> [ { name: 'users', kind: 'hasMany' },\n   //     { name: 'owner', kind: 'belongsTo' } ]\n   relationships.post;\n   //=> [ { name: 'posts', kind: 'hasMany' } ]\n   ```\n    @property relationships\n    @public\n   @static\n   @type Map\n   @readOnly\n   */static get relationships(){(test=>{if(!test){throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);}})(this.modelName);const map=new Map();const relationshipsByName=this.relationshipsByName;// Loop through each computed property on the class\nrelationshipsByName.forEach(desc=>{const{type}=desc;if(!map.has(type)){map.set(type,[]);}map.get(type).push(desc);});return map;}/**\n   A hash containing lists of the model's relationships, grouped\n   by the relationship kind. For example, given a model with this\n   definition:\n    ```app/models/blog.js\n   import Model, { belongsTo, hasMany } from '@ember-data/model';\n    export default class BlogModel extends Model {\n      @hasMany('user') users;\n      @belongsTo('user') owner;\n       @hasMany('post') posts;\n    }\n   ```\n    This property would contain the following:\n    ```javascript\n   import Blog from 'app/models/blog';\n    let relationshipNames = Blog.relationshipNames;\n   relationshipNames.hasMany;\n   //=> ['users', 'posts']\n   relationshipNames.belongsTo;\n   //=> ['owner']\n   ```\n    @property relationshipNames\n    @public\n   @static\n   @type Object\n   @readOnly\n   */static get relationshipNames(){(test=>{if(!test){throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);}})(this.modelName);const names={hasMany:[],belongsTo:[]};this.eachComputedProperty((name,meta)=>{if(isRelationshipSchema(meta)){names[meta.kind].push(name);}});return names;}/**\n   An array of types directly related to a model. Each type will be\n   included once, regardless of the number of relationships it has with\n   the model.\n    For example, given a model with this definition:\n    ```app/models/blog.js\n   import Model, { belongsTo, hasMany } from '@ember-data/model';\n    export default class BlogModel extends Model {\n      @hasMany('user') users;\n      @belongsTo('user') owner;\n       @hasMany('post') posts;\n    }\n   ```\n    This property would contain the following:\n    ```javascript\n   import Blog from 'app/models/blog';\n    let relatedTypes = Blog.relatedTypes');\n   //=> ['user', 'post']\n   ```\n    @property relatedTypes\n   @public\n   @static\n   @type Array\n   @readOnly\n   */static get relatedTypes(){(test=>{if(!test){throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);}})(this.modelName);const types=[];const rels=this.relationshipsObject;const relationships=Object.keys(rels);// create an array of the unique types involved\n// in relationships\nfor(let i=0;i<relationships.length;i++){const name=relationships[i];const meta=rels[name];const modelName=meta.type;if(!types.includes(modelName)){types.push(modelName);}}return types;}/**\n   A map whose keys are the relationships of a model and whose values are\n   relationship descriptors.\n    For example, given a model with this\n   definition:\n    ```app/models/blog.js\n   import Model, { belongsTo, hasMany } from '@ember-data/model';\n    export default class BlogModel extends Model {\n      @hasMany('user') users;\n      @belongsTo('user') owner;\n       @hasMany('post') posts;\n    }\n   ```\n    This property would contain the following:\n    ```javascript\n   import Blog from 'app/models/blog';\n    let relationshipsByName = Blog.relationshipsByName;\n   relationshipsByName.users;\n   //=> { name: 'users', kind: 'hasMany', type: 'user', options: Object }\n   relationshipsByName.owner;\n   //=> { name: 'owner', kind: 'belongsTo', type: 'user', options: Object }\n   ```\n    @property relationshipsByName\n    @public\n   @static\n   @type Map\n   @readOnly\n   */static get relationshipsByName(){(test=>{if(!test){throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);}})(this.modelName);const map=new Map();const rels=this.relationshipsObject;const relationships=Object.keys(rels);for(let i=0;i<relationships.length;i++){const name=relationships[i];const value=rels[name];map.set(value.name,value);}return map;}static get relationshipsObject(){(test=>{if(!test){throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);}})(this.modelName);const relationships=Object.create(null);const modelName=this.modelName;this.eachComputedProperty((name,meta)=>{if(!isRelationshipSchema(meta)){return;}// TODO deprecate key being here\nmeta.key=name;meta.name=name;relationships[name]=meta;(test=>{if(!test){throw new Error(`Expected options in meta`);}})(meta.options&&typeof meta.options==='object');(test=>{if(!test){throw new Error(`You should not specify both options.as and options.inverse as null on ${modelName}.${meta.name}, as if there is no inverse field there is no abstract type to conform to. You may have intended for this relationship to be polymorphic, or you may have mistakenly set inverse to null.`);}})(!(meta.options.inverse===null&&meta.options.as?.length));});return relationships;}/**\n   A map whose keys are the fields of the model and whose values are strings\n   describing the kind of the field. A model's fields are the union of all of its\n   attributes and relationships.\n    For example:\n    ```app/models/blog.js\n   import Model, { attr, belongsTo, hasMany } from '@ember-data/model';\n    export default class BlogModel extends Model {\n      @hasMany('user') users;\n      @belongsTo('user') owner;\n       @hasMany('post') posts;\n       @attr('string') title;\n    }\n   ```\n    ```js\n   import Blog from 'app/models/blog'\n    let fields = Blog.fields;\n   fields.forEach(function(kind, field) {\n      // do thing\n    });\n    // prints:\n   // users, hasMany\n   // owner, belongsTo\n   // posts, hasMany\n   // title, attribute\n   ```\n    @property fields\n    @public\n   @static\n   @type Map\n   @readOnly\n   */static get fields(){(test=>{if(!test){throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);}})(this.modelName);const map=new Map();this.eachComputedProperty((name,meta)=>{if(isRelationshipSchema(meta)){map.set(name,meta.kind);}else if(isAttributeSchema(meta)){map.set(name,'attribute');}});return map;}/**\n   Given a callback, iterates over each of the relationships in the model,\n   invoking the callback with the name of each relationship and its relationship\n   descriptor.\n    @method eachRelationship\n    @public\n   @static\n   @param {Function} callback the callback to invoke\n   @param {any} binding the value to which the callback's `this` should be bound\n   */static eachRelationship(callback,binding){(test=>{if(!test){throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);}})(this.modelName);this.relationshipsByName.forEach((relationship,name)=>{callback.call(binding,name,relationship);});}/**\n   Given a callback, iterates over each of the types related to a model,\n   invoking the callback with the related type's class. Each type will be\n   returned just once, regardless of how many different relationships it has\n   with a model.\n    @method eachRelatedType\n    @public\n   @static\n   @param {Function} callback the callback to invoke\n   @param {any} binding the value to which the callback's `this` should be bound\n   */static eachRelatedType(callback,binding){(test=>{if(!test){throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);}})(this.modelName);const relationshipTypes=this.relatedTypes;for(let i=0;i<relationshipTypes.length;i++){const type=relationshipTypes[i];callback.call(binding,type);}}/**\n   *\n   * @method determineRelationshipType\n   * @private\n   * @deprecated\n   */static determineRelationshipType(knownSide,store){(test=>{if(!test){throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);}})(this.modelName);const knownKey=knownSide.name;const knownKind=knownSide.kind;const inverse=this.inverseFor(knownKey,store);// let key;\nif(!inverse){return knownKind==='belongsTo'?'oneToNone':'manyToNone';}// key = inverse.name;\nconst otherKind=inverse.kind;if(otherKind==='belongsTo'){return knownKind==='belongsTo'?'oneToOne':'manyToOne';}else{return knownKind==='belongsTo'?'oneToMany':'manyToMany';}}/**\n   A map whose keys are the attributes of the model (properties\n   described by attr) and whose values are the meta object for the\n   property.\n    Example\n    ```app/models/person.js\n   import Model, { attr } from '@ember-data/model';\n    export default class PersonModel extends Model {\n      @attr('string') firstName;\n      @attr('string') lastName;\n      @attr('date') birthday;\n    }\n   ```\n    ```javascript\n   import Person from 'app/models/person'\n    let attributes = Person.attributes\n    attributes.forEach(function(meta, name) {\n      // do thing\n    });\n    // prints:\n   // firstName {type: \"string\", kind: 'attribute', options: Object, parentType: function, name: \"firstName\"}\n   // lastName {type: \"string\", kind: 'attribute', options: Object, parentType: function, name: \"lastName\"}\n   // birthday {type: \"date\", kind: 'attribute', options: Object, parentType: function, name: \"birthday\"}\n   ```\n    @property attributes\n    @public\n   @static\n   @type {Map}\n   @readOnly\n   */static get attributes(){(test=>{if(!test){throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);}})(this.modelName);const map=new Map();this.eachComputedProperty((name,meta)=>{if(isAttributeSchema(meta)){(test=>{if(!test){throw new Error(\"You may not set `id` as an attribute on your model. Please remove any lines that look like: `id: attr('<type>')` from \"+this.toString());}})(name!=='id');// TODO deprecate key being here\nmeta.key=name;meta.name=name;map.set(name,meta);}});return map;}/**\n   A map whose keys are the attributes of the model (properties\n   described by attr) and whose values are type of transformation\n   applied to each attribute. This map does not include any\n   attributes that do not have an transformation type.\n    Example\n    ```app/models/person.js\n   import Model, { attr } from '@ember-data/model';\n    export default class PersonModel extends Model {\n      @attr firstName;\n      @attr('string') lastName;\n      @attr('date') birthday;\n    }\n   ```\n    ```javascript\n   import Person from 'app/models/person';\n    let transformedAttributes = Person.transformedAttributes\n    transformedAttributes.forEach(function(field, type) {\n      // do thing\n    });\n    // prints:\n   // lastName string\n   // birthday date\n   ```\n    @property transformedAttributes\n    @public\n   @static\n   @type {Map}\n   @readOnly\n   */static get transformedAttributes(){(test=>{if(!test){throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);}})(this.modelName);const map=new Map();this.eachAttribute((name,meta)=>{if(meta.type){map.set(name,meta.type);}});return map;}/**\n   Iterates through the attributes of the model, calling the passed function on each\n   attribute.\n    The callback method you provide should have the following signature (all\n   parameters are optional):\n    ```javascript\n   function(name, meta);\n   ```\n    - `name` the name of the current property in the iteration\n   - `meta` the meta object for the attribute property in the iteration\n    Note that in addition to a callback, you can also pass an optional target\n   object that will be set as `this` on the context.\n    Example\n    ```javascript\n   import Model, { attr } from '@ember-data/model';\n    class PersonModel extends Model {\n      @attr('string') firstName;\n      @attr('string') lastName;\n      @attr('date') birthday;\n    }\n    PersonModel.eachAttribute(function(name, meta) {\n      // do thing\n    });\n    // prints:\n   // firstName {type: \"string\", kind: 'attribute', options: Object, parentType: function, name: \"firstName\"}\n   // lastName {type: \"string\", kind: 'attribute', options: Object, parentType: function, name: \"lastName\"}\n   // birthday {type: \"date\", kind: 'attribute', options: Object, parentType: function, name: \"birthday\"}\n   ```\n    @method eachAttribute\n    @public\n   @param {Function} callback The callback to execute\n   @param {Object} [binding] the value to which the callback's `this` should be bound\n   @static\n   */static eachAttribute(callback,binding){(test=>{if(!test){throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);}})(this.modelName);this.attributes.forEach((meta,name)=>{callback.call(binding,name,meta);});}/**\n   Iterates through the transformedAttributes of the model, calling\n   the passed function on each attribute. Note the callback will not be\n   called for any attributes that do not have an transformation type.\n    The callback method you provide should have the following signature (all\n   parameters are optional):\n    ```javascript\n   function(name, type);\n   ```\n    - `name` the name of the current property in the iteration\n   - `type` a string containing the name of the type of transformed\n   applied to the attribute\n    Note that in addition to a callback, you can also pass an optional target\n   object that will be set as `this` on the context.\n    Example\n    ```javascript\n   import Model, { attr } from '@ember-data/model';\n    let Person = Model.extend({\n      firstName: attr(),\n      lastName: attr('string'),\n      birthday: attr('date')\n    });\n    Person.eachTransformedAttribute(function(name, type) {\n      // do thing\n    });\n    // prints:\n   // lastName string\n   // birthday date\n   ```\n    @method eachTransformedAttribute\n    @public\n   @param {Function} callback The callback to execute\n   @param {Object} [binding] the value to which the callback's `this` should be bound\n   @static\n   */static eachTransformedAttribute(callback,binding){(test=>{if(!test){throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);}})(this.modelName);this.transformedAttributes.forEach((type,name)=>{callback.call(binding,name,type);});}/**\n   Returns the name of the model class.\n    @method toString\n    @public\n   @static\n   */static toString(){(test=>{if(!test){throw new Error(`Accessing schema information on Models without looking up the model via the store is disallowed.`);}})(this.modelName);return`model:${this.modelName}`;}}// @ts-expect-error TS doesn't know how to do `this` function overloads\n_Model=Model;decorateMethodV2(_Model.prototype,\"isEmpty\",[_ember_data_tracking__WEBPACK_IMPORTED_MODULE_5__.compat]);decorateMethodV2(_Model.prototype,\"isLoading\",[_ember_data_tracking__WEBPACK_IMPORTED_MODULE_5__.compat]);decorateMethodV2(_Model.prototype,\"isLoaded\",[_ember_data_tracking__WEBPACK_IMPORTED_MODULE_5__.compat]);decorateMethodV2(_Model.prototype,\"hasDirtyAttributes\",[_ember_data_tracking__WEBPACK_IMPORTED_MODULE_5__.compat]);decorateMethodV2(_Model.prototype,\"isSaving\",[_ember_data_tracking__WEBPACK_IMPORTED_MODULE_5__.compat]);decorateMethodV2(_Model.prototype,\"isDeleted\",[_ember_data_tracking__WEBPACK_IMPORTED_MODULE_5__.compat]);decorateMethodV2(_Model.prototype,\"isNew\",[_ember_data_tracking__WEBPACK_IMPORTED_MODULE_5__.compat]);decorateMethodV2(_Model.prototype,\"isValid\",[_ember_data_tracking__WEBPACK_IMPORTED_MODULE_5__.compat]);decorateMethodV2(_Model.prototype,\"dirtyType\",[_ember_data_tracking__WEBPACK_IMPORTED_MODULE_5__.compat]);decorateMethodV2(_Model.prototype,\"isError\",[_ember_data_tracking__WEBPACK_IMPORTED_MODULE_5__.compat]);decorateMethodV2(_Model.prototype,\"id\",[tagged]);decorateMethodV2(_Model.prototype,\"currentState\",[tagged]);decorateMethodV2(_Model.prototype,\"errors\",[computeOnce]);decorateMethodV2(_Model.prototype,\"adapterError\",[_ember_data_tracking__WEBPACK_IMPORTED_MODULE_5__.compat]);_defineProperty(Model,\"isModel\",true);/**\n    Create should only ever be called by the store. To create an instance of a\n    `Model` in a dirty state use `store.createRecord`.\n    To create instances of `Model` in a clean state, use `store.push`\n     @method create\n    @private\n    @static\n  *//**\n   Represents the model's class name as a string. This can be used to look up the model's class name through\n   `Store`'s modelFor method.\n    `modelName` is generated for you by EmberData. It will be a lowercased, dasherized string.\n   For example:\n    ```javascript\n   store.modelFor('post').modelName; // 'post'\n   store.modelFor('blog-post').modelName; // 'blog-post'\n   ```\n    The most common place you'll want to access `modelName` is in your serializer's `payloadKeyFromModelName` method. For example, to change payload\n   keys to underscore (instead of dasherized), you might use the following code:\n    ```javascript\n   import RESTSerializer from '@ember-data/serializer/rest';\n   import { underscore } from '<app-name>/utils/string-utils';\n    export default const PostSerializer = RESTSerializer.extend({\n     payloadKeyFromModelName(modelName) {\n       return underscore(modelName);\n     }\n   });\n   ```\n   @property modelName\n    @public\n   @type String\n   @readonly\n   @static\n  */_defineProperty(Model,\"modelName\",null);decorateMethodV2(_Model,\"inverseMap\",[computeOnce]);decorateMethodV2(_Model,\"relationships\",[computeOnce]);decorateMethodV2(_Model,\"relationshipNames\",[computeOnce]);decorateMethodV2(_Model,\"relatedTypes\",[computeOnce]);decorateMethodV2(_Model,\"relationshipsByName\",[computeOnce]);decorateMethodV2(_Model,\"relationshipsObject\",[computeOnce]);decorateMethodV2(_Model,\"fields\",[computeOnce]);decorateMethodV2(_Model,\"attributes\",[computeOnce]);decorateMethodV2(_Model,\"transformedAttributes\",[computeOnce]);Model.prototype.save=save;// @ts-expect-error TS doesn't know how to do `this` function overloads\nModel.prototype.destroyRecord=destroyRecord;Model.prototype.unloadRecord=unloadRecord;Model.prototype.hasMany=hasMany;Model.prototype.belongsTo=belongsTo;Model.prototype.serialize=serialize;Model.prototype._createSnapshot=createSnapshot;Model.prototype.deleteRecord=deleteRecord;Model.prototype.changedAttributes=changedAttributes;Model.prototype.rollbackAttributes=rollbackAttributes;Model.prototype.reload=reload;(0,_ember_data_tracking_private__WEBPACK_IMPORTED_MODULE_6__.defineSignal)(Model.prototype,'isReloading',false);// this is required to prevent `init` from passing\n// the values initialized during create to `setUnknownProperty`\nModel.prototype._createProps=null;Model.prototype._secretInit=null;{const lookupDescriptor=function lookupDescriptor(obj,keyName){let current=obj;do{const descriptor=Object.getOwnPropertyDescriptor(current,keyName);if(descriptor!==undefined){return descriptor;}current=Object.getPrototypeOf(current);}while(current!==null);return null;};// eslint-disable-next-line @typescript-eslint/unbound-method\nconst init=Model.prototype.init;Model.prototype.init=function(createArgs){init.call(this,createArgs);const ourDescriptor=lookupDescriptor(Model.prototype,'currentState');const theirDescriptor=lookupDescriptor(this,'currentState');if(!ourDescriptor||!theirDescriptor){throw new Error(`Unable to determine if 'currentState' is a reserved property name on instances of classes extending Model. Please ensure that 'currentState' is not defined as a property on ${this.constructor.toString()}`);}const realState=this.___recordState;if(ourDescriptor.get!==theirDescriptor.get||realState!==this.currentState){throw new Error(`'currentState' is a reserved property name on instances of classes extending Model. Please choose a different property name for ${this.constructor.toString()}`);}const ID_DESCRIPTOR=lookupDescriptor(Model.prototype,'id');const idDesc=lookupDescriptor(this,'id');if(!ID_DESCRIPTOR||!idDesc){throw new Error(`Unable to determine if 'id' is a reserved property name on instances of classes extending Model. Please ensure that 'id' is not defined as a property on ${this.constructor.toString()}`);}if(idDesc.get!==ID_DESCRIPTOR.get){throw new Error(`You may not set 'id' as an attribute on your model. Please remove any lines that look like: \\`id: attr('<type>')\\` from ${this.constructor.toString()}`);}};delete Model.reopen;delete Model.reopenClass;}function isRelationshipSchema(meta){const hasKind=typeof meta==='object'&&meta!==null&&'kind'in meta&&'options'in meta;return hasKind&&(meta.kind==='hasMany'||meta.kind==='belongsTo');}function isAttributeSchema(meta){return typeof meta==='object'&&meta!==null&&'kind'in meta&&meta.kind==='attribute';}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@ember-data/model/dist/model-CrihGN_B.js?");

/***/ }),

/***/ "./node_modules/@ember-data/model/dist/schema-provider-CB0q21oL.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@ember-data/model/dist/schema-provider-CB0q21oL.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   M: () => (/* binding */ ModelSchemaProvider),\n/* harmony export */   b: () => (/* binding */ buildSchema),\n/* harmony export */   g: () => (/* binding */ getModelFactory)\n/* harmony export */ });\n/* harmony import */ var _ember_application__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ember/application */ \"@ember/application\");\n/* harmony import */ var _ember_application__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ember_application__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ember_debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ember/debug */ \"@ember/debug\");\n/* harmony import */ var _ember_debug__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_ember_debug__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _model_CrihGN_B_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./model-CrihGN_B.js */ \"./node_modules/@ember-data/model/dist/model-CrihGN_B.js\");\n/*\n    In case someone defined a relationship to a mixin, for example:\n    ```ts\n      class CommentModel extends Model {\n        @belongsTo('commentable', { polymorphic: true }) owner;\n      }\n\n      let Commentable = Mixin.create({\n        @hasMany('comment') comments;\n      });\n    ```\n    we want to look up a Commentable class which has all the necessary\n    relationship meta data. Thus, we look up the mixin and create a mock\n    Model, so we can access the relationship CPs of the mixin (`comments`)\n    in this case\n  */function modelForMixin(store,normalizedModelName){const owner=(0,_ember_application__WEBPACK_IMPORTED_MODULE_0__.getOwner)(store);const MaybeMixin=owner.factoryFor(`mixin:${normalizedModelName}`);const mixin=MaybeMixin&&MaybeMixin.class;if(mixin){const ModelForMixin=_model_CrihGN_B_js__WEBPACK_IMPORTED_MODULE_2__.M.extend(mixin);ModelForMixin.__isMixin=true;ModelForMixin.__mixin=mixin;//Cache the class as a model\nowner.register(`model:${normalizedModelName}`,ModelForMixin);}return owner.factoryFor(`model:${normalizedModelName}`);}class ModelSchemaProvider{constructor(store){this.store=store;this._schemas=new Map();this._typeMisses=new Set();}hasTrait(type){(test=>{{throw new Error(`hasTrait is not available with @ember-data/model's SchemaService`);}})();return false;}resourceHasTrait(resource,trait){(test=>{{throw new Error(`resourceHasTrait is not available with @ember-data/model's SchemaService`);}})();return false;}transformation(field){(test=>{{throw new Error(`transformation is not available with @ember-data/model's SchemaService`);}})();}derivation(field){(test=>{{throw new Error(`derivation is not available with @ember-data/model's SchemaService`);}})();}hashFn(field){(test=>{{throw new Error(`hashFn is not available with @ember-data/model's SchemaService`);}})();}resource(resource){const type=(0,_model_CrihGN_B_js__WEBPACK_IMPORTED_MODULE_2__.n)(resource.type);if(!this._schemas.has(type)){this._loadModelSchema(type);}return this._schemas.get(type).schema;}registerResources(schemas){(test=>{{throw new Error(`registerResources is not available with @ember-data/model's SchemaService`);}})();}registerResource(schema){(test=>{{throw new Error(`registerResource is not available with @ember-data/model's SchemaService`);}})();}registerTransformation(transform){(test=>{{throw new Error(`registerTransformation is not available with @ember-data/model's SchemaService`);}})();}registerDerivation(derivation){(test=>{{throw new Error(`registerDerivation is not available with @ember-data/model's SchemaService`);}})();}registerHashFn(hashFn){(test=>{{throw new Error(`registerHashFn is not available with @ember-data/model's SchemaService`);}})();}_loadModelSchema(type){const modelClass=this.store.modelFor(type);const attributeMap=modelClass.attributes;const attributes=Object.create(null);attributeMap.forEach((meta,name)=>attributes[name]=meta);const relationships=modelClass.relationshipsObject||null;const fields=new Map();for(const attr of Object.values(attributes)){fields.set(attr.name,attr);}for(const rel of Object.values(relationships)){fields.set(rel.name,rel);}const schema={legacy:true,identity:{name:'id',kind:'@id'},type,fields:Array.from(fields.values())};const internalSchema={schema,attributes,relationships,fields};this._schemas.set(type,internalSchema);return internalSchema;}fields(resource){const type=(0,_model_CrihGN_B_js__WEBPACK_IMPORTED_MODULE_2__.n)(resource.type);if(!this._schemas.has(type)){this._loadModelSchema(type);}return this._schemas.get(type).fields;}hasResource(resource){const type=(0,_model_CrihGN_B_js__WEBPACK_IMPORTED_MODULE_2__.n)(resource.type);if(this._schemas.has(type)){return true;}if(this._typeMisses.has(type)){return false;}const factory=getModelFactory(this.store,type);const exists=factory!==null;if(!exists){this._typeMisses.add(type);return false;}return true;}}{ModelSchemaProvider.prototype.doesTypeExist=function(type){(0,_ember_debug__WEBPACK_IMPORTED_MODULE_1__.deprecate)(`Use \\`schema.hasResource({ type })\\` instead of \\`schema.doesTypeExist(type)\\``,false,{id:'ember-data:schema-service-updates',until:'5.0',for:'ember-data',since:{available:'5.4',enabled:'5.4'}});return this.hasResource({type});};ModelSchemaProvider.prototype.attributesDefinitionFor=function(resource){(0,_ember_debug__WEBPACK_IMPORTED_MODULE_1__.deprecate)(`Use \\`schema.fields({ type })\\` instead of \\`schema.attributesDefinitionFor({ type })\\``,false,{id:'ember-data:schema-service-updates',until:'5.0',for:'ember-data',since:{available:'5.4',enabled:'5.4'}});const type=(0,_model_CrihGN_B_js__WEBPACK_IMPORTED_MODULE_2__.n)(resource.type);if(!this._schemas.has(type)){this._loadModelSchema(type);}return this._schemas.get(type).attributes;};ModelSchemaProvider.prototype.relationshipsDefinitionFor=function(resource){(0,_ember_debug__WEBPACK_IMPORTED_MODULE_1__.deprecate)(`Use \\`schema.fields({ type })\\` instead of \\`schema.relationshipsDefinitionFor({ type })\\``,false,{id:'ember-data:schema-service-updates',until:'5.0',for:'ember-data',since:{available:'5.4',enabled:'5.4'}});const type=(0,_model_CrihGN_B_js__WEBPACK_IMPORTED_MODULE_2__.n)(resource.type);if(!this._schemas.has(type)){this._loadModelSchema(type);}return this._schemas.get(type).relationships;};}function buildSchema(store){return new ModelSchemaProvider(store);}function getModelFactory(store,type){if(!store._modelFactoryCache){store._modelFactoryCache=Object.create(null);}const cache=store._modelFactoryCache;let factory=cache[type];if(!factory){const owner=(0,_ember_application__WEBPACK_IMPORTED_MODULE_0__.getOwner)(store);factory=owner.factoryFor(`model:${type}`);if(!factory){//Support looking up mixins as base types for polymorphic relationships\nfactory=modelForMixin(store,type);}if(!factory){// we don't cache misses in case someone wants to register a missing model\nreturn null;}const klass=factory.class;if(klass.isModel){const hasOwnModelNameSet=klass.modelName&&Object.prototype.hasOwnProperty.call(klass,'modelName');if(!hasOwnModelNameSet){Object.defineProperty(klass,'modelName',{value:type});}}cache[type]=factory;}return factory;}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@ember-data/model/dist/schema-provider-CB0q21oL.js?");

/***/ }),

/***/ "./node_modules/@ember-data/request-utils/dist/deprecation-support.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@ember-data/request-utils/dist/deprecation-support.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ember_debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ember/debug */ \"@ember/debug\");\n/* harmony import */ var _ember_debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ember_debug__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _inflect_8aYUyMN7_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./inflect-8aYUyMN7.js */ \"./node_modules/@ember-data/request-utils/dist/inflect-8aYUyMN7.js\");\n{}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@ember-data/request-utils/dist/deprecation-support.js?");

/***/ }),

/***/ "./node_modules/@ember-data/request-utils/dist/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@ember-data/request-utils/dist/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CachePolicy: () => (/* binding */ CachePolicy),\n/* harmony export */   LifetimesService: () => (/* binding */ LifetimesService),\n/* harmony export */   buildBaseURL: () => (/* binding */ buildBaseURL),\n/* harmony export */   buildQueryParams: () => (/* binding */ buildQueryParams),\n/* harmony export */   filterEmpty: () => (/* binding */ filterEmpty),\n/* harmony export */   parseCacheControl: () => (/* binding */ parseCacheControl),\n/* harmony export */   setBuildURLConfig: () => (/* binding */ setBuildURLConfig),\n/* harmony export */   sortQueryParams: () => (/* binding */ sortQueryParams)\n/* harmony export */ });\n/* harmony import */ var _ember_debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ember/debug */ \"@ember/debug\");\n/* harmony import */ var _ember_debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ember_debug__WEBPACK_IMPORTED_MODULE_0__);\n/**\n * Simple utility function to assist in url building,\n * query params, and other common request operations.\n *\n * These primitives may be used directly or composed\n * by request builders to provide a consistent interface\n * for building requests.\n *\n * For instance:\n *\n * ```ts\n * import { buildBaseURL, buildQueryParams } from '@ember-data/request-utils';\n *\n * const baseURL = buildBaseURL({\n *   host: 'https://api.example.com',\n *   namespace: 'api/v1',\n *   resourcePath: 'emberDevelopers',\n *   op: 'query',\n *   identifier: { type: 'ember-developer' }\n * });\n * const url = `${baseURL}?${buildQueryParams({ name: 'Chris', include:['pets'] })}`;\n * // => 'https://api.example.com/api/v1/emberDevelopers?include=pets&name=Chris'\n * ```\n *\n * This is useful, but not as useful as the REST request builder for query which is sugar\n * over this (and more!):\n *\n * ```ts\n * import { query } from '@ember-data/rest/request';\n *\n * const options = query('ember-developer', { name: 'Chris', include:['pets'] });\n * // => { url: 'https://api.example.com/api/v1/emberDevelopers?include=pets&name=Chris' }\n * // Note: options will also include other request options like headers, method, etc.\n * ```\n *\n * @module @ember-data/request-utils\n * @main @ember-data/request-utils\n * @public\n */// prevents the final constructed object from needing to add\n// host and namespace which are provided by the final consuming\n// class to the prototype which can result in overwrite errors\nconst CONFIG={host:'',namespace:''};/**\n * Sets the global configuration for `buildBaseURL`\n * for host and namespace values for the application.\n *\n * These values may still be overridden by passing\n * them to buildBaseURL directly.\n *\n * This method may be called as many times as needed.\n * host values of `''` or `'/'` are equivalent.\n *\n * Except for the value of `/` as host, host should not\n * end with `/`.\n *\n * namespace should not start or end with a `/`.\n *\n * ```ts\n * type BuildURLConfig = {\n *   host: string;\n *   namespace: string'\n * }\n * ```\n *\n * Example:\n *\n * ```ts\n * import { setBuildURLConfig } from '@ember-data/request-utils';\n *\n * setBuildURLConfig({\n *   host: 'https://api.example.com',\n *   namespace: 'api/v1'\n * });\n * ```\n *\n * @method setBuildURLConfig\n * @static\n * @public\n * @for @ember-data/request-utils\n * @param {BuildURLConfig} config\n * @return void\n */function setBuildURLConfig(config){(test=>{if(!test){throw new Error(`setBuildURLConfig: You must pass a config object`);}})(config);(test=>{if(!test){throw new Error(`setBuildURLConfig: You must pass a config object with a 'host' or 'namespace' property`);}})('host'in config||'namespace'in config);CONFIG.host=config.host||'';CONFIG.namespace=config.namespace||'';(test=>{if(!test){throw new Error(`buildBaseURL: host must NOT end with '/', received '${CONFIG.host}'`);}})(CONFIG.host==='/'||!CONFIG.host.endsWith('/'));(test=>{if(!test){throw new Error(`buildBaseURL: namespace must NOT start with '/', received '${CONFIG.namespace}'`);}})(!CONFIG.namespace.startsWith('/'));(test=>{if(!test){throw new Error(`buildBaseURL: namespace must NOT end with '/', received '${CONFIG.namespace}'`);}})(!CONFIG.namespace.endsWith('/'));}const OPERATIONS_WITH_PRIMARY_RECORDS=new Set(['findRecord','findRelatedRecord','findRelatedCollection','updateRecord','deleteRecord']);function isOperationWithPrimaryRecord(options){return'op'in options&&OPERATIONS_WITH_PRIMARY_RECORDS.has(options.op);}function hasResourcePath(options){return'resourcePath'in options&&typeof options.resourcePath==='string'&&options.resourcePath.length>0;}function resourcePathForType(options){(test=>{if(!test){throw new Error(`resourcePathForType: You must pass a valid op as part of options`);}})('op'in options&&typeof options.op==='string');return options.op==='findMany'?options.identifiers[0].type:options.identifier.type;}/**\n * Builds a URL for a request based on the provided options.\n * Does not include support for building query params (see `buildQueryParams`)\n * so that it may be composed cleanly with other query-params strategies.\n *\n * Usage:\n *\n * ```ts\n * import { buildBaseURL } from '@ember-data/request-utils';\n *\n * const url = buildBaseURL({\n *   host: 'https://api.example.com',\n *   namespace: 'api/v1',\n *   resourcePath: 'emberDevelopers',\n *   op: 'query',\n *   identifier: { type: 'ember-developer' }\n * });\n *\n * // => 'https://api.example.com/api/v1/emberDevelopers'\n * ```\n *\n * On the surface this may seem like a lot of work to do something simple, but\n * it is designed to be composable with other utilities and interfaces that the\n * average product engineer will never need to see or use.\n *\n * A few notes:\n *\n * - `resourcePath` is optional, but if it is not provided, `identifier.type` will be used.\n * - `host` and `namespace` are optional, but if they are not provided, the values globally\n *    configured via `setBuildURLConfig` will be used.\n * - `op` is required and must be one of the following:\n *   - 'findRecord' 'query' 'findMany' 'findRelatedCollection' 'findRelatedRecord'` 'createRecord' 'updateRecord' 'deleteRecord'\n * - Depending on the value of `op`, `identifier` or `identifiers` will be required.\n *\n * @method buildBaseURL\n * @static\n * @public\n * @for @ember-data/request-utils\n * @param urlOptions\n * @return string\n */function buildBaseURL(urlOptions){const options=Object.assign({host:CONFIG.host,namespace:CONFIG.namespace},urlOptions);(test=>{if(!test){throw new Error(`buildBaseURL: You must pass \\`op\\` as part of options`);}})(hasResourcePath(options)||typeof options.op==='string'&&options.op.length>0);(test=>{if(!test){throw new Error(`buildBaseURL: You must pass \\`identifier\\` as part of options`);}})(hasResourcePath(options)||options.op==='findMany'||options.identifier&&typeof options.identifier==='object');(test=>{if(!test){throw new Error(`buildBaseURL: You must pass \\`identifiers\\` as part of options`);}})(hasResourcePath(options)||options.op!=='findMany'||options.identifiers&&Array.isArray(options.identifiers)&&options.identifiers.length>0&&options.identifiers.every(i=>i&&typeof i==='object'));(test=>{if(!test){throw new Error(`buildBaseURL: You must pass valid \\`identifier\\` as part of options, expected 'id'`);}})(hasResourcePath(options)||!isOperationWithPrimaryRecord(options)||typeof options.identifier.id==='string'&&options.identifier.id.length>0);(test=>{if(!test){throw new Error(`buildBaseURL: You must pass \\`identifiers\\` as part of options`);}})(hasResourcePath(options)||options.op!=='findMany'||options.identifiers.every(i=>typeof i.id==='string'&&i.id.length>0));(test=>{if(!test){throw new Error(`buildBaseURL: You must pass valid \\`identifier\\` as part of options, expected 'type'`);}})(hasResourcePath(options)||options.op==='findMany'||typeof options.identifier.type==='string'&&options.identifier.type.length>0);(test=>{if(!test){throw new Error(`buildBaseURL: You must pass valid \\`identifiers\\` as part of options, expected 'type'`);}})(hasResourcePath(options)||options.op!=='findMany'||typeof options.identifiers[0].type==='string'&&options.identifiers[0].type.length>0);// prettier-ignore\nconst idPath=isOperationWithPrimaryRecord(options)?encodeURIComponent(options.identifier.id):'';const resourcePath=options.resourcePath||resourcePathForType(options);const{host,namespace}=options;const fieldPath='fieldPath'in options?options.fieldPath:'';(test=>{if(!test){throw new Error(`buildBaseURL: You tried to build a url for a ${String('op'in options?options.op+' ':'')}request to ${resourcePath} but resourcePath must be set or op must be one of \"${['findRecord','findRelatedRecord','findRelatedCollection','updateRecord','deleteRecord','createRecord','query','findMany'].join('\",\"')}\".`);}})(hasResourcePath(options)||['findRecord','query','findMany','findRelatedCollection','findRelatedRecord','createRecord','updateRecord','deleteRecord'].includes(options.op));(test=>{if(!test){throw new Error(`buildBaseURL: host must NOT end with '/', received '${host}'`);}})(host==='/'||!host.endsWith('/'));(test=>{if(!test){throw new Error(`buildBaseURL: namespace must NOT start with '/', received '${namespace}'`);}})(!namespace.startsWith('/'));(test=>{if(!test){throw new Error(`buildBaseURL: namespace must NOT end with '/', received '${namespace}'`);}})(!namespace.endsWith('/'));(test=>{if(!test){throw new Error(`buildBaseURL: resourcePath must NOT start with '/', received '${resourcePath}'`);}})(!resourcePath.startsWith('/'));(test=>{if(!test){throw new Error(`buildBaseURL: resourcePath must NOT end with '/', received '${resourcePath}'`);}})(!resourcePath.endsWith('/'));(test=>{if(!test){throw new Error(`buildBaseURL: fieldPath must NOT start with '/', received '${fieldPath}'`);}})(!fieldPath.startsWith('/'));(test=>{if(!test){throw new Error(`buildBaseURL: fieldPath must NOT end with '/', received '${fieldPath}'`);}})(!fieldPath.endsWith('/'));(test=>{if(!test){throw new Error(`buildBaseURL: idPath must NOT start with '/', received '${idPath}'`);}})(!idPath.startsWith('/'));(test=>{if(!test){throw new Error(`buildBaseURL: idPath must NOT end with '/', received '${idPath}'`);}})(!idPath.endsWith('/'));const hasHost=host!==''&&host!=='/';const url=[hasHost?host:'',namespace,resourcePath,idPath,fieldPath].filter(Boolean).join('/');return hasHost?url:`/${url}`;}const DEFAULT_QUERY_PARAMS_SERIALIZATION_OPTIONS={arrayFormat:'comma'};function handleInclude(include){(test=>{if(!test){throw new Error(`Expected include to be a string or array, got ${typeof include}`);}})(typeof include==='string'||Array.isArray(include));return typeof include==='string'?include.split(','):include;}/**\n * filter out keys of an object that have falsy values or point to empty arrays\n * returning a new object with only those keys that have truthy values / non-empty arrays\n *\n * @method filterEmpty\n * @static\n * @public\n * @for @ember-data/request-utils\n * @param {Record<string, Serializable>} source object to filter keys with empty values from\n * @return {Record<string, Serializable>} A new object with the keys that contained empty values removed\n */function filterEmpty(source){const result={};for(const key in source){const value=source[key];// Allow `0` and `false` but filter falsy values that indicate \"empty\"\nif(value!==undefined&&value!==null&&value!==''){if(!Array.isArray(value)||value.length>0){result[key]=source[key];}}}return result;}/**\n * Sorts query params by both key and value returning a new URLSearchParams\n * object with the keys inserted in sorted order.\n *\n * Treats `included` specially, splicing it into an array if it is a string and sorting the array.\n *\n * Options:\n * - arrayFormat: 'bracket' | 'indices' | 'repeat' | 'comma'\n *\n * 'bracket': appends [] to the key for every value e.g. `&ids[]=1&ids[]=2`\n * 'indices': appends [i] to the key for every value e.g. `&ids[0]=1&ids[1]=2`\n * 'repeat': appends the key for every value e.g. `&ids=1&ids=2`\n * 'comma' (default): appends the key once with a comma separated list of values e.g. `&ids=1,2`\n *\n * @method sortQueryParams\n * @static\n * @public\n * @for @ember-data/request-utils\n * @param {URLSearchParams | object} params\n * @param {object} options\n * @return {URLSearchParams} A URLSearchParams with keys inserted in sorted order\n */function sortQueryParams(params,options){const opts=Object.assign({},DEFAULT_QUERY_PARAMS_SERIALIZATION_OPTIONS,options);const paramsIsObject=!(params instanceof URLSearchParams);const urlParams=new URLSearchParams();const dictionaryParams=paramsIsObject?params:{};if(!paramsIsObject){params.forEach((value,key)=>{const hasExisting=key in dictionaryParams;if(!hasExisting){dictionaryParams[key]=value;}else{const existingValue=dictionaryParams[key];if(Array.isArray(existingValue)){existingValue.push(value);}else{dictionaryParams[key]=[existingValue,value];}}});}if('include'in dictionaryParams){dictionaryParams.include=handleInclude(dictionaryParams.include);}const sortedKeys=Object.keys(dictionaryParams).sort();sortedKeys.forEach(key=>{const value=dictionaryParams[key];if(Array.isArray(value)){value.sort();switch(opts.arrayFormat){case'indices':value.forEach((v,i)=>{urlParams.append(`${key}[${i}]`,String(v));});return;case'bracket':value.forEach(v=>{urlParams.append(`${key}[]`,String(v));});return;case'repeat':value.forEach(v=>{urlParams.append(key,String(v));});return;case'comma':default:urlParams.append(key,value.join(','));return;}}else{urlParams.append(key,String(value));}});return urlParams;}/**\n * Sorts query params by both key and value, returning a query params string\n *\n * Treats `included` specially, splicing it into an array if it is a string and sorting the array.\n *\n * Options:\n * - arrayFormat: 'bracket' | 'indices' | 'repeat' | 'comma'\n *\n * 'bracket': appends [] to the key for every value e.g. `ids[]=1&ids[]=2`\n * 'indices': appends [i] to the key for every value e.g. `ids[0]=1&ids[1]=2`\n * 'repeat': appends the key for every value e.g. `ids=1&ids=2`\n * 'comma' (default): appends the key once with a comma separated list of values e.g. `ids=1,2`\n *\n * @method buildQueryParams\n * @static\n * @public\n * @for @ember-data/request-utils\n * @param {URLSearchParams | object} params\n * @param {object} [options]\n * @return {string} A sorted query params string without the leading `?`\n */function buildQueryParams(params,options){return sortQueryParams(params,options).toString();}const NUMERIC_KEYS=new Set(['max-age','s-maxage','stale-if-error','stale-while-revalidate']);/**\n *  Parses a string Cache-Control header value into an object with the following structure:\n *\n * ```ts\n * interface CacheControlValue {\n *   immutable?: boolean;\n *   'max-age'?: number;\n *   'must-revalidate'?: boolean;\n *   'must-understand'?: boolean;\n *   'no-cache'?: boolean;\n *   'no-store'?: boolean;\n *   'no-transform'?: boolean;\n *   'only-if-cached'?: boolean;\n *   private?: boolean;\n *   'proxy-revalidate'?: boolean;\n *   public?: boolean;\n *   's-maxage'?: number;\n *   'stale-if-error'?: number;\n *   'stale-while-revalidate'?: number;\n * }\n * ```\n * @method parseCacheControl\n * @static\n * @public\n * @for @ember-data/request-utils\n * @param {string} header\n * @return {CacheControlValue}\n */function parseCacheControl(header){let key='';let value='';let isParsingKey=true;const cacheControlValue={};function parseCacheControlValue(stringToParse){const parsedValue=Number.parseInt(stringToParse);(test=>{if(!test){throw new Error(`Invalid Cache-Control value, expected a number but got - ${stringToParse}`);}})(!Number.isNaN(parsedValue));return parsedValue;}for(let i=0;i<header.length;i++){const char=header.charAt(i);if(char===','){(test=>{if(!test){throw new Error(`Invalid Cache-Control value, expected a value`);}})(!isParsingKey||!NUMERIC_KEYS.has(key));(test=>{if(!test){throw new Error(`Invalid Cache-Control value, expected a value after \"=\" but got \",\"`);}})(i===0||header.charAt(i-1)!=='=');isParsingKey=true;// @ts-expect-error TS incorrectly thinks that optional keys must have a type that includes undefined\ncacheControlValue[key]=NUMERIC_KEYS.has(key)?parseCacheControlValue(value):true;key='';value='';continue;}else if(char==='='){(test=>{if(!test){throw new Error(`Invalid Cache-Control value, expected a value after \"=\"`);}})(i+1!==header.length);isParsingKey=false;}else if(char===' '||char===`\\t`||char===`\\n`){continue;}else if(isParsingKey){key+=char;}else{value+=char;}if(i===header.length-1){// @ts-expect-error TS incorrectly thinks that optional keys must have a type that includes undefined\ncacheControlValue[key]=NUMERIC_KEYS.has(key)?parseCacheControlValue(value):true;}}return cacheControlValue;}function isStale(headers,expirationTime){// const age = headers.get('age');\n// const cacheControl = parseCacheControl(headers.get('cache-control') || '');\n// const expires = headers.get('expires');\n// const lastModified = headers.get('last-modified');\nconst date=headers.get('date');if(!date){return true;}const time=new Date(date).getTime();const now=Date.now();const deadline=time+expirationTime;const result=now>deadline;return result;}/**\n * A basic CachePolicy that can be added to the Store service.\n *\n * Determines staleness based on time since the request was last received from the API\n * using the `date` header.\n *\n * Invalidates any request for which `cacheOptions.types` was provided when a createRecord\n * request for that type is successful.\n *\n * For this to work, the `createRecord` request must include the `cacheOptions.types` array\n * with the types that should be invalidated, or its request should specify the identifiers\n * of the records that are being created via `records`. Providing both is valid.\n *\n * > [!NOTE]\n * > only requests that had specified `cacheOptions.types` and occurred prior to the\n * > createRecord request will be invalidated. This means that a given request should always\n * > specify the types that would invalidate it to opt into this behavior. Abstracting this\n * > behavior via builders is recommended to ensure consistency.\n *\n * This allows the Store's CacheHandler to determine if a request is expired and\n * should be refetched upon next request.\n *\n * The `Fetch` handler provided by `@ember-data/request/fetch` will automatically\n * add the `date` header to responses if it is not present.\n *\n * > [!NOTE]\n * > Date headers do not have millisecond precision, so expiration times should\n * > generally be larger than 1000ms.\n *\n * Usage:\n *\n * ```ts\n * import { CachePolicy } from '@ember-data/request-utils';\n * import DataStore from '@ember-data/store';\n *\n * // ...\n *\n * export class Store extends DataStore {\n *   constructor(args) {\n *     super(args);\n *     this.lifetimes = new CachePolicy({ apiCacheSoftExpires: 30_000, apiCacheHardExpires: 60_000 });\n *   }\n * }\n * ```\n *\n * @class CachePolicy\n * @public\n * @module @ember-data/request-utils\n */class CachePolicy{_getStore(store){let set=this._stores.get(store);if(!set){set={invalidated:new Set(),types:new Map()};this._stores.set(store,set);}return set;}constructor(config){this._stores=new WeakMap();const _config=arguments.length===1?config:arguments[1];(0,_ember_debug__WEBPACK_IMPORTED_MODULE_0__.deprecate)(`Passing a Store to the CachePolicy is deprecated, please pass only a config instead.`,arguments.length===1,{id:'ember-data:request-utils:lifetimes-service-store-arg',since:{enabled:'5.4',available:'5.4'},for:'@ember-data/request-utils',until:'6.0'});(test=>{if(!test){throw new Error(`You must pass a config to the CachePolicy`);}})(_config);(test=>{if(!test){throw new Error(`You must pass a apiCacheSoftExpires to the CachePolicy`);}})(typeof _config.apiCacheSoftExpires==='number');(test=>{if(!test){throw new Error(`You must pass a apiCacheHardExpires to the CachePolicy`);}})(typeof _config.apiCacheHardExpires==='number');this.config=_config;}/**\n   * Invalidate a request by its identifier for a given store instance.\n   *\n   * While the store argument may seem redundant, the CachePolicy\n   * is designed to be shared across multiple stores / forks\n   * of the store.\n   *\n   * ```ts\n   * store.lifetimes.invalidateRequest(store, identifier);\n   * ```\n   *\n   * @method invalidateRequest\n   * @public\n   * @param {StableDocumentIdentifier} identifier\n   * @param {Store} store\n   */invalidateRequest(identifier,store){this._getStore(store).invalidated.add(identifier);}/**\n   * Invalidate all requests associated to a specific type\n   * for a given store instance.\n   *\n   * While the store argument may seem redundant, the CachePolicy\n   * is designed to be shared across multiple stores / forks\n   * of the store.\n   *\n   * This invalidation is done automatically when using this service\n   * for both the CacheHandler and the LegacyNetworkHandler.\n   *\n   * ```ts\n   * store.lifetimes.invalidateRequestsForType(store, 'person');\n   * ```\n   *\n   * @method invalidateRequestsForType\n   * @public\n   * @param {string} type\n   * @param {Store} store\n   */invalidateRequestsForType(type,store){const storeCache=this._getStore(store);const set=storeCache.types.get(type);const notifications=store.notifications;if(set){// TODO batch notifications\nset.forEach(id=>{storeCache.invalidated.add(id);notifications.notify(id,'invalidated');});}}/**\n   * Invoked when a request has been fulfilled from the configured request handlers.\n   * This is invoked by the CacheHandler for both foreground and background requests\n   * once the cache has been updated.\n   *\n   * Note, this is invoked by the CacheHandler regardless of whether\n   * the request has a cache-key.\n   *\n   * This method should not be invoked directly by consumers.\n   *\n   * @method didRequest\n   * @public\n   * @param {ImmutableRequestInfo} request\n   * @param {ImmutableResponse} response\n   * @param {Store} store\n   * @param {StableDocumentIdentifier | null} identifier\n   * @return {void}\n   */didRequest(request,response,identifier,store){// if this is a successful createRecord request, invalidate the cacheKey for the type\nif(request.op==='createRecord'){const statusNumber=response?.status??0;if(statusNumber>=200&&statusNumber<400){const types=new Set(request.records?.map(r=>r.type));const additionalTypes=request.cacheOptions?.types;additionalTypes?.forEach(type=>{types.add(type);});types.forEach(type=>{this.invalidateRequestsForType(type,store);});}// add this document's cacheKey to a map for all associated types\n// it is recommended to only use this for queries\n}else if(identifier&&request.cacheOptions?.types?.length){const storeCache=this._getStore(store);request.cacheOptions?.types.forEach(type=>{const set=storeCache.types.get(type);if(set){set.add(identifier);storeCache.invalidated.delete(identifier);}else{storeCache.types.set(type,new Set([identifier]));}});}}/**\n   * Invoked to determine if the request may be fulfilled from cache\n   * if possible.\n   *\n   * Note, this is only invoked by the CacheHandler if the request has\n   * a cache-key.\n   *\n   * If no cache entry is found or the entry is hard expired,\n   * the request will be fulfilled from the configured request handlers\n   * and the cache will be updated before returning the response.\n   *\n   * @method isHardExpired\n   * @public\n   * @param {StableDocumentIdentifier} identifier\n   * @param {Store} store\n   * @return {boolean} true if the request is considered hard expired\n   */isHardExpired(identifier,store){// if we are explicitly invalidated, we are hard expired\nconst storeCache=this._getStore(store);if(storeCache.invalidated.has(identifier)){return true;}const cache=store.cache;const cached=cache.peekRequest(identifier);return!cached||!cached.response||isStale(cached.response.headers,this.config.apiCacheHardExpires);}/**\n   * Invoked if `isHardExpired` is false to determine if the request\n   * should be update behind the scenes if cache data is already available.\n   *\n   * Note, this is only invoked by the CacheHandler if the request has\n   * a cache-key.\n   *\n   * If true, the request will be fulfilled from cache while a backgrounded\n   * request is made to update the cache via the configured request handlers.\n   *\n   * @method isSoftExpired\n   * @public\n   * @param {StableDocumentIdentifier} identifier\n   * @param {Store} store\n   * @return {boolean} true if the request is considered soft expired\n   */isSoftExpired(identifier,store){const cache=store.cache;const cached=cache.peekRequest(identifier);return!cached||!cached.response||isStale(cached.response.headers,this.config.apiCacheSoftExpires);}}class LifetimesService extends CachePolicy{constructor(config){(0,_ember_debug__WEBPACK_IMPORTED_MODULE_0__.deprecate)(`\\`import { LifetimesService } from '@ember-data/request-utils';\\` is deprecated, please use \\`import { CachePolicy } from '@ember-data/request-utils';\\` instead.`,false,{id:'ember-data:deprecate-lifetimes-service-import',since:{enabled:'5.4',available:'5.4'},for:'ember-data',until:'6.0'});super(config);}}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@ember-data/request-utils/dist/index.js?");

/***/ }),

/***/ "./node_modules/@ember-data/request-utils/dist/inflect-8aYUyMN7.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@ember-data/request-utils/dist/inflect-8aYUyMN7.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ singular),\n/* harmony export */   b: () => (/* binding */ plural),\n/* harmony export */   c: () => (/* binding */ loadUncountable),\n/* harmony export */   d: () => (/* binding */ clear),\n/* harmony export */   e: () => (/* binding */ clearRules),\n/* harmony export */   f: () => (/* binding */ dasherize),\n/* harmony export */   g: () => (/* binding */ camelize),\n/* harmony export */   h: () => (/* binding */ capitalize),\n/* harmony export */   i: () => (/* binding */ irregular),\n/* harmony export */   j: () => (/* binding */ underscore),\n/* harmony export */   k: () => (/* binding */ setMaxLRUCacheSize),\n/* harmony export */   l: () => (/* binding */ loadIrregular),\n/* harmony export */   m: () => (/* binding */ defaultRules),\n/* harmony export */   p: () => (/* binding */ pluralize),\n/* harmony export */   r: () => (/* binding */ resetToDefaults),\n/* harmony export */   s: () => (/* binding */ singularize),\n/* harmony export */   u: () => (/* binding */ uncountable)\n/* harmony export */ });\nconst defaultRules={plurals:[[/$/,'s'],[/s$/i,'s'],[/^(ax|test)is$/i,'$1es'],[/(octop|vir)us$/i,'$1i'],[/(octop|vir)i$/i,'$1i'],[/(alias|status|bonus)$/i,'$1es'],[/(bu)s$/i,'$1ses'],[/(buffal|tomat)o$/i,'$1oes'],[/([ti])um$/i,'$1a'],[/([ti])a$/i,'$1a'],[/sis$/i,'ses'],[/(?:([^f])fe|([lr])f)$/i,'$1$2ves'],[/(hive)$/i,'$1s'],[/([^aeiouy]|qu)y$/i,'$1ies'],[/(x|ch|ss|sh)$/i,'$1es'],[/(matr|vert|ind)(?:ix|ex)$/i,'$1ices'],[/^(m|l)ouse$/i,'$1ice'],[/^(m|l)ice$/i,'$1ice'],[/^(ox)$/i,'$1en'],[/^(oxen)$/i,'$1'],[/(quiz)$/i,'$1zes']],singular:[[/s$/i,''],[/(ss)$/i,'$1'],[/(n)ews$/i,'$1ews'],[/([ti])a$/i,'$1um'],[/((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)(sis|ses)$/i,'$1sis'],[/(^analy)(sis|ses)$/i,'$1sis'],[/([^f])ves$/i,'$1fe'],[/(hive)s$/i,'$1'],[/(tive)s$/i,'$1'],[/([lr])ves$/i,'$1f'],[/([^aeiouy]|qu)ies$/i,'$1y'],[/(s)eries$/i,'$1eries'],[/(m)ovies$/i,'$1ovie'],[/(x|ch|ss|sh)es$/i,'$1'],[/^(m|l)ice$/i,'$1ouse'],[/(bus)(es)?$/i,'$1'],[/(o)es$/i,'$1'],[/(shoe)s$/i,'$1'],[/(cris|test)(is|es)$/i,'$1is'],[/^(a)x[ie]s$/i,'$1xis'],[/(octop|vir)(us|i)$/i,'$1us'],[/(alias|status|bonus)(es)?$/i,'$1'],[/^(ox)en/i,'$1'],[/(vert|ind)ices$/i,'$1ex'],[/(matr)ices$/i,'$1ix'],[/(quiz)zes$/i,'$1'],[/(database)s$/i,'$1']],irregularPairs:[['person','people'],['man','men'],['child','children'],['sex','sexes'],['move','moves'],['cow','kine'],['zombie','zombies']],uncountable:['equipment','information','rice','money','species','series','fish','sheep','jeans','police']};const DEFAULT_MAX_CACHE_SIZE=10_000;class LRUCache{// debug stats\nconstructor(doWork,size){this.size=size||DEFAULT_MAX_CACHE_SIZE;this.state=new Map();this.doWork=doWork;{this._hits=0;this._misses=0;this._ejected=0;}}get(key){const value=this.state.get(key);if(value){{this._hits++;}this.state.delete(key);this.state.set(key,value);return value;}{this._misses++;}const newValue=this.doWork(key);this.set(key,newValue);return newValue;}set(key,value){if(this.state.size===this.size){for(const[k]of this.state){{this._ejected++;}this.state.delete(k);break;}}this.state.set(key,value);}clear(){this.state.clear();{this._hits=0;this._misses=0;this._ejected=0;}}}const STRING_DASHERIZE_REGEXP=/[ _]/g;const STRING_DECAMELIZE_REGEXP=/([a-z\\d])([A-Z])/g;const STRING_DASHERIZE_CACHE=new LRUCache(key=>key.replace(STRING_DECAMELIZE_REGEXP,'$1_$2').toLowerCase().replace(STRING_DASHERIZE_REGEXP,'-'));// eslint-disable-next-line no-useless-escape\nconst STRING_CAMELIZE_REGEXP_1=/(\\-|\\_|\\.|\\s)+(.)?/g;const STRING_CAMELIZE_REGEXP_2=/(^|\\/)([A-Z])/g;const CAMELIZE_CACHE=new LRUCache(key=>key.replace(STRING_CAMELIZE_REGEXP_1,(_match,_separator,chr)=>chr?chr.toUpperCase():'').replace(STRING_CAMELIZE_REGEXP_2,(match/*, separator, chr */)=>match.toLowerCase()));const STRING_UNDERSCORE_REGEXP_1=/([a-z\\d])([A-Z]+)/g;// eslint-disable-next-line no-useless-escape\nconst STRING_UNDERSCORE_REGEXP_2=/\\-|\\s+/g;const UNDERSCORE_CACHE=new LRUCache(str=>str.replace(STRING_UNDERSCORE_REGEXP_1,'$1_$2').replace(STRING_UNDERSCORE_REGEXP_2,'_').toLowerCase());const STRING_CAPITALIZE_REGEXP=/(^|\\/)([a-z\\u00C0-\\u024F])/g;const CAPITALIZE_CACHE=new LRUCache(str=>str.replace(STRING_CAPITALIZE_REGEXP,(match/*, separator, chr */)=>match.toUpperCase()));/**\n  Replaces underscores, spaces, or camelCase with dashes.\n\n  ```js\n  import { dasherize } from '@ember-data/request-utils/string';\n\n  dasherize('innerHTML');                // 'inner-html'\n  dasherize('action_name');              // 'action-name'\n  dasherize('css-class-name');           // 'css-class-name'\n  dasherize('my favorite items');        // 'my-favorite-items'\n  dasherize('privateDocs/ownerInvoice';  // 'private-docs/owner-invoice'\n  ```\n\n  @typedoc\n*/function dasherize(str){return STRING_DASHERIZE_CACHE.get(str);}/**\n  Returns the lowerCamelCase form of a string.\n\n  ```js\n  import { camelize } from '@ember-data/request-utils/string';\n\n  camelize('innerHTML');                   // 'innerHTML'\n  camelize('action_name');                 // 'actionName'\n  camelize('css-class-name');              // 'cssClassName'\n  camelize('my favorite items');           // 'myFavoriteItems'\n  camelize('My Favorite Items');           // 'myFavoriteItems'\n  camelize('private-docs/owner-invoice');  // 'privateDocs/ownerInvoice'\n```\n\n  @typedoc\n*/function camelize(str){return CAMELIZE_CACHE.get(str);}/**\n  Returns the lower\\_case\\_and\\_underscored form of a string.\n\n  ```js\n  import { underscore } from '@ember-data/request-utils/string';\n\n  underscore('innerHTML');                 // 'inner_html'\n  underscore('action_name');               // 'action_name'\n  underscore('css-class-name');            // 'css_class_name'\n  underscore('my favorite items');         // 'my_favorite_items'\n  underscore('privateDocs/ownerInvoice');  // 'private_docs/owner_invoice'\n  ```\n\n  @typedoc\n*/function underscore(str){return UNDERSCORE_CACHE.get(str);}/**\n  Returns the Capitalized form of a string\n\n  ```js\n  import { capitalize } from '@ember-data/request-utils/string';\n\n  capitalize('innerHTML')                 // 'InnerHTML'\n  capitalize('action_name')               // 'Action_name'\n  capitalize('css-class-name')            // 'Css-class-name'\n  capitalize('my favorite items')         // 'My favorite items'\n  capitalize('privateDocs/ownerInvoice'); // 'PrivateDocs/ownerInvoice'\n  ```\n\n  @typedoc\n*/function capitalize(str){return CAPITALIZE_CACHE.get(str);}function setMaxLRUCacheSize(size){CAMELIZE_CACHE.size=size;UNDERSCORE_CACHE.size=size;CAPITALIZE_CACHE.size=size;STRING_DASHERIZE_CACHE.size=size;}const BLANK_REGEX=/^\\s*$/;const LAST_WORD_DASHED_REGEX=/([\\w/-]+[_/\\s-])([a-z\\d]+$)/;const LAST_WORD_CAMELIZED_REGEX=/([\\w/\\s-]+)([A-Z][a-z\\d]*$)/;const CAMELIZED_REGEX=/[A-Z][a-z\\d]*$/;const SINGULARS=new LRUCache(word=>{return _singularize(word);});const PLURALS=new LRUCache(word=>{return _pluralize(word);});const UNCOUNTABLE=new Set(defaultRules.uncountable);const IRREGULAR=new Map();const INVERSE_IRREGULAR=new Map();const SINGULAR_RULES=new Map(defaultRules.singular.reverse());const PLURAL_RULES=new Map(defaultRules.plurals.reverse());function uncountable(word){UNCOUNTABLE.add(word.toLowerCase());}function loadUncountable(uncountables){uncountables.forEach(word=>{uncountable(word);});}function irregular(single,plur){//pluralizing\nIRREGULAR.set(single.toLowerCase(),plur);IRREGULAR.set(plur.toLowerCase(),plur);//singularizing\nINVERSE_IRREGULAR.set(plur.toLowerCase(),single);INVERSE_IRREGULAR.set(single.toLowerCase(),single);}function loadIrregular(irregularPairs){irregularPairs.forEach(pair=>{//pluralizing\nIRREGULAR.set(pair[0].toLowerCase(),pair[1]);IRREGULAR.set(pair[1].toLowerCase(),pair[1]);//singularizing\nINVERSE_IRREGULAR.set(pair[1].toLowerCase(),pair[0]);INVERSE_IRREGULAR.set(pair[0].toLowerCase(),pair[0]);});}loadIrregular(defaultRules.irregularPairs);function clear(){SINGULARS.clear();PLURALS.clear();}function resetToDefaults(){clearRules();defaultRules.uncountable.forEach(v=>UNCOUNTABLE.add(v));defaultRules.singular.forEach(v=>SINGULAR_RULES.set(v[0],v[1]));defaultRules.plurals.forEach(v=>PLURAL_RULES.set(v[0],v[1]));loadIrregular(defaultRules.irregularPairs);}function clearRules(){SINGULARS.clear();PLURALS.clear();UNCOUNTABLE.clear();IRREGULAR.clear();INVERSE_IRREGULAR.clear();SINGULAR_RULES.clear();PLURAL_RULES.clear();}function singularize(word){(test=>{if(!test){throw new Error(`singularize expects to receive a non-empty string`);}})(typeof word==='string'&&word.length>0);if(!word)return'';return SINGULARS.get(word);}function pluralize(word){(test=>{if(!test){throw new Error(`pluralize expects to receive a non-empty string`);}})(typeof word==='string'&&word.length>0);if(!word)return'';return PLURALS.get(word);}function unshiftMap(v,map){// reorder\nconst rules=[v,...map.entries()];map.clear();rules.forEach(rule=>{map.set(rule[0],rule[1]);});}function plural(regex,string){// rule requires reordering if exists, so remove it first\nif(PLURAL_RULES.has(regex)){PLURAL_RULES.delete(regex);}// reorder\nunshiftMap([regex,string],PLURAL_RULES);}function singular(regex,string){// rule requires reordering if exists, so remove it first\nif(SINGULAR_RULES.has(regex)){SINGULAR_RULES.delete(regex);}// reorder\nunshiftMap([regex,string],SINGULAR_RULES);}function _pluralize(word){return inflect(word,PLURAL_RULES,IRREGULAR);}function _singularize(word){return inflect(word,SINGULAR_RULES,INVERSE_IRREGULAR);}function inflect(word,typeRules,irregulars){// empty strings\nconst isBlank=!word||BLANK_REGEX.test(word);if(isBlank){return word;}// basic uncountables\nconst lowercase=word.toLowerCase();if(UNCOUNTABLE.has(lowercase)){return word;}// adv uncountables\nconst wordSplit=LAST_WORD_DASHED_REGEX.exec(word)||LAST_WORD_CAMELIZED_REGEX.exec(word);const lastWord=wordSplit?wordSplit[2].toLowerCase():null;if(lastWord&&UNCOUNTABLE.has(lastWord)){return word;}// handle irregulars\nconst isCamelized=CAMELIZED_REGEX.test(word);for(let[rule,substitution]of irregulars){if(lowercase.match(rule+'$')){if(isCamelized&&lastWord&&irregulars.has(lastWord)){substitution=capitalize(substitution);rule=capitalize(rule);}return word.replace(new RegExp(rule,'i'),substitution);}}// do the actual inflection\nfor(const[rule,substitution]of typeRules){if(rule.test(word)){return word.replace(rule,substitution);}}return word;}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@ember-data/request-utils/dist/inflect-8aYUyMN7.js?");

/***/ }),

/***/ "./node_modules/@ember-data/request-utils/dist/string.js":
/*!***************************************************************!*\
  !*** ./node_modules/@ember-data/request-utils/dist/string.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   camelize: () => (/* reexport safe */ _inflect_8aYUyMN7_js__WEBPACK_IMPORTED_MODULE_0__.g),\n/* harmony export */   capitalize: () => (/* reexport safe */ _inflect_8aYUyMN7_js__WEBPACK_IMPORTED_MODULE_0__.h),\n/* harmony export */   clear: () => (/* reexport safe */ _inflect_8aYUyMN7_js__WEBPACK_IMPORTED_MODULE_0__.d),\n/* harmony export */   clearRules: () => (/* reexport safe */ _inflect_8aYUyMN7_js__WEBPACK_IMPORTED_MODULE_0__.e),\n/* harmony export */   dasherize: () => (/* reexport safe */ _inflect_8aYUyMN7_js__WEBPACK_IMPORTED_MODULE_0__.f),\n/* harmony export */   irregular: () => (/* reexport safe */ _inflect_8aYUyMN7_js__WEBPACK_IMPORTED_MODULE_0__.i),\n/* harmony export */   loadIrregular: () => (/* reexport safe */ _inflect_8aYUyMN7_js__WEBPACK_IMPORTED_MODULE_0__.l),\n/* harmony export */   loadUncountable: () => (/* reexport safe */ _inflect_8aYUyMN7_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   plural: () => (/* reexport safe */ _inflect_8aYUyMN7_js__WEBPACK_IMPORTED_MODULE_0__.b),\n/* harmony export */   pluralize: () => (/* reexport safe */ _inflect_8aYUyMN7_js__WEBPACK_IMPORTED_MODULE_0__.p),\n/* harmony export */   resetToDefaults: () => (/* reexport safe */ _inflect_8aYUyMN7_js__WEBPACK_IMPORTED_MODULE_0__.r),\n/* harmony export */   setMaxLRUCacheSize: () => (/* reexport safe */ _inflect_8aYUyMN7_js__WEBPACK_IMPORTED_MODULE_0__.k),\n/* harmony export */   singular: () => (/* reexport safe */ _inflect_8aYUyMN7_js__WEBPACK_IMPORTED_MODULE_0__.a),\n/* harmony export */   singularize: () => (/* reexport safe */ _inflect_8aYUyMN7_js__WEBPACK_IMPORTED_MODULE_0__.s),\n/* harmony export */   uncountable: () => (/* reexport safe */ _inflect_8aYUyMN7_js__WEBPACK_IMPORTED_MODULE_0__.u),\n/* harmony export */   underscore: () => (/* reexport safe */ _inflect_8aYUyMN7_js__WEBPACK_IMPORTED_MODULE_0__.j)\n/* harmony export */ });\n/* harmony import */ var _inflect_8aYUyMN7_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./inflect-8aYUyMN7.js */ \"./node_modules/@ember-data/request-utils/dist/inflect-8aYUyMN7.js\");\n\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@ember-data/request-utils/dist/string.js?");

/***/ }),

/***/ "./node_modules/@ember-data/request/dist/debug-D0st-bv4.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@ember-data/request/dist/debug-D0st-bv4.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   I: () => (/* binding */ IS_CACHE_HANDLER),\n/* harmony export */   a: () => (/* binding */ assertValidRequest),\n/* harmony export */   b: () => (/* binding */ createDeferred),\n/* harmony export */   c: () => (/* binding */ clearRequestResult),\n/* harmony export */   d: () => (/* binding */ getPromiseResult),\n/* harmony export */   e: () => (/* binding */ executeNextHandler),\n/* harmony export */   f: () => (/* binding */ cloneResponseProperties),\n/* harmony export */   g: () => (/* binding */ getRequestResult),\n/* harmony export */   s: () => (/* binding */ setPromiseResult),\n/* harmony export */   u: () => (/* binding */ upgradePromise)\n/* harmony export */ });\n/* harmony import */ var _warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @warp-drive/core-types/-private */ \"./node_modules/@warp-drive/core-types/dist/-private.js\");\n/* harmony import */ var _warp_drive_core_types_request__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @warp-drive/core-types/request */ \"./node_modules/@warp-drive/core-types/dist/request.js\");\nfunction _classPrivateFieldInitSpec(e,t,a){_checkPrivateRedeclaration(e,t),t.set(e,a);}function _checkPrivateRedeclaration(e,t){if(t.has(e))throw new TypeError(\"Cannot initialize the same private elements twice on an object\");}function _classPrivateFieldGet(s,a){return s.get(_assertClassBrand(s,a));}function _classPrivateFieldSet(s,a,r){return s.set(_assertClassBrand(s,a),r),r;}function _assertClassBrand(e,t,n){if(\"function\"==typeof e?e===t:e.has(t))return arguments.length<3?t:n;throw new TypeError(\"Private element is not present on this object\");}function _defineProperty(e,r,t){return(r=_toPropertyKey(r))in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e;}function _toPropertyKey(t){var i=_toPrimitive(t,\"string\");return\"symbol\"==typeof i?i:i+\"\";}function _toPrimitive(t,r){if(\"object\"!=typeof t||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e.call(t,r||\"default\");if(\"object\"!=typeof i)return i;throw new TypeError(\"@@toPrimitive must return a primitive value.\");}return(\"string\"===r?String:Number)(t);}const PromiseCache=(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_0__.getOrSetUniversal)('PromiseCache',new WeakMap());const RequestMap=(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_0__.getOrSetUniversal)('RequestMap',new Map());function setRequestResult(requestId,result){RequestMap.set(requestId,result);}function clearRequestResult(requestId){RequestMap.delete(requestId);}function getRequestResult(requestId){return RequestMap.get(requestId);}function setPromiseResult(promise,result){PromiseCache.set(promise,result);}function getPromiseResult(promise){return PromiseCache.get(promise);}const IS_CACHE_HANDLER=(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_0__.getOrSetGlobal)('IS_CACHE_HANDLER',Symbol('IS_CACHE_HANDLER'));function curryFuture(owner,inbound,outbound){owner.setStream(inbound.getStream());inbound.then(doc=>{const document={[_warp_drive_core_types_request__WEBPACK_IMPORTED_MODULE_1__.STRUCTURED]:true,request:owner.request,response:doc.response,content:doc.content};outbound.resolve(document);},error=>{if(isDoc(error)){owner.setStream(owner.god.stream);}if(!error||!(error instanceof Error)){try{throw new Error(error?error:`Request Rejected with an Unknown Error`);}catch(e){if(error&&typeof error==='object'){Object.assign(e,error);e.message=error.message||`Request Rejected with an Unknown Error`;}error=e;}}error[_warp_drive_core_types_request__WEBPACK_IMPORTED_MODULE_1__.STRUCTURED]=true;error.request=owner.request;error.response=owner.getResponse();error.error=error.error||error.message;outbound.reject(error);});return outbound.promise;}function isDoc(doc){return doc&&doc[_warp_drive_core_types_request__WEBPACK_IMPORTED_MODULE_1__.STRUCTURED]===true;}function ensureDoc(owner,content,isError){if(isDoc(content)){return content;}if(isError){return{[_warp_drive_core_types_request__WEBPACK_IMPORTED_MODULE_1__.STRUCTURED]:true,request:owner.request,response:owner.getResponse(),error:content};}return{[_warp_drive_core_types_request__WEBPACK_IMPORTED_MODULE_1__.STRUCTURED]:true,request:owner.request,response:owner.getResponse(),content:content};}function enhanceReason(reason){return new DOMException(reason||'The user aborted a request.','AbortError');}function handleOutcome(owner,inbound,outbound){inbound.then(content=>{if(owner.controller.signal.aborted){// the next function did not respect the signal, we handle it here\noutbound.reject(enhanceReason(owner.controller.signal.reason));return;}if(isDoc(content)){owner.setStream(owner.god.stream);content=content.content;}const document={[_warp_drive_core_types_request__WEBPACK_IMPORTED_MODULE_1__.STRUCTURED]:true,request:owner.request,response:owner.getResponse(),content};outbound.resolve(document);},error=>{if(isDoc(error)){owner.setStream(owner.god.stream);}if(!error||!(error instanceof Error)){try{throw new Error(error?error:`Request Rejected with an Unknown Error`);}catch(e){if(error&&typeof error==='object'){Object.assign(e,error);e.message=error.message||`Request Rejected with an Unknown Error`;}error=e;}}error[_warp_drive_core_types_request__WEBPACK_IMPORTED_MODULE_1__.STRUCTURED]=true;error.request=owner.request;error.response=owner.getResponse();error.error=error.error||error.message;outbound.reject(error);});return outbound.promise;}function isCacheHandler(handler,index){return index===0&&Boolean(handler[IS_CACHE_HANDLER]);}function executeNextHandler(wares,request,i,god){{if(i===wares.length){throw new Error(`No handler was able to handle this request.`);}assertValidRequest(request,false);}const owner=new ContextOwner(request,god,i===0);function next(r){owner.nextCalled++;return executeNextHandler(wares,r,i+1,god);}const _isCacheHandler=isCacheHandler(wares[i],i);const context=new Context(owner,_isCacheHandler);let outcome;try{outcome=wares[i].request(context,next);if(_isCacheHandler){context._finalize();}if(!!outcome&&_isCacheHandler){if(!(outcome instanceof Promise)){setRequestResult(owner.requestId,{isError:false,result:ensureDoc(owner,outcome,false)});outcome=Promise.resolve(outcome);}}else{if(!outcome||!(outcome instanceof Promise)&&!(typeof outcome==='object'&&'then'in outcome)){// eslint-disable-next-line no-console\nconsole.log({request,handler:wares[i],outcome});if(outcome===undefined){throw new Error(`Expected handler.request to return a promise, instead received undefined.`);}throw new Error(`Expected handler.request to return a promise, instead received a synchronous value.`);}}}catch(e){if(_isCacheHandler){setRequestResult(owner.requestId,{isError:true,result:ensureDoc(owner,e,true)});}// eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\noutcome=Promise.reject(e);}const future=createFuture(owner);if(isFuture(outcome)){return curryFuture(owner,outcome,future);}return handleOutcome(owner,outcome,future);}function isFuture(maybe){return Boolean(maybe&&maybe instanceof Promise&&maybe[_warp_drive_core_types_request__WEBPACK_IMPORTED_MODULE_1__.IS_FUTURE]===true);}function createDeferred(){let resolve;let reject;const promise=new Promise((res,rej)=>{resolve=res;reject=rej;});return{resolve,reject,promise};}function upgradePromise(promise,future){promise[_warp_drive_core_types_request__WEBPACK_IMPORTED_MODULE_1__.IS_FUTURE]=true;// eslint-disable-next-line @typescript-eslint/unbound-method\npromise.getStream=future.getStream;// eslint-disable-next-line @typescript-eslint/unbound-method\npromise.abort=future.abort;// eslint-disable-next-line @typescript-eslint/unbound-method\npromise.onFinalize=future.onFinalize;promise.id=future.id;promise.lid=future.lid;return promise;}function createFuture(owner){const deferred=createDeferred();let{promise}=deferred;let cbs;promise=promise.finally(()=>{owner.resolveStream();if(cbs){cbs.forEach(cb=>cb());}});promise.onFinalize=fn=>{cbs=cbs||[];cbs.push(fn);};promise[_warp_drive_core_types_request__WEBPACK_IMPORTED_MODULE_1__.IS_FUTURE]=true;promise.getStream=()=>{return owner.getStream();};promise.abort=reason=>{owner.abort(enhanceReason(reason));};promise.id=owner.requestId;promise.lid=owner.god.identifier;deferred.promise=promise;return deferred;}function upgradeHeaders(headers){headers.clone=()=>{return new Headers(headers);};headers.toJSON=()=>{return Array.from(headers);};return headers;}function cloneResponseProperties(response){const{headers,ok,redirected,status,statusText,type,url}=response;upgradeHeaders(headers);return{headers:headers,ok,redirected,status,statusText,type,url};}class ContextOwner{constructor(request,god,isRoot=false){_defineProperty(this,\"hasSetStream\",false);_defineProperty(this,\"hasSetResponse\",false);_defineProperty(this,\"hasSubscribers\",false);_defineProperty(this,\"stream\",createDeferred());_defineProperty(this,\"response\",null);_defineProperty(this,\"nextCalled\",0);this.isRoot=isRoot;this.requestId=god.id;this.controller=request.controller||god.controller;this.stream.promise.sizeHint=0;if(request.controller){if(request.controller!==god.controller){god.controller.signal.addEventListener('abort',()=>{this.controller.abort(god.controller.signal.reason);});}delete request.controller;}let enhancedRequest=Object.assign({signal:this.controller.signal},request);{if(!request?.cacheOptions?.[_warp_drive_core_types_request__WEBPACK_IMPORTED_MODULE_1__.SkipCache]){request=deepFreeze(request);enhancedRequest=deepFreeze(enhancedRequest);}}this.enhancedRequest=enhancedRequest;this.request=request;this.god=god;this.stream.promise=this.stream.promise.then(stream=>{if(this.god.stream===stream&&this.hasSubscribers){this.god.stream=null;}return stream;});}get hasRequestedStream(){return this.god.hasRequestedStream;}getResponse(){if(this.hasSetResponse){return this.response;}if(this.nextCalled===1){return this.god.response;}return null;}getStream(){if(this.isRoot){this.god.hasRequestedStream=true;}if(!this.hasSetResponse){const hint=this.god.response?.headers?.get('content-length');this.stream.promise.sizeHint=hint?parseInt(hint,10):0;}this.hasSubscribers=true;return this.stream.promise;}abort(reason){this.controller.abort(reason);}setStream(stream){if(!this.hasSetStream){this.hasSetStream=true;if(!(stream instanceof Promise)){this.god.stream=stream;}// @ts-expect-error\nthis.stream.resolve(stream);}}resolveStream(){this.setStream(this.nextCalled===1?this.god.stream:null);}setResponse(response){if(this.hasSetResponse){{throw new Error(`Cannot setResponse when a response has already been set`);}return;}this.hasSetResponse=true;if(response instanceof Response){// TODO potentially avoid cloning in prod\nlet responseData=cloneResponseProperties(response);{responseData=deepFreeze(responseData);}this.response=responseData;this.god.response=responseData;const sizeHint=response.headers?.get('content-length');this.stream.promise.sizeHint=sizeHint?parseInt(sizeHint,10):0;}else{this.response=response;this.god.response=response;}}}var _owner=/*#__PURE__*/new WeakMap();class Context{constructor(owner,isCacheHandler){_classPrivateFieldInitSpec(this,_owner,void 0);this.id=owner.requestId;_classPrivateFieldSet(_owner,this,owner);this.request=owner.enhancedRequest;this._isCacheHandler=isCacheHandler;this._finalized=false;}setStream(stream){_classPrivateFieldGet(_owner,this).setStream(stream);}setResponse(response){_classPrivateFieldGet(_owner,this).setResponse(response);}setIdentifier(identifier){(test=>{if(!test){throw new Error(`setIdentifier may only be used synchronously from a CacheHandler`);}})(identifier&&this._isCacheHandler&&!this._finalized);_classPrivateFieldGet(_owner,this).god.identifier=identifier;}get hasRequestedStream(){return _classPrivateFieldGet(_owner,this).hasRequestedStream;}_finalize(){this._finalized=true;}}const BODY_TYPES={type:'string',klass:['Blob','ArrayBuffer','TypedArray','DataView','FormData','URLSearchParams','ReadableStream']};const ValidKeys=new Map([['records','array'],['data','json'],['body',BODY_TYPES],['disableTestWaiter','boolean'],['options','object'],['cacheOptions','object'],['op','string'],['store','object'],['url','string'],['cache',['default','force-cache','no-cache','no-store','only-if-cached','reload']],['credentials',['include','omit','same-origin']],['destination',['','object','audio','audioworklet','document','embed','font','frame','iframe','image','manifest','paintworklet','report','script','sharedworker','style','track','video','worker','xslt']],['headers','headers'],['integrity','string'],['keepalive','boolean'],['method',['GET','PUT','PATCH','DELETE','POST','OPTIONS']],['mode',['same-origin','cors','navigate','no-cors']],['redirect',['error','follow','manual']],['referrer','string'],['signal','AbortSignal'],['controller','AbortController'],['referrerPolicy',['','same-origin','no-referrer','no-referrer-when-downgrade','origin','origin-when-cross-origin','strict-origin','strict-origin-when-cross-origin','unsafe-url']]]);const IS_FROZEN=(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_0__.getOrSetGlobal)('IS_FROZEN',Symbol('FROZEN'));const IS_COLLECTION=(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_0__.getOrSetGlobal)('IS_COLLECTION',Symbol.for('Collection'));function freezeHeaders(headers){headers.delete=headers.set=headers.append=()=>{throw new Error(`Cannot Mutate Immutatable Headers, use headers.clone to get a copy`);};upgradeHeaders(headers);return headers;}function deepFreeze(value){if(value&&value[IS_FROZEN]){return value;}const _type=typeof value;switch(_type){case'boolean':case'string':case'number':case'symbol':case'undefined':case'bigint':return value;case'function':throw new Error(`Cannot deep-freeze a function`);case'object':{const _niceType=niceTypeOf(value);switch(_niceType){case'array':{if(value[IS_COLLECTION]){return value;}const arr=value.map(deepFreeze);arr[IS_FROZEN]=true;return Object.freeze(arr);}case'null':return value;case'object':Object.keys(value).forEach(key=>{try{value[key]=deepFreeze(value[key]);}catch{// continue\n}});value[IS_FROZEN]=true;return Object.freeze(value);case'headers':return freezeHeaders(value);case'Collection':case'Store':case'AbortSignal':return value;case'date':case'map':case'set':case'error':case'stream':default:// console.log(`Cannot deep-freeze ${_niceType}`);\nreturn value;}}}}function isMaybeContext(request){if(request&&typeof request==='object'){const keys=Object.keys(request);if(keys.length===1&&keys[0]==='request'){return true;}}return false;}function niceTypeOf(v){if(v===null){return'null';}if(typeof v==='string'){return v?'non-empty-string':'empty-string';}if(!v){return typeof v;}if(Array.isArray(v)){return'array';}if(v instanceof Date){return'date';}if(v instanceof Map){return'map';}if(v instanceof Set){return'set';}if(v instanceof Error){return'error';}if(v instanceof ReadableStream||v instanceof WritableStream||v instanceof TransformStream){return'stream';}if(v instanceof Headers){return'headers';}if(typeof v==='object'&&v.constructor&&v.constructor.name!=='Object'){return v.constructor.name;}return typeof v;}function validateKey(key,value,errors){const schema=ValidKeys.get(key);if(!schema&&!IgnoredKeys.has(key)){errors.push(`InvalidKey: '${key}'`);return;}if(schema){if(schema===BODY_TYPES){if(typeof value==='string'||value instanceof ReadableStream){return;}const type=niceTypeOf(value);if(schema.klass.includes(type)){return;}errors.push(`InvalidValue: key 'body' should be a string or one of '${schema.klass.join(\"', '\")}', received ${'<a value of type '+niceTypeOf(value)+'>'}`);return;}if(Array.isArray(schema)){if(!schema.includes(value)){errors.push(`InvalidValue: key ${key} should be a one of '${schema.join(\"', '\")}', received ${typeof value==='string'?value:'<a value of type '+niceTypeOf(value)+'>'}`);}return;}else if(schema==='json'){try{JSON.stringify(value);}catch(e){errors.push(`InvalidValue: key ${key} should be a JSON serializable value, but failed to serialize with Error - ${e.message}`);}return;}else if(schema==='headers'){if(!(value instanceof Headers)){errors.push(`InvalidValue: key ${key} should be an instance of Headers, received ${niceTypeOf(value)}`);}return;}else if(schema==='record'){const _type=typeof value;// record must extend plain object or Object.create(null)\nif(!value||_type!=='object'||value.constructor&&value.constructor!==Object){errors.push(`InvalidValue: key ${key} should be a dictionary of string keys to string values, received ${niceTypeOf(value)}`);return;}const keys=Object.keys(value);keys.forEach(k=>{const v=value[k];if(typeof k!=='string'){errors.push(`\\tThe key ${String(k)} on ${key} should be a string key`);}else if(typeof v!=='string'){errors.push(`\\tThe value of ${key}.${k} should be a string not ${niceTypeOf(v)}`);}});return;}else if(schema==='string'){if(typeof value!=='string'||value.length===0){errors.push(`InvalidValue: key ${key} should be a non-empty string, received ${typeof value==='string'?\"''\":typeof value}`);}return;}else if(schema==='object'){if(!value||Array.isArray(value)||typeof value!=='object'){errors.push(`InvalidValue: key ${key} should be an object`);}return;}else if(schema==='boolean'){if(typeof value!=='boolean'){errors.push(`InvalidValue: key ${key} should be a boolean, received ${typeof value}`);}return;}else if(schema==='array'){if(!Array.isArray(value)){errors.push(`InvalidValue: key ${key} should be an array, received ${typeof value}`);}return;}}}const IgnoredKeys=new Set([]);function assertValidRequest(request,isTopLevel){{// handle basic shape\nif(!request){throw new Error(`Expected ${isTopLevel?'RequestManager.request':'next'}(<request>) to be called with a request, but none was provided.`);}if(Array.isArray(request)||typeof request!=='object'){throw new Error(`The \\`request\\` passed to \\`${isTopLevel?'RequestManager.request':'next'}(<request>)\\` should be an object, received \\`${niceTypeOf(request)}\\``);}if(Object.keys(request).length===0){throw new Error(`The \\`request\\` passed to \\`${isTopLevel?'RequestManager.request':'next'}(<request>)\\` was empty (\\`{}\\`). Requests need at least one valid key.`);}// handle accidentally passing context entirely\nif(request instanceof Context){throw new Error(`Expected a request passed to \\`${isTopLevel?'RequestManager.request':'next'}(<request>)\\` but received the previous handler's context instead`);}// handle Object.assign({}, context);\nif(isMaybeContext(request)){throw new Error(`Expected a request passed to \\`${isTopLevel?'RequestManager.request':'next'}(<request>)\\` but received an object with a request key instead.`);}// handle schema\nconst keys=Object.keys(request);const validationErrors=[];const isLegacyRequest=Boolean('op'in request&&!request.url);keys.forEach(key=>{if(isLegacyRequest&&key==='data'){return;}validateKey(key,request[key],validationErrors);});if(validationErrors.length){const error=new Error(`Invalid Request passed to \\`${isTopLevel?'RequestManager.request':'next'}(<request>)\\`.\\n\\nThe following issues were found:\\n\\n\\t${validationErrors.join('\\n\\t')}`);error.errors=validationErrors;throw error;}}}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@ember-data/request/dist/debug-D0st-bv4.js?");

/***/ }),

/***/ "./node_modules/@ember-data/request/dist/fetch.js":
/*!********************************************************!*\
  !*** ./node_modules/@ember-data/request/dist/fetch.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Fetch)\n/* harmony export */ });\n/* harmony import */ var _debug_D0st_bv4_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./debug-D0st-bv4.js */ \"./node_modules/@ember-data/request/dist/debug-D0st-bv4.js\");\n/**\n * A basic Fetch Handler which converts a request into a\n * `fetch` call presuming the response to be `json`.\n *\n * ```ts\n * import Fetch from '@ember-data/request/fetch';\n *\n * manager.use([Fetch]);\n * ```\n *\n * @module @ember-data/request/fetch\n * @main @ember-data/request/fetch\n */// Lazily close over fetch to avoid breaking Mirage\nconst _fetch=typeof fetch!=='undefined'?(...args)=>fetch(...args):typeof FastBoot!=='undefined'?(...args)=>FastBoot.require('node-fetch')(...args):()=>{throw new Error('No Fetch Implementation Found');};// clones a response in a way that should still\n// allow it to stream\nfunction cloneResponse(response,overrides){const props=(0,_debug_D0st_bv4_js__WEBPACK_IMPORTED_MODULE_0__.f)(response);return new Response(response.body,Object.assign(props,overrides));}let IS_MAYBE_MIRAGE=()=>false;{IS_MAYBE_MIRAGE=()=>Boolean(typeof window!=='undefined'&&(window.server?.pretender||window.fetch.toString().replace(/\\s+/g,'')!=='function fetch() { [native code] }'.replace(/\\s+/g,'')));}const MUTATION_OPS=new Set(['updateRecord','createRecord','deleteRecord']);const ERROR_STATUS_CODE_FOR=new Map([[400,'Bad Request'],[401,'Unauthorized'],[402,'Payment Required'],[403,'Forbidden'],[404,'Not Found'],[405,'Method Not Allowed'],[406,'Not Acceptable'],[407,'Proxy Authentication Required'],[408,'Request Timeout'],[409,'Conflict'],[410,'Gone'],[411,'Length Required'],[412,'Precondition Failed'],[413,'Payload Too Large'],[414,'URI Too Long'],[415,'Unsupported Media Type'],[416,'Range Not Satisfiable'],[417,'Expectation Failed'],[419,'Page Expired'],[420,'Enhance Your Calm'],[421,'Misdirected Request'],[422,'Unprocessable Entity'],[423,'Locked'],[424,'Failed Dependency'],[425,'Too Early'],[426,'Upgrade Required'],[428,'Precondition Required'],[429,'Too Many Requests'],[430,'Request Header Fields Too Large'],[431,'Request Header Fields Too Large'],[450,'Blocked By Windows Parental Controls'],[451,'Unavailable For Legal Reasons'],[500,'Internal Server Error'],[501,'Not Implemented'],[502,'Bad Gateway'],[503,'Service Unavailable'],[504,'Gateway Timeout'],[505,'HTTP Version Not Supported'],[506,'Variant Also Negotiates'],[507,'Insufficient Storage'],[508,'Loop Detected'],[509,'Bandwidth Limit Exceeded'],[510,'Not Extended'],[511,'Network Authentication Required']]);/**\n * A basic handler which converts a request into a\n * `fetch` call presuming the response to be `json`.\n *\n * ```ts\n * import Fetch from '@ember-data/request/fetch';\n *\n * manager.use([Fetch]);\n * ```\n *\n * @class Fetch\n * @public\n */const Fetch={async request(context){let response;try{response=await _fetch(context.request.url,context.request);}catch(e){if(e instanceof DOMException&&e.name==='AbortError'){e.statusText='Aborted';e.status=20;e.isRequestError=true;}else{e.statusText='Unknown Network Error';e.status=0;e.isRequestError=true;}throw e;}const isError=!response.ok||response.status>=400;const op=context.request.op;const isMutationOp=Boolean(op&&MUTATION_OPS.has(op));if(!isError&&!isMutationOp&&response.status!==204&&!response.headers.has('date')){if(IS_MAYBE_MIRAGE()){response.headers.set('date',new Date().toUTCString());}else{const headers=new Headers(response.headers);headers.set('date',new Date().toUTCString());response=cloneResponse(response,{headers});}}context.setResponse(response);if(response.status===204){return null;}let text='';// if we are in a mirage context, we cannot support streaming\nif(IS_MAYBE_MIRAGE()){text=await response.text();}else{const reader=response.body.getReader();const decoder=new TextDecoder();let isStreaming=context.hasRequestedStream;let stream=isStreaming?new TransformStream():null;let writer=stream?.writable.getWriter();if(isStreaming){// Listen for the abort event on the AbortSignal\ncontext.request.signal?.addEventListener('abort',()=>{if(!isStreaming){return;}void stream.writable.abort('Request Aborted');void stream.readable.cancel('Request Aborted');});context.setStream(stream.readable);}while(true){// we manually read the stream instead of using `response.json()`\n// or `response.text()` because if we need to stream the body\n// we need to be able to pass the stream along efficiently.\nconst{done,value}=await reader.read();if(done){if(isStreaming){isStreaming=false;await writer.ready;await writer.close();}break;}text+=decoder.decode(value,{stream:true});// if we are streaming, we want to pass the stream along\nif(isStreaming){await writer.ready;await writer.write(value);}else if(context.hasRequestedStream){const encode=new TextEncoder();isStreaming=true;stream=new TransformStream();// Listen for the abort event on the AbortSignal\n// eslint-disable-next-line @typescript-eslint/no-loop-func\ncontext.request.signal?.addEventListener('abort',()=>{if(!isStreaming){return;}void stream.writable.abort('Request Aborted');void stream.readable.cancel('Request Aborted');});context.setStream(stream.readable);writer=stream.writable.getWriter();await writer.ready;await writer.write(encode.encode(text));await writer.ready;await writer.write(value);}}if(isStreaming){isStreaming=false;await writer.ready;await writer.close();}}// if we are an error, we will want to throw\nif(isError){let errorPayload;try{errorPayload=JSON.parse(text);}catch{// void;\n}// attempt errors discovery\nconst errors=Array.isArray(errorPayload)?errorPayload:isDict(errorPayload)&&Array.isArray(errorPayload.errors)?errorPayload.errors:null;const statusText=response.statusText||ERROR_STATUS_CODE_FOR.get(response.status)||'Unknown Request Error';const msg=`[${response.status} ${statusText}] ${context.request.method??'GET'} (${response.type}) - ${response.url}`;const error=errors?new AggregateError(errors,msg):new Error(msg);error.status=response.status;error.statusText=statusText;error.isRequestError=true;error.code=error.status;error.name=error.statusText.replaceAll(' ','')+'Error';error.content=errorPayload;throw error;}else{return JSON.parse(text);}}};function isDict(v){return v!==null&&typeof v==='object';}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@ember-data/request/dist/fetch.js?");

/***/ }),

/***/ "./node_modules/@ember-data/request/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@ember-data/request/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createDeferred: () => (/* reexport safe */ _debug_D0st_bv4_js__WEBPACK_IMPORTED_MODULE_1__.b),\n/* harmony export */   \"default\": () => (/* binding */ RequestManager),\n/* harmony export */   getPromiseResult: () => (/* reexport safe */ _debug_D0st_bv4_js__WEBPACK_IMPORTED_MODULE_1__.d),\n/* harmony export */   setPromiseResult: () => (/* reexport safe */ _debug_D0st_bv4_js__WEBPACK_IMPORTED_MODULE_1__.s)\n/* harmony export */ });\n/* harmony import */ var _warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @warp-drive/core-types/-private */ \"./node_modules/@warp-drive/core-types/dist/-private.js\");\n/* harmony import */ var _debug_D0st_bv4_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./debug-D0st-bv4.js */ \"./node_modules/@ember-data/request/dist/debug-D0st-bv4.js\");\n/* harmony import */ var _embroider_macros_src_addon_es_compat2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../@embroider/macros/src/addon/es-compat2 */ \"./node_modules/@embroider/macros/src/addon/es-compat2.js\");\nfunction _classPrivateFieldInitSpec(e,t,a){_checkPrivateRedeclaration(e,t),t.set(e,a);}function _checkPrivateRedeclaration(e,t){if(t.has(e))throw new TypeError(\"Cannot initialize the same private elements twice on an object\");}function _classPrivateFieldGet(s,a){return s.get(_assertClassBrand(s,a));}function _assertClassBrand(e,t,n){if(\"function\"==typeof e?e===t:e.has(t))return arguments.length<3?t:n;throw new TypeError(\"Private element is not present on this object\");}/* eslint-disable no-irregular-whitespace *//**\n *\n  <p align=\"center\">\n  <img\n    class=\"project-logo\"\n    src=\"https://raw.githubusercontent.com/emberjs/data/4612c9354e4c54d53327ec2cf21955075ce21294/ember-data-logo-light.svg#gh-light-mode-only\"\n    alt=\"EmberData RequestManager\"\n    width=\"240px\"\n    title=\"EmberData RequestManager\"\n    />\n</p>\n\n<p align=\"center\">⚡️ a simple abstraction over fetch to enable easy management of request/response flows</p>\n\nThis package provides [*Ember*‍**Data**](https://github.com/emberjs/data/)'s `RequestManager`, a framework agnostic library that can be integrated with any Javascript application to make [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) happen.\n\n- [Installation](#installation)\n- [Basic Usage](#🚀-basic-usage)\n- [Architecture](#🪜-architecture)\n- [Usage](#usage)\n  - [Making Requests](#making-requests)\n    - [Using The Response](#using-the-response)\n  - [Request Handlers](#handling-requests)\n    - [Handling Errors](#handling-errors)\n    - [Handling Abort](#handling-abort)\n    - [Stream Currying](#stream-currying)\n    - [Automatic Currying](#automatic-currying-of-stream-and-response)\n  - [Using as a Service](#using-as-a-service)\n    - [Using with `@ember-data/store`](#using-with-ember-datastore)\n    - [Using with `ember-data`](#using-with-ember-data)\n\n---\n\n## Installation\n\nInstall using your javascript package manager of choice. For instance with [pnpm](https://pnpm.io/)\n\n```no-highlight\npnpm add @ember-data/request\n```\n\n---\n\n## 🚀 Basic Usage\n\nA `RequestManager` provides a request/response flow in which configured handlers are successively given the opportunity to handle, modify, or pass-along a request.\n\nThe RequestManager on its own does not know how to fulfill requests. For this we must register at least one handler. A basic `Fetch` handler is provided that will take the request options provided and execute `fetch`.\n\n```ts\nimport RequestManager from '@ember-data/request';\nimport Fetch from '@ember-data/request/fetch';\nimport { apiUrl } from './config';\n\n// ... create manager and add our Fetch handler\nconst manager = new RequestManager();\nmanager.use([Fetch]);\n\n// ... execute a request\nconst response = await manager.request({\n  url: `${apiUrl}/users`\n});\n```\n\n---\n\n## 🪜 Architecture\n\nA `RequestManager` receives a request and manages fulfillment via configured handlers. It may be used standalone from the rest of *Ember*‍**Data** and is not specific to any library or framework.\n\nEach handler may choose to fulfill the request using some source of data or to pass the request along to other handlers.\n\nThe same or a separate instance of a `RequestManager` may also be used to fulfill requests issued by [*Ember*‍**Data**{Store}](https://github.com/emberjs/data/tree/main/packages/store)\n\nWhen the same instance is used by both this allows for simple coordination throughout the application. Requests issued by the Store will use the in-memory cache\nand return hydrated responses, requests issued directly to the RequestManager\nwill skip the in-memory cache and return raw responses.\n\n---\n\n## Usage\n\n```ts\nconst userList = await manager.request({\n  url: `/api/v1/users.list`\n});\n\nconst users = userList.content;\n```\n\n---\n\n### Making Requests\n\n`RequestManager` has a single asyncronous method as it's API: `request`\n\n```ts\nclass RequestManager {\n  request<T>(req: RequestInfo): Future<T>;\n}\n```\n\n`manager.request(<RequestInfo>)` accepts an object containing the information\nnecessary for the request to be handled successfully.\n\nThese options extend the [options](https://developer.mozilla.org/en-US/docs/Web/API/fetch#parameters) provided to `fetch`, and can accept a [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request/Request). All properties accepted by Request options and fetch options are valid.\n\n```ts\ninterface RequestInfo extends FetchOptions {\n  op?: string;\n  store?: Store;\n\n  url: string;\n   // data that a handler should convert into\n   // the query (GET) or body (POST)\n  data?: Record<string, unknown>;\n\n  // options specifically intended for handlers\n  // to utilize to process the request\n  options?: Record<string, unknown>;\n}\n```\n\n> **note**\n> providing a `signal` is unnecessary as an `AbortController` is automatically provided if none is present.\n\n---\n\n#### Using the Response\n\n`manager.request` returns a `Future`, which allows access to limited information about the request while it is still pending and fulfills with the final state when the request completes and the response has been read.\n\n```ts\nconst usersFuture = manager.request({\n  url: `/api/v1/users.list`\n});\n```\n\nA `Future` is cancellable via `abort`.\n\n```ts\nusersFuture.abort();\n```\n\nHandlers may *optionally* expose a ReadableStream to the `Future` for streaming data; however, when doing so the handler should not resolve until it has fully read the response stream itself.\n\n```ts\ninterface Future<T> extends Promise<StructuredDocument<T>> {\n  abort(): void;\n\n  async getStream(): ReadableStream | null;\n}\n```\n\nA Future resolves or rejects with a `StructuredDocument`.\n\n```ts\ninterface StructuredDocument<T> {\n  request: RequestInfo;\n  response: ResponseInfo | null;\n  content?: T;\n  error?: Error;\n}\n```\n\nThe `RequestInfo` specified by `document.request` is the same as originally provided to `manager.request`. If any handler fulfilled this request using different request info it is not represented here. This contract helps to ensure that `retry` and `caching` are possible since the original arguments are correctly preserved. This also allows handlers to \"fork\" the request or fulfill from multiple sources without the details of fulfillment muddying the original request.\n\nThe `ResponseInfo` is a serializable fulfilled subset of a [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response) if set via `setResponse`. If no response was ever set this will be `null`.\n\n```ts\ninterface ResponseInfo {\n  headers?: Record<string, string>;\n  ok?: boolean;\n  redirected?: boolean;\n  status?: HTTPStatusCode;\n  statusText?: string;\n  type?: 'basic' | 'cors';\n  url?: string;\n}\n```\n\n---\n\n### Request Handlers\n\nRequests are fulfilled by handlers. A handler receives the request context\nas well as a `next` function with which to pass along a request to the next\nhandler if it so chooses.\n\nA handler may be any object with a `request` method. This allows both stateful and non-stateful\nhandlers to be utilized.\n\nIf a handler calls `next`, it receives a `Future` which resolves to a `StructuredDocument`\nthat it can then compose how it sees fit with its own response.\n\n```ts\n\ntype NextFn<P> = (req: RequestInfo) => Future<P>;\n\ninterface Handler {\n  async request<T>(context: RequestContext, next: NextFn<P>): T;\n}\n```\n\n`RequestContext` contains a readonly version of the RequestInfo as well as a few methods for building up the `StructuredDocument` and `Future` that will be part of the response.\n\n```ts\ninterface RequestContext<T> {\n  readonly request: RequestInfo;\n\n  setStream(stream: ReadableStream | Promise<ReadableStream>): void;\n  setResponse(response: Response | ResponseInfo): void;\n}\n```\n\nA basic `fetch` handler with support for streaming content updates while\nthe download is still underway might look like the following, where we use\n[`response.clone()`](https://developer.mozilla.org/en-US/docs/Web/API/Response/clone) to `tee` the `ReadableStream` into two streams.\n\nA more efficient handler might read from the response stream, building up the\nresponse content before passing along the chunk downstream.\n\n```ts\nconst FetchHandler = {\n  async request(context) {\n    const response = await fetch(context.request);\n    context.setResponse(reponse);\n    context.setStream(response.clone().body);\n\n    return response.json();\n  }\n}\n```\n\nRequest handlers are registered by configuring the manager via `use`\n\n```ts\nmanager.use([Handler1, Handler2])\n```\n\nHandlers will be invoked in the order they are registered (\"fifo\", first-in first-out), and may only be registered up until the first request is made. It is recommended but not required to register all handlers at one time in order to ensure explicitly visible handler ordering.\n\n---\n\n#### Handling Errors\n\nEach handler in the chain can catch errors from upstream and choose to\neither handle the error, re-throw the error, or throw a new error.\n\n```ts\nconst MAX_RETRIES = 5;\n\nconst Handler = {\n  async request(context, next) {\n    let attempts = 0;\n\n    while (attempts < MAX_RETRIES) {\n      attempts++;\n      try {\n        const response = await next(context.request);\n        return response;\n      } catch (e) {\n        if (isTimeoutError(e) && attempts < MAX_RETRIES) {\n          // retry request\n          continue;\n        }\n        // rethrow if it is not a timeout error\n        throw e;\n      }\n    }\n  }\n}\n```\n\n---\n\n#### Handling Abort\n\nAborting a request will reject the current handler in the chain. However,\nevery handler can potentially catch this error. If your handler needs to\nseparate AbortError from other Error types, it is recommended to check\n`context.request.signal.aborted` (or if a custom controller was supplied `controller.signal.aborted`).\n\nIn this manner it is possible for a request to recover from an abort and\nstill proceed; however, as a best practice this should be used for necessary\ncleanup only and the original AbortError rethrown if the abort signal comes\nfrom the root controller.\n\n**AbortControllers are Always Present and Always Entangled**\n\nIf the initial request does not supply an [AbortController](https://developer.mozilla.org/en-US/docs/Web/API/AbortController), one will be generated.\n\nThe [signal](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal) for this controller is automatically added to the request passed into the first handler.\n\nEach handler has the option to supply a new controller to the request when calling `next`. If a new controller is provided it will be automatically\nentangled with the root controller. If the root controller aborts, so will\nany entangled controllers.\n\nIf an entangled controller aborts, the root controller will not abort. This\nallows for advanced request-flow scenarios to abort subsections of the request tree without aborting the entire request.\n\n---\n\n#### Stream Currying\n\n`RequestManager.request` and `next` differ from `fetch` in one **crucial detail** in that the outer Promise resolves only once the response stream has been processed.\n\nFor context, it helps to understand a few of the use-cases that RequestManager\nis intended to allow.\n\n- to manage and return streaming content (such as video files)\n- to fulfill a request from multiple sources or by splitting one request into multiple requests\n  - for instance one API call for a user and another for the user's friends\n  - or e.g. fulfilling part of the request from one source (one API, in-memory, localStorage, IndexedDB\n   etc.) and the rest from another source (a different API, a WebWorker, etc.)\n- to coalesce multiple requests\n- to decorate a request with additional info\n  - e.g. an Auth handler that ensures the correct tokens or headers or cookies are attached.\n\n\n`await fetch(<req>)` resolves at the moment headers are received. This allows for the body of the request to be processed as a stream by application\ncode *while chunks are still being received by the browser*.\n\nWhen an app chooses to `await response.json()` what occurs is the browser reads the stream to completion and then returns the result. Additionally, this stream may only be read **once**.\n\nThe `RequestManager` preserves this ability to subscribe to and utilize the stream by either the application or the handler – thereby delivering the full power and flexibility of native APIs – without restricting developers in ways that lead to complicated workarounds.\n\nEach handler may call `setStream` only once, but may do so *at any time* until the promise that the handler returns has resolved. The associated promise returned by calling `future.getStream` will resolve with the stream set by `setStream` if that method is called, or `null` if that method\nhas not been called by the time that the handler's request method has resolved.\n\nHandlers that do not create a stream of their own, but which call `next`, should defensively pipe the stream forward. While this is not required (see automatic currying below) it is better to do so in most cases as otherwise the stream may not become available to downstream handlers or the application until the upstream handler has fully read it.\n\n```ts\ncontext.setStream(future.getStream());\n```\n\nHandlers that either call `next` multiple times or otherwise have reason to create multiple  fetch requests should either choose to return no stream, meaningfully combine the streams, or select a single prioritized stream.\n\nOf course, any handler may choose to read and handle the stream, and return either no stream or a different stream in the process.\n\n---\n\n#### Automatic Currying of Stream and Response\n\nIn order to simplify the common case for handlers which decorate a request, if `next` is called only a single time and `setResponse` was never called by the handler, the response set by the next handler in the chain will be applied to that handler's outcome. For instance, this makes the following pattern possible `return (await next(<req>)).content;`.\n\nSimilarly, if `next` is called only a single time and neither `setStream` nor `getStream` was called, we automatically curry the stream from the future returned by `next` onto the future returned by the handler.\n\nFinally, if the return value of a handler is a `Future`, we curry `content` and `errors` as well, thus enabling the simplest form `return next(<req>)`.\n\nIn the case of the `Future` being returned, `Stream` proxying is automatic and immediate and does not wait for the `Future` to resolve.\n\n---\n\n### Using as a Service\n\nMost applications will desire to have a single `RequestManager` instance, which can be achieved using module-state patterns for singletons, or for [Ember](https://emberjs.com) applications by exporting the manager as a [service](https://guides.emberjs.com/release/services/).\n\n*services/request.ts*\n```ts\nimport RequestManager from '@ember-data/request';\nimport Fetch from '@ember-data/request/fetch';\nimport Auth from 'ember-simple-auth/ember-data-handler';\n\nexport default class extends RequestManager {\n  constructor(createArgs) {\n    super(createArgs);\n    this.use([Auth, Fetch]);\n  }\n}\n```\n\n---\n\n#### Using with `@ember-data/store`\n\nTo have a request service unique to a Store:\n\n```ts\nimport Store, { CacheHandler } from '@ember-data/store';\nimport RequestManager from '@ember-data/request';\nimport Fetch from '@ember-data/request/fetch';\n\nclass extends Store {\n  requestManager = new RequestManager();\n\n  constructor(args) {\n    super(args);\n    this.requestManager.use([Fetch]);\n    this.requestManager.useCache(CacheHandler);\n  }\n}\n```\n\n---\n\n#### Using with `ember-data`\n\nIf using the package [ember-data](https://github.com/emberjs/data/tree/main/packages/-ember-data),\nthe following configuration will automatically be done in order to preserve the\nlegacy [Adapter](https://github.com/emberjs/data/tree/main/packages/adapter) and\n[Serializer](https://github.com/emberjs/data/tree/main/packages/serializer) behavior.\nAdditional handlers or a service injection like the above would need to be done by the\nconsuming application in order to make broader use of `RequestManager`.\n\n```ts\nimport Store, { CacheHandler } from 'ember-data/store';\nimport RequestManager from '@ember-data/request';\nimport Fetch from '@ember-data/request/fetch';\nimport { LegacyNetworkHandler } from '@ember-data/legacy-compat';\n\nexport default class extends Store {\n  requestManager = new RequestManager();\n\n  constructor(args) {\n    super(args);\n    this.requestManager.use([LegacyNetworkHandler, Fetch]);\n    this.requestManager.useCache(CacheHandler);\n  }\n}\n```\n\nTo provide a different configuration, import and extend `ember-data/store`. The\ndefault configuration will be ignored if the `requestManager` property is set,\nthough the store will still register the CacheHandler.\n\nFor usage of the store's `requestManager` via `store.request(<req>)` see the\n[Store](https://api.emberjs.com/ember-data/release/modules/@ember-data%2Fstore) documentation.\n\n *\n * @module @ember-data/request\n * @main @ember-data/request\n *//**\n * ```js\n * import RequestManager from '@ember-data/request';\n * ```\n *\n * A RequestManager provides a request/response flow in which configured\n * handlers are successively given the opportunity to handle, modify, or\n * pass-along a request.\n *\n * ```ts\n * interface RequestManager {\n *   request<T>(req: RequestInfo): Future<T>;\n * }\n * ```\n *\n * For example:\n *\n * ```ts\n * import RequestManager from '@ember-data/request';\n * import Fetch from '@ember-data/request/fetch';\n * import Auth from 'ember-simple-auth/ember-data-handler';\n * import Config from './config';\n *\n * const { apiUrl } = Config;\n *\n * // ... create manager\n * const manager = new RequestManager().use([Auth, Fetch]);\n *\n * // ... execute a request\n * const response = await manager.request({\n *   url: `${apiUrl}/users`\n * });\n * ```\n *\n * ### Futures\n *\n * The return value of `manager.request` is a `Future`, which allows\n * access to limited information about the request while it is still\n * pending and fulfills with the final state when the request completes.\n *\n * A `Future` is cancellable via `abort`.\n *\n * Handlers may optionally expose a `ReadableStream` to the `Future` for\n * streaming data; however, when doing so the future should not resolve\n * until the response stream is fully read.\n *\n * ```ts\n * interface Future<T> extends Promise<StructuredDocument<T>> {\n *   abort(): void;\n *\n *   async getStream(): ReadableStream | null;\n * }\n * ```\n *\n * ### StructuredDocuments\n *\n * A Future resolves with a `StructuredDataDocument` or rejects with a `StructuredErrorDocument`.\n *\n * ```ts\n * interface StructuredDataDocument<T> {\n *   request: ImmutableRequestInfo;\n *   response: ImmutableResponseInfo;\n *   content: T;\n * }\n * interface StructuredErrorDocument extends Error {\n *   request: ImmutableRequestInfo;\n *   response: ImmutableResponseInfo;\n *   error: string | object;\n * }\n * type StructuredDocument<T> = StructuredDataDocument<T> | StructuredErrorDocument;\n * ```\n *\n * @class RequestManager\n * @public\n */var _handlers=/*#__PURE__*/new WeakMap();class RequestManager{/**\n   * A map of pending requests from request.id to their\n   * associated CacheHandler promise.\n   *\n   * This queue is managed by the CacheHandler\n   *\n   * @internal\n   */constructor(options){_classPrivateFieldInitSpec(this,_handlers,[]);Object.assign(this,options);this._pending=new Map();this._deduped=new Map();}/**\n   * Register a handler to use for primary cache intercept.\n   *\n   * Only one such handler may exist. If using the same\n   * RequestManager as the Store instance the Store\n   * registers itself as a Cache handler.\n   *\n   * @method useCache\n   * @public\n   * @param {Handler[]} cacheHandler\n   * @return {ThisType}\n   */useCache(cacheHandler){{if(this._hasCacheHandler){throw new Error(`\\`RequestManager.useCache(<handler>)\\` May only be invoked once.`);}if(Object.isFrozen(_classPrivateFieldGet(_handlers,this))){throw new Error(`\\`RequestManager.useCache(<handler>)\\` May only be invoked prior to any request having been made.`);}this._hasCacheHandler=true;}cacheHandler[_debug_D0st_bv4_js__WEBPACK_IMPORTED_MODULE_1__.I]=true;_classPrivateFieldGet(_handlers,this).unshift(cacheHandler);return this;}/**\n   * Register handler(s) to use when a request is issued.\n   *\n   * Handlers will be invoked in the order they are registered.\n   * Each Handler is given the opportunity to handle the request,\n   * curry the request, or pass along a modified request.\n   *\n   * @method use\n   * @public\n   * @param {Handler[]} newHandlers\n   * @return {ThisType}\n   */use(newHandlers){const handlers=_classPrivateFieldGet(_handlers,this);{if(Object.isFrozen(handlers)){throw new Error(`Cannot add a Handler to a RequestManager after a request has been made`);}if(!Array.isArray(newHandlers)){throw new Error(`\\`RequestManager.use(<Handler[]>)\\` expects an array of handlers, but was called with \\`${typeof newHandlers}\\``);}newHandlers.forEach((handler,index)=>{if(!handler||typeof handler!=='object'||typeof handler.request!=='function'){throw new Error(`\\`RequestManager.use(<Handler[]>)\\` expected to receive an array of handler objects with request methods, by the handler at index ${index} does not conform.`);}});}handlers.push(...newHandlers);return this;}/**\n   * Issue a Request.\n   *\n   * Returns a Future that fulfills with a StructuredDocument\n   *\n   * @method request\n   * @public\n   * @param {RequestInfo} request\n   * @return {Future}\n   */request(request){const handlers=_classPrivateFieldGet(_handlers,this);{if(!Object.isFrozen(handlers)){Object.freeze(handlers);}(0,_debug_D0st_bv4_js__WEBPACK_IMPORTED_MODULE_1__.a)(request,true);}const controller=request.controller||new AbortController();if(request.controller){delete request.controller;}const requestId=(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_0__.peekUniversalTransient)('REQ_ID')??0;(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_0__.setUniversalTransient)('REQ_ID',requestId+1);const context={controller,response:null,stream:null,hasRequestedStream:false,id:requestId,identifier:null};const promise=(0,_debug_D0st_bv4_js__WEBPACK_IMPORTED_MODULE_1__.e)(handlers,request,0,context);// the cache handler will set the result of the request synchronously\n// if it is able to fulfill the request from the cache\nconst cacheResult=(0,_debug_D0st_bv4_js__WEBPACK_IMPORTED_MODULE_1__.g)(requestId);{if(!request.disableTestWaiter){const{waitForPromise}=(0,_embroider_macros_src_addon_es_compat2__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(__webpack_require__(/*! @ember/test-waiters */ \"@ember/test-waiters\"));const newPromise=waitForPromise(promise);const finalPromise=(0,_debug_D0st_bv4_js__WEBPACK_IMPORTED_MODULE_1__.u)(newPromise.then(result=>{(0,_debug_D0st_bv4_js__WEBPACK_IMPORTED_MODULE_1__.s)(finalPromise,{isError:false,result});(0,_debug_D0st_bv4_js__WEBPACK_IMPORTED_MODULE_1__.c)(requestId);return result;},error=>{(0,_debug_D0st_bv4_js__WEBPACK_IMPORTED_MODULE_1__.s)(finalPromise,{isError:true,result:error});(0,_debug_D0st_bv4_js__WEBPACK_IMPORTED_MODULE_1__.c)(requestId);throw error;}),promise);if(cacheResult){(0,_debug_D0st_bv4_js__WEBPACK_IMPORTED_MODULE_1__.s)(finalPromise,cacheResult);}return finalPromise;}}// const promise1 = store.request(myRequest);\n// const promise2 = store.request(myRequest);\n// promise1 === promise2; // false\n// either we need to make promise1 === promise2, or we need to make sure that\n// we need to have a way to key from request to result\n// such that we can lookup the result here and return it if it exists\nconst finalPromise=(0,_debug_D0st_bv4_js__WEBPACK_IMPORTED_MODULE_1__.u)(promise.then(result=>{(0,_debug_D0st_bv4_js__WEBPACK_IMPORTED_MODULE_1__.s)(finalPromise,{isError:false,result});(0,_debug_D0st_bv4_js__WEBPACK_IMPORTED_MODULE_1__.c)(requestId);return result;},error=>{(0,_debug_D0st_bv4_js__WEBPACK_IMPORTED_MODULE_1__.s)(finalPromise,{isError:true,result:error});(0,_debug_D0st_bv4_js__WEBPACK_IMPORTED_MODULE_1__.c)(requestId);throw error;}),promise);if(cacheResult){(0,_debug_D0st_bv4_js__WEBPACK_IMPORTED_MODULE_1__.s)(finalPromise,cacheResult);}return finalPromise;}static create(options){return new this(options);}}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@ember-data/request/dist/index.js?");

/***/ }),

/***/ "./node_modules/@ember-data/serializer/dist/transform.js":
/*!***************************************************************!*\
  !*** ./node_modules/@ember-data/serializer/dist/transform.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BooleanTransform: () => (/* binding */ BooleanTransform),\n/* harmony export */   DateTransform: () => (/* binding */ DateTransform),\n/* harmony export */   NumberTransform: () => (/* binding */ NumberTransform),\n/* harmony export */   StringTransform: () => (/* binding */ StringTransform),\n/* harmony export */   \"default\": () => (/* binding */ Transform)\n/* harmony export */ });\n/* harmony import */ var _ember_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ember/object */ \"@ember/object\");\n/* harmony import */ var _ember_object__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ember_object__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _warp_drive_core_types_symbols__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @warp-drive/core-types/symbols */ \"./node_modules/@warp-drive/core-types/dist/symbols.js\");\nfunction _defineProperty(e,r,t){return(r=_toPropertyKey(r))in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e;}function _toPropertyKey(t){var i=_toPrimitive(t,\"string\");return\"symbol\"==typeof i?i:i+\"\";}function _toPrimitive(t,r){if(\"object\"!=typeof t||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e.call(t,r||\"default\");if(\"object\"!=typeof i)return i;throw new TypeError(\"@@toPrimitive must return a primitive value.\");}return(\"string\"===r?String:Number)(t);}/**\n  @module @ember-data/serializer\n*//**\n  The `Transform` class is used to serialize and deserialize model\n  attributes when they are saved or loaded from an\n  adapter. Subclassing `Transform` is useful for creating custom\n  attributes. All subclasses of `Transform` must implement a\n  `serialize` and a `deserialize` method.\n\n  Example\n\n  ```app/transforms/temperature.js\n\n  // Converts centigrade in the JSON to fahrenheit in the app\n  export default class TemperatureTransform {\n    deserialize(serialized, options) {\n      return (serialized *  1.8) + 32;\n    }\n\n    serialize(deserialized, options) {\n      return (deserialized - 32) / 1.8;\n    }\n\n    static create() {\n      return new this();\n    }\n  }\n  ```\n\n  Usage\n\n  ```app/models/requirement.js\n  import Model, { attr } from '@ember-data/model';\n\n  export default class RequirementModel extends Model {\n    @attr('string') name;\n    @attr('temperature') temperature;\n  }\n  ```\n\n  The options passed into the `attr` function when the attribute is\n  declared on the model is also available in the transform.\n\n  ```app/models/post.js\n  import Model, { attr } from '@ember-data/model';\n\n  export default class PostModel extends Model {\n    @attr('string') title;\n    @attr('markdown', {\n      markdown: {\n        gfm: false,\n        sanitize: true\n      }\n    })\n    markdown;\n  }\n  ```\n\n  ```app/transforms/markdown.js\n  export default class MarkdownTransform {\n    serialize(deserialized, options) {\n      return deserialized.raw;\n    }\n\n    deserialize(serialized, options) {\n      let markdownOptions = options.markdown || {};\n\n      return marked(serialized, markdownOptions);\n    }\n\n    static create() {\n      return new this();\n    }\n  }\n  ```\n\n  @class Transform\n  @public\n *//**\n  When given a deserialized value from a record attribute this\n  method must return the serialized value.\n\n  Example\n\n  ```javascript\n  serialize(deserialized, options) {\n    return deserialized ? null : Number(deserialized);\n  }\n  ```\n\n  @method serialize\n  @public\n  @param deserialized The deserialized value\n  @param options hash of options passed to `attr`\n  @return The serialized value\n*//**\n  When given a serialized value from a JSON object this method must\n  return the deserialized value for the record attribute.\n\n  Example\n\n  ```javascript\n  deserialize(serialized, options) {\n    return empty(serialized) ? null : Number(serialized);\n  }\n  ```\n\n  @method deserialize\n  @public\n  @param serialized The serialized value\n  @param options hash of options passed to `attr`\n  @return The deserialized value\n*/const Transform=(_ember_object__WEBPACK_IMPORTED_MODULE_0___default());/**\n  @module @ember-data/serializer\n*//**\n  The `BooleanTransform` class is used to serialize and deserialize\n  boolean attributes on Ember Data record objects. This transform is\n  used when `boolean` is passed as the type parameter to the\n  [attr](/ember-data/release/functions/@ember-data%2Fmodel/attr) function.\n\n  Usage\n\n  ```app/models/user.js\n  import Model, { attr } from '@ember-data/model';\n\n  export default class UserModel extends Model {\n    @attr('boolean') isAdmin;\n    @attr('string') name;\n    @attr('string') email;\n  }\n  ```\n\n  By default, the boolean transform only allows for values of `true` or\n  `false`. You can opt into allowing `null` values for\n  boolean attributes via `attr('boolean', { allowNull: true })`\n\n  ```app/models/user.js\n  import Model, { attr } from '@ember-data/model';\n\n  export default class UserModel extends Model {\n    @attr('string') email;\n    @attr('string') username;\n    @attr('boolean', { allowNull: true }) wantsWeeklyEmail;\n  }\n  ```\n\n  @class BooleanTransform\n  @public\n */class BooleanTransform{deserialize(serialized,options){if((serialized===null||serialized===undefined)&&options?.allowNull===true){return null;}if(typeof serialized==='boolean'){return serialized;}else if(typeof serialized==='string'){return /^(true|t|1)$/i.test(serialized);}else if(typeof serialized==='number'){return serialized===1;}else{return false;}}serialize(deserialized,options){if((deserialized===null||deserialized===undefined)&&options?.allowNull===true){return null;}return Boolean(deserialized);}static create(){return new this();}}/**\n  @module @ember-data/serializer\n*//**\n The `DateTransform` class is used to serialize and deserialize\n date attributes on Ember Data record objects. This transform is used\n when `date` is passed as the type parameter to the\n [attr](/ember-data/release/functions/@ember-data%2Fmodel/attr) function. It uses the [`ISO 8601`](https://en.wikipedia.org/wiki/ISO_8601)\n standard.\n\n ```app/models/score.js\n import Model, { attr, belongsTo } from '@ember-data/model';\n\n export default class ScoreModel extends Model {\n    @attr('number') value;\n    @belongsTo('player') player;\n    @attr('date') date;\n  }\n ```\n\n @class DateTransform\n  @public\n */class DateTransform{constructor(){_defineProperty(this,_warp_drive_core_types_symbols__WEBPACK_IMPORTED_MODULE_1__.TransformName,'date');}deserialize(serialized,_options){if(typeof serialized==='string'){let offset=serialized.indexOf('+');if(offset!==-1&&serialized.length-5===offset){offset+=3;return new Date(serialized.slice(0,offset)+':'+serialized.slice(offset));}return new Date(serialized);}else if(typeof serialized==='number'){return new Date(serialized);}else if(serialized===null||serialized===undefined){// if the value is null return null\n// if the value is not present in the data return undefined\nreturn serialized;}else{return null;}}serialize(date,_options){// @ts-expect-error isNaN accepts date as it is coercible\nif(date instanceof Date&&!isNaN(date)){return date.toISOString();}else{return null;}}static create(){return new this();}}/**\n  @module @ember-data/serializer\n*/function isNumber(value){return value===value&&value!==Infinity&&value!==-Infinity;}/**\n  The `NumberTransform` class is used to serialize and deserialize\n  numeric attributes on Ember Data record objects. This transform is\n  used when `number` is passed as the type parameter to the\n  [attr](/ember-data/release/functions/@ember-data%2Fmodel/attr) function.\n\n  Usage\n\n  ```app/models/score.js\n  import Model, { attr, belongsTo } from '@ember-data/model';\n\n  export default class ScoreModel extends Model {\n    @attr('number') value;\n    @belongsTo('player') player;\n    @attr('date') date;\n  }\n  ```\n\n  @class NumberTransform\n  @public\n */class NumberTransform{constructor(){_defineProperty(this,_warp_drive_core_types_symbols__WEBPACK_IMPORTED_MODULE_1__.TransformName,'number');}deserialize(serialized,_options){if(serialized===''||serialized===null||serialized===undefined){return null;}else{const transformed=Number(serialized);return isNumber(transformed)?transformed:null;}}serialize(deserialized,_options){if(deserialized===''||deserialized===null||deserialized===undefined){return null;}else{const transformed=Number(deserialized);return isNumber(transformed)?transformed:null;}}static create(){return new this();}}/**\n  @module @ember-data/serializer\n*//**\n  The `StringTransform` class is used to serialize and deserialize\n  string attributes on Ember Data record objects. This transform is\n  used when `string` is passed as the type parameter to the\n  [attr](/ember-data/release/functions/@ember-data%2Fmodel/attr) function.\n\n  Usage\n\n  ```app/models/user.js\n  import Model, { attr, belongsTo } from '@ember-data/model';\n\n  export default class UserModel extends Model {\n    @attr('boolean') isAdmin;\n    @attr('string') name;\n    @attr('string') email;\n  }\n  ```\n\n  @class StringTransform\n  @public\n */class StringTransform{constructor(){_defineProperty(this,_warp_drive_core_types_symbols__WEBPACK_IMPORTED_MODULE_1__.TransformName,'string');}deserialize(serialized,_options){return!serialized&&serialized!==''?null:String(serialized);}serialize(deserialized,_options){return!deserialized&&deserialized!==''?null:String(deserialized);}static create(){return new this();}}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@ember-data/serializer/dist/transform.js?");

/***/ }),

/***/ "./node_modules/@ember-data/store/dist/-private.js":
/*!*********************************************************!*\
  !*** ./node_modules/@ember-data/store/dist/-private.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ARRAY_SIGNAL: () => (/* reexport safe */ _handler_CET_Ja8V_js__WEBPACK_IMPORTED_MODULE_0__.A),\n/* harmony export */   CacheHandler: () => (/* reexport safe */ _handler_CET_Ja8V_js__WEBPACK_IMPORTED_MODULE_0__.C),\n/* harmony export */   CollectionRecordArray: () => (/* reexport safe */ _handler_CET_Ja8V_js__WEBPACK_IMPORTED_MODULE_0__.j),\n/* harmony export */   LiveArray: () => (/* reexport safe */ _handler_CET_Ja8V_js__WEBPACK_IMPORTED_MODULE_0__.I),\n/* harmony export */   MUTATE: () => (/* reexport safe */ _handler_CET_Ja8V_js__WEBPACK_IMPORTED_MODULE_0__.M),\n/* harmony export */   RecordArrayManager: () => (/* reexport safe */ _handler_CET_Ja8V_js__WEBPACK_IMPORTED_MODULE_0__.R),\n/* harmony export */   SOURCE: () => (/* reexport safe */ _handler_CET_Ja8V_js__WEBPACK_IMPORTED_MODULE_0__.k),\n/* harmony export */   Store: () => (/* reexport safe */ _handler_CET_Ja8V_js__WEBPACK_IMPORTED_MODULE_0__.S),\n/* harmony export */   StoreMap: () => (/* reexport safe */ _handler_CET_Ja8V_js__WEBPACK_IMPORTED_MODULE_0__.q),\n/* harmony export */   _clearCaches: () => (/* reexport safe */ _handler_CET_Ja8V_js__WEBPACK_IMPORTED_MODULE_0__._),\n/* harmony export */   _deprecatingNormalize: () => (/* reexport safe */ _handler_CET_Ja8V_js__WEBPACK_IMPORTED_MODULE_0__.u),\n/* harmony export */   coerceId: () => (/* reexport safe */ _handler_CET_Ja8V_js__WEBPACK_IMPORTED_MODULE_0__.g),\n/* harmony export */   constructResource: () => (/* reexport safe */ _handler_CET_Ja8V_js__WEBPACK_IMPORTED_MODULE_0__.f),\n/* harmony export */   ensureStringId: () => (/* reexport safe */ _handler_CET_Ja8V_js__WEBPACK_IMPORTED_MODULE_0__.h),\n/* harmony export */   fastPush: () => (/* reexport safe */ _handler_CET_Ja8V_js__WEBPACK_IMPORTED_MODULE_0__.l),\n/* harmony export */   isStableIdentifier: () => (/* reexport safe */ _handler_CET_Ja8V_js__WEBPACK_IMPORTED_MODULE_0__.i),\n/* harmony export */   notifyArray: () => (/* reexport safe */ _handler_CET_Ja8V_js__WEBPACK_IMPORTED_MODULE_0__.n),\n/* harmony export */   peekCache: () => (/* reexport safe */ _handler_CET_Ja8V_js__WEBPACK_IMPORTED_MODULE_0__.p),\n/* harmony export */   recordIdentifierFor: () => (/* reexport safe */ _handler_CET_Ja8V_js__WEBPACK_IMPORTED_MODULE_0__.r),\n/* harmony export */   removeRecordDataFor: () => (/* reexport safe */ _handler_CET_Ja8V_js__WEBPACK_IMPORTED_MODULE_0__.m),\n/* harmony export */   setCacheFor: () => (/* reexport safe */ _handler_CET_Ja8V_js__WEBPACK_IMPORTED_MODULE_0__.t),\n/* harmony export */   setRecordIdentifier: () => (/* reexport safe */ _handler_CET_Ja8V_js__WEBPACK_IMPORTED_MODULE_0__.o),\n/* harmony export */   storeFor: () => (/* reexport safe */ _handler_CET_Ja8V_js__WEBPACK_IMPORTED_MODULE_0__.s)\n/* harmony export */ });\n/* harmony import */ var _handler_CET_Ja8V_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./handler-CET_Ja8V.js */ \"./node_modules/@ember-data/store/dist/handler-CET_Ja8V.js\");\n\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@ember-data/store/dist/-private.js?");

/***/ }),

/***/ "./node_modules/@ember-data/store/dist/handler-CET_Ja8V.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@ember-data/store/dist/handler-CET_Ja8V.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ ARRAY_SIGNAL),\n/* harmony export */   C: () => (/* binding */ CacheHandler),\n/* harmony export */   I: () => (/* binding */ IdentifierArray),\n/* harmony export */   M: () => (/* binding */ MUTATE),\n/* harmony export */   R: () => (/* binding */ RecordArrayManager),\n/* harmony export */   S: () => (/* binding */ Store),\n/* harmony export */   _: () => (/* binding */ _clearCaches),\n/* harmony export */   a: () => (/* binding */ setIdentifierGenerationMethod),\n/* harmony export */   b: () => (/* binding */ setIdentifierUpdateMethod),\n/* harmony export */   c: () => (/* binding */ setIdentifierForgetMethod),\n/* harmony export */   d: () => (/* binding */ setIdentifierResetMethod),\n/* harmony export */   e: () => (/* binding */ setKeyInfoForResource),\n/* harmony export */   f: () => (/* binding */ constructResource),\n/* harmony export */   g: () => (/* binding */ coerceId),\n/* harmony export */   h: () => (/* binding */ ensureStringId),\n/* harmony export */   i: () => (/* binding */ isStableIdentifier),\n/* harmony export */   j: () => (/* binding */ Collection),\n/* harmony export */   k: () => (/* binding */ SOURCE),\n/* harmony export */   l: () => (/* binding */ fastPush),\n/* harmony export */   m: () => (/* binding */ removeRecordDataFor),\n/* harmony export */   n: () => (/* binding */ notifyArray),\n/* harmony export */   o: () => (/* binding */ setRecordIdentifier),\n/* harmony export */   p: () => (/* binding */ peekCache),\n/* harmony export */   q: () => (/* binding */ StoreMap),\n/* harmony export */   r: () => (/* binding */ recordIdentifierFor),\n/* harmony export */   s: () => (/* binding */ storeFor),\n/* harmony export */   t: () => (/* binding */ setCacheFor),\n/* harmony export */   u: () => (/* binding */ normalizeModelName)\n/* harmony export */ });\n/* harmony import */ var _ember_debug__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ember/debug */ \"@ember/debug\");\n/* harmony import */ var _ember_debug__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ember_debug__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _warp_drive_core_types_request__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @warp-drive/core-types/request */ \"./node_modules/@warp-drive/core-types/dist/request.js\");\n/* harmony import */ var _warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @warp-drive/core-types/-private */ \"./node_modules/@warp-drive/core-types/dist/-private.js\");\n/* harmony import */ var _warp_drive_core_types_identifier__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @warp-drive/core-types/identifier */ \"./node_modules/@warp-drive/core-types/dist/identifier.js\");\n/* harmony import */ var _ember_data_request_utils_string__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ember-data/request-utils/string */ \"./node_modules/@ember-data/request-utils/dist/string.js\");\n/* harmony import */ var _ember_data_tracking_private__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ember-data/tracking/-private */ \"./node_modules/@ember-data/tracking/dist/-private.js\");\n/* harmony import */ var _ember_runloop__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ember/runloop */ \"@ember/runloop\");\n/* harmony import */ var _ember_runloop__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_ember_runloop__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _ember_data_tracking__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ember-data/tracking */ \"./node_modules/@ember-data/tracking/dist/index.js\");\nvar _IdentifierArray;function _classPrivateMethodInitSpec(e,a){_checkPrivateRedeclaration(e,a),a.add(e);}function _classPrivateFieldInitSpec(e,t,a){_checkPrivateRedeclaration(e,t),t.set(e,a);}function _checkPrivateRedeclaration(e,t){if(t.has(e))throw new TypeError(\"Cannot initialize the same private elements twice on an object\");}function _classPrivateFieldGet(s,a){return s.get(_assertClassBrand(s,a));}function _classPrivateFieldSet(s,a,r){return s.set(_assertClassBrand(s,a),r),r;}function _assertClassBrand(e,t,n){if(\"function\"==typeof e?e===t:e.has(t))return arguments.length<3?t:n;throw new TypeError(\"Private element is not present on this object\");}function _defineProperty(e,r,t){return(r=_toPropertyKey(r))in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e;}function _toPropertyKey(t){var i=_toPrimitive(t,\"string\");return\"symbol\"==typeof i?i:i+\"\";}function _toPrimitive(t,r){if(\"object\"!=typeof t||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e.call(t,r||\"default\");if(\"object\"!=typeof i)return i;throw new TypeError(\"@@toPrimitive must return a primitive value.\");}return(\"string\"===r?String:Number)(t);}/**\n  @module @ember-data/store\n*/function coerceId(id){{let normalized;if(id===null||id===undefined||id===''){normalized=null;}else{normalized=String(id);}(0,_ember_debug__WEBPACK_IMPORTED_MODULE_0__.deprecate)(`The resource id '<${typeof id}> ${String(id)} ' is not normalized. Update your application code to use '${JSON.stringify(normalized)}' instead.`,normalized===id,{id:'ember-data:deprecate-non-strict-id',until:'6.0',for:'ember-data',since:{available:'5.3',enabled:'5.3'}});return normalized;}(test=>{if(!test){throw new Error(`Resource IDs must be a non-empty string or null. Received '${String(id)}'.`);}})(id===null||typeof id==='string'&&id.length>0);return id;}function ensureStringId(id){let normalized=null;if(typeof id==='string'){normalized=id.length>0?id:null;}else if(typeof id==='number'&&!isNaN(id)){normalized=String(id);}(test=>{if(!test){throw new Error(`Expected id to be a string or number, received ${String(id)}`);}})(normalized!==null);return normalized;}function normalizeModelName(type){{const result=(0,_ember_data_request_utils_string__WEBPACK_IMPORTED_MODULE_4__.dasherize)(type);(0,_ember_debug__WEBPACK_IMPORTED_MODULE_0__.deprecate)(`The resource type '${type}' is not normalized. Update your application code to use '${result}' instead of '${type}'.`,result===type,{id:'ember-data:deprecate-non-strict-types',until:'6.0',for:'ember-data',since:{available:'5.3',enabled:'5.3'}});return result;}return type;}/**\n  @module @ember-data/store\n*/function installPolyfill(){const isFastBoot=typeof FastBoot!=='undefined';const CRYPTO=isFastBoot?FastBoot.require('crypto'):globalThis.crypto;if(!CRYPTO.randomUUID){// we might be able to optimize this by requesting more bytes than we need at a time\nconst rng=function(){// WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\nconst rnds8=new Uint8Array(16);if(!CRYPTO.getRandomValues&&!isFastBoot){throw new Error(`Unable to generate bytes for UUID`);}return CRYPTO.getRandomValues?CRYPTO.getRandomValues(rnds8):CRYPTO.randomFillSync(rnds8);};/*\n     * Convert array of 16 byte values to UUID string format of the form:\n     * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n     */const byteToHex=[];for(let i=0;i<256;++i){byteToHex[i]=(i+0x100).toString(16).substr(1);}const bytesToUuid=function(buf){const bth=byteToHex;// join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\nreturn[bth[buf[0]],bth[buf[1]],bth[buf[2]],bth[buf[3]],'-',bth[buf[4]],bth[buf[5]],'-',bth[buf[6]],bth[buf[7]],'-',bth[buf[8]],bth[buf[9]],'-',bth[buf[10]],bth[buf[11]],bth[buf[12]],bth[buf[13]],bth[buf[14]],bth[buf[15]]].join('');};CRYPTO.randomUUID=function uuidv4(){const rnds=rng();// Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\nrnds[6]=rnds[6]&0x0f|0x40;rnds[8]=rnds[8]&0x3f|0x80;return bytesToUuid(rnds);};}}function isResource(resource){return Boolean(resource&&typeof resource==='object');}function hasProp(resource,prop){return Boolean(isResource(resource)&&prop in resource&&typeof resource[prop]==='string'&&resource[prop].length);}function hasLid(resource){return hasProp(resource,'lid');}function hasId(resource){return hasProp(resource,'id')||Boolean(isResource(resource)&&'id'in resource&&typeof resource.id==='number');}function hasType(resource){return hasProp(resource,'type');}/**\n  @module @ember-data/store\n*/const IDENTIFIERS=(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_2__.getOrSetGlobal)('IDENTIFIERS',new Set());const DOCUMENTS=(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_2__.getOrSetGlobal)('DOCUMENTS',new Set());function isStableIdentifier(identifier){return identifier[_warp_drive_core_types_identifier__WEBPACK_IMPORTED_MODULE_3__.CACHE_OWNER]!==undefined||IDENTIFIERS.has(identifier);}function isDocumentIdentifier(identifier){return DOCUMENTS.has(identifier);}const isFastBoot=typeof FastBoot!=='undefined';const _crypto=isFastBoot?FastBoot.require('crypto'):globalThis.crypto;function uuidv4(){(test=>{if(!test){throw new Error('crypto.randomUUID needs to be avaliable. Some browsers incorrectly disallow it in insecure contexts. You maybe want to enable the polyfill: https://github.com/emberjs/data#randomuuid-polyfill');}})(typeof _crypto.randomUUID==='function');return _crypto.randomUUID();}function freeze(obj){if(typeof Object.freeze==='function'){return Object.freeze(obj);}return obj;}// type IdentifierTypeLookup = { all: Set<StableRecordIdentifier>; id: Map<string, StableRecordIdentifier> };\n// type IdentifiersByType = Map<string, IdentifierTypeLookup>;\nfunction setIdentifierGenerationMethod(method){(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_2__.setTransient)('configuredGenerationMethod',method);}function setIdentifierUpdateMethod(method){(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_2__.setTransient)('configuredUpdateMethod',method);}function setIdentifierForgetMethod(method){(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_2__.setTransient)('configuredForgetMethod',method);}function setIdentifierResetMethod(method){(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_2__.setTransient)('configuredResetMethod',method);}function setKeyInfoForResource(method){(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_2__.setTransient)('configuredKeyInfoMethod',method);}// Map<type, Map<id, lid>>\n// TODO can we just delete this?\nconst NEW_IDENTIFIERS=new Map();// TODO @runspired maybe needs peekTransient ?\nlet IDENTIFIER_CACHE_ID=0;function updateTypeIdMapping(typeMap,identifier,id){let idMap=typeMap.get(identifier.type);if(!idMap){idMap=new Map();typeMap.set(identifier.type,idMap);}idMap.set(id,identifier.lid);}function defaultUpdateMethod(identifier,data,bucket){if(bucket==='record'){(test=>{if(!test){throw new Error(`Expected identifier to be a StableRecordIdentifier`);}})(isStableIdentifier(identifier));if(!identifier.id&&hasId(data)){updateTypeIdMapping(NEW_IDENTIFIERS,identifier,data.id);}}}function defaultKeyInfoMethod(resource,known){// TODO RFC something to make this configurable\nconst id=hasId(resource)?coerceId(resource.id):null;const type=hasType(resource)?normalizeModelName(resource.type):known?known.type:null;(test=>{if(!test){throw new Error(`Expected keyInfoForResource to provide a type for the resource`);}})(type);return{type,id};}function defaultGenerationMethod(data,bucket){if(bucket==='record'){if(hasLid(data)){return data.lid;}(test=>{if(!test){throw new Error(`Cannot generate an identifier for a resource without a type`);}})(hasType(data));if(hasId(data)){const type=normalizeModelName(data.type);const lid=NEW_IDENTIFIERS.get(type)?.get(data.id);return lid||`@lid:${type}-${data.id}`;}return uuidv4();}else if(bucket==='document'){if(!data.url){return null;}if(!data.method||data.method.toUpperCase()==='GET'){return data.url;}return null;}(test=>{{throw new Error(`Unknown bucket ${bucket}`);}})();}function defaultEmptyCallback(...args){}function defaultMergeMethod(a,_b,_c){return a;}let DEBUG_MAP;{DEBUG_MAP=(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_2__.getOrSetGlobal)('DEBUG_MAP',new WeakMap());}/**\n * Each instance of {Store} receives a unique instance of a IdentifierCache.\n *\n * This cache is responsible for assigning or retrieving the unique identify\n * for arbitrary resource data encountered by the store. Data representing\n * a unique resource or record should always be represented by the same\n * identifier.\n *\n * It can be configured by consuming applications.\n *\n * @class IdentifierCache\n   @public\n */class IdentifierCache{constructor(){// we cache the user configuredGenerationMethod at init because it must\n// be configured prior and is not allowed to be changed\nthis._generate=(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_2__.peekTransient)('configuredGenerationMethod')||defaultGenerationMethod;this._update=(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_2__.peekTransient)('configuredUpdateMethod')||defaultUpdateMethod;this._forget=(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_2__.peekTransient)('configuredForgetMethod')||defaultEmptyCallback;this._reset=(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_2__.peekTransient)('configuredResetMethod')||defaultEmptyCallback;this._merge=defaultMergeMethod;this._keyInfoForResource=(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_2__.peekTransient)('configuredKeyInfoMethod')||defaultKeyInfoMethod;this._id=IDENTIFIER_CACHE_ID++;this._cache={resources:new Map(),resourcesByType:Object.create(null),documents:new Map(),polymorphicLidBackMap:new Map()};}/**\n   * Internal hook to allow management of merge conflicts with identifiers.\n   *\n   * we allow late binding of this private internal merge so that\n   * the cache can insert itself here to handle elimination of duplicates\n   *\n   * @method __configureMerge\n   * @private\n   */__configureMerge(method){this._merge=method||defaultMergeMethod;}upgradeIdentifier(resource){return this._getRecordIdentifier(resource,2);}/**\n   * @method _getRecordIdentifier\n   * @private\n   */_getRecordIdentifier(resource,shouldGenerate){// short circuit if we're already the stable version\nif(isStableIdentifier(resource)){{// TODO should we instead just treat this case as a new generation skipping the short circuit?\nif(!this._cache.resources.has(resource.lid)||this._cache.resources.get(resource.lid)!==resource){throw new Error(`The supplied identifier ${JSON.stringify(resource)} does not belong to this store instance`);}}return resource;}// the resource is unknown, ask the application to identify this data for us\nconst lid=this._generate(resource,'record');let identifier=/*#__NOINLINE__*/getIdentifierFromLid(this._cache,lid,resource);if(identifier!==null){return identifier;}if(shouldGenerate===0){return;}// if we still don't have an identifier, time to generate one\nif(shouldGenerate===2){resource.lid=lid;resource[_warp_drive_core_types_identifier__WEBPACK_IMPORTED_MODULE_3__.CACHE_OWNER]=this._id;identifier=/*#__NOINLINE__*/makeStableRecordIdentifier(resource,'record',false);}else{// we lie a bit here as a memory optimization\nconst keyInfo=this._keyInfoForResource(resource,null);keyInfo.lid=lid;keyInfo[_warp_drive_core_types_identifier__WEBPACK_IMPORTED_MODULE_3__.CACHE_OWNER]=this._id;identifier=/*#__NOINLINE__*/makeStableRecordIdentifier(keyInfo,'record',false);}addResourceToCache(this._cache,identifier);return identifier;}/**\n   * allows us to peek without generating when needed\n   * useful for the \"create\" case when we need to see if\n   * we are accidentally overwritting something\n   *\n   * @method peekRecordIdentifier\n   * @param resource\n   * @return {StableRecordIdentifier | undefined}\n   * @private\n   */peekRecordIdentifier(resource){return this._getRecordIdentifier(resource,0);}/**\n    Returns the DocumentIdentifier for the given Request, creates one if it does not yet exist.\n    Returns `null` if the request does not have a `cacheKey` or `url`.\n     @method getOrCreateDocumentIdentifier\n    @param request\n    @return {StableDocumentIdentifier | null}\n    @public\n  */getOrCreateDocumentIdentifier(request){let cacheKey=request.cacheOptions?.key;if(!cacheKey){cacheKey=this._generate(request,'document');}if(!cacheKey){return null;}let identifier=this._cache.documents.get(cacheKey);if(identifier===undefined){identifier={lid:cacheKey};{Object.freeze(identifier);}DOCUMENTS.add(identifier);this._cache.documents.set(cacheKey,identifier);}return identifier;}/**\n    Returns the Identifier for the given Resource, creates one if it does not yet exist.\n     Specifically this means that we:\n     - validate the `id` `type` and `lid` combo against known identifiers\n    - return an object with an `lid` that is stable (repeated calls with the same\n      `id` + `type` or `lid` will return the same `lid` value)\n    - this referential stability of the object itself is guaranteed\n     @method getOrCreateRecordIdentifier\n    @param resource\n    @return {StableRecordIdentifier}\n    @public\n  */getOrCreateRecordIdentifier(resource){return this._getRecordIdentifier(resource,1);}/**\n   Returns a new Identifier for the supplied data. Call this method to generate\n   an identifier when a new resource is being created local to the client and\n   potentially does not have an `id`.\n    Delegates generation to the user supplied `GenerateMethod` if one has been provided\n   with the signature `generateMethod({ type }, 'record')`.\n    @method createIdentifierForNewRecord\n   @param data\n   @return {StableRecordIdentifier}\n   @public\n  */createIdentifierForNewRecord(data){const newLid=this._generate(data,'record');const identifier=/*#__NOINLINE__*/makeStableRecordIdentifier({id:data.id||null,type:data.type,lid:newLid,[_warp_drive_core_types_identifier__WEBPACK_IMPORTED_MODULE_3__.CACHE_OWNER]:this._id},'record',true);// populate our unique table\n{if(this._cache.resources.has(identifier.lid)){throw new Error(`The lid generated for the new record is not unique as it matches an existing identifier`);}}/*#__NOINLINE__*/addResourceToCache(this._cache,identifier);return identifier;}/**\n   Provides the opportunity to update secondary lookup tables for existing identifiers\n   Called after an identifier created with `createIdentifierForNewRecord` has been\n   committed.\n    Assigned `id` to an `Identifier` if `id` has not previously existed; however,\n   attempting to change the `id` or calling update without providing an `id` when\n   one is missing will throw an error.\n     - sets `id` (if `id` was previously `null`)\n    - `lid` and `type` MUST NOT be altered post creation\n     If a merge occurs, it is possible the returned identifier does not match the originally\n    provided identifier. In this case the abandoned identifier will go through the usual\n    `forgetRecordIdentifier` codepaths.\n     @method updateRecordIdentifier\n    @param identifierObject\n    @param data\n    @return {StableRecordIdentifier}\n    @public\n  */updateRecordIdentifier(identifierObject,data){let identifier=this.getOrCreateRecordIdentifier(identifierObject);const keyInfo=this._keyInfoForResource(data,identifier);let existingIdentifier=/*#__NOINLINE__*/detectMerge(this._cache,keyInfo,identifier,data);const hadLid=hasLid(data);if(!existingIdentifier){// If the incoming type does not match the identifier type, we need to create an identifier for the incoming\n// data so we can merge the incoming data with the existing identifier, see #7325 and #7363\nif(identifier.type!==keyInfo.type){if(hadLid){// Strip the lid to ensure we force a new identifier creation\ndelete data.lid;}existingIdentifier=this.getOrCreateRecordIdentifier(data);}}if(existingIdentifier){const generatedIdentifier=identifier;identifier=this._mergeRecordIdentifiers(keyInfo,generatedIdentifier,existingIdentifier,data);// make sure that the `lid` on the data we are processing matches the lid we kept\nif(hadLid){data.lid=identifier.lid;}}const id=identifier.id;/*#__NOINLINE__*/performRecordIdentifierUpdate(identifier,keyInfo,data,this._update);const newId=identifier.id;// add to our own secondary lookup table\nif(id!==newId&&newId!==null){const typeSet=this._cache.resourcesByType[identifier.type];(test=>{if(!test){throw new Error(`Expected to find a typeSet for ${identifier.type}`);}})(typeSet);typeSet.id.set(newId,identifier);if(id!==null){typeSet.id.delete(id);}}return identifier;}/**\n   * @method _mergeRecordIdentifiers\n   * @private\n   */_mergeRecordIdentifiers(keyInfo,identifier,existingIdentifier,data){(test=>{if(!test){throw new Error(`Expected keyInfo to contain an id`);}})(hasId(keyInfo));// delegate determining which identifier to keep to the configured MergeMethod\nconst kept=this._merge(identifier,existingIdentifier,data);const abandoned=kept===identifier?existingIdentifier:identifier;// get any backreferences before forgetting this identifier, as it will be removed from the cache\n// and we will no longer be able to find them\nconst abandonedBackReferences=this._cache.polymorphicLidBackMap.get(abandoned.lid);// delete the backreferences for the abandoned identifier so that forgetRecordIdentifier\n// does not try to remove them.\nif(abandonedBackReferences)this._cache.polymorphicLidBackMap.delete(abandoned.lid);// cleanup the identifier we no longer need\nthis.forgetRecordIdentifier(abandoned);// ensure a secondary cache entry for the original lid for the abandoned identifier\nthis._cache.resources.set(abandoned.lid,kept);// backReferences let us know which other identifiers are pointing at this identifier\n// so we can delete them later if we forget this identifier\nconst keptBackReferences=this._cache.polymorphicLidBackMap.get(kept.lid)??[];keptBackReferences.push(abandoned.lid);// update the backreferences from the abandoned identifier to be for the kept identifier\nif(abandonedBackReferences){abandonedBackReferences.forEach(lid=>{keptBackReferences.push(lid);this._cache.resources.set(lid,kept);});}this._cache.polymorphicLidBackMap.set(kept.lid,keptBackReferences);return kept;}/**\n   Provides the opportunity to eliminate an identifier from secondary lookup tables\n   as well as eliminates it from ember-data's own lookup tables and book keeping.\n    Useful when a record has been deleted and the deletion has been persisted and\n   we do not care about the record anymore. Especially useful when an `id` of a\n   deleted record might be reused later for a new record.\n    @method forgetRecordIdentifier\n   @param identifierObject\n   @public\n  */forgetRecordIdentifier(identifierObject){const identifier=this.getOrCreateRecordIdentifier(identifierObject);const typeSet=this._cache.resourcesByType[identifier.type];(test=>{if(!test){throw new Error(`Expected to find a typeSet for ${identifier.type}`);}})(typeSet);if(identifier.id!==null){typeSet.id.delete(identifier.id);}this._cache.resources.delete(identifier.lid);typeSet.lid.delete(identifier.lid);const backReferences=this._cache.polymorphicLidBackMap.get(identifier.lid);if(backReferences){backReferences.forEach(lid=>{this._cache.resources.delete(lid);});this._cache.polymorphicLidBackMap.delete(identifier.lid);}{identifier[_warp_drive_core_types_identifier__WEBPACK_IMPORTED_MODULE_3__.DEBUG_STALE_CACHE_OWNER]=identifier[_warp_drive_core_types_identifier__WEBPACK_IMPORTED_MODULE_3__.CACHE_OWNER];}identifier[_warp_drive_core_types_identifier__WEBPACK_IMPORTED_MODULE_3__.CACHE_OWNER]=undefined;IDENTIFIERS.delete(identifier);this._forget(identifier,'record');}destroy(){NEW_IDENTIFIERS.clear();this._cache.documents.forEach(identifier=>{DOCUMENTS.delete(identifier);});this._reset();}}function makeStableRecordIdentifier(recordIdentifier,bucket,clientOriginated){IDENTIFIERS.add(recordIdentifier);{// we enforce immutability in dev\n//  but preserve our ability to do controlled updates to the reference\nlet wrapper={get lid(){return recordIdentifier.lid;},get id(){return recordIdentifier.id;},get type(){return recordIdentifier.type;},get[_warp_drive_core_types_identifier__WEBPACK_IMPORTED_MODULE_3__.CACHE_OWNER](){return recordIdentifier[_warp_drive_core_types_identifier__WEBPACK_IMPORTED_MODULE_3__.CACHE_OWNER];},set[_warp_drive_core_types_identifier__WEBPACK_IMPORTED_MODULE_3__.CACHE_OWNER](value){recordIdentifier[_warp_drive_core_types_identifier__WEBPACK_IMPORTED_MODULE_3__.CACHE_OWNER]=value;},get[_warp_drive_core_types_identifier__WEBPACK_IMPORTED_MODULE_3__.DEBUG_STALE_CACHE_OWNER](){return recordIdentifier[_warp_drive_core_types_identifier__WEBPACK_IMPORTED_MODULE_3__.DEBUG_STALE_CACHE_OWNER];},set[_warp_drive_core_types_identifier__WEBPACK_IMPORTED_MODULE_3__.DEBUG_STALE_CACHE_OWNER](value){recordIdentifier[_warp_drive_core_types_identifier__WEBPACK_IMPORTED_MODULE_3__.DEBUG_STALE_CACHE_OWNER]=value;}};Object.defineProperty(wrapper,'toString',{enumerable:false,value:()=>{const{type,id,lid}=recordIdentifier;return`${clientOriginated?'[CLIENT_ORIGINATED] ':''}${String(type)}:${String(id)} (${lid})`;}});Object.defineProperty(wrapper,'toJSON',{enumerable:false,value:()=>{const{type,id,lid}=recordIdentifier;return{type,id,lid};}});wrapper[_warp_drive_core_types_identifier__WEBPACK_IMPORTED_MODULE_3__.DEBUG_CLIENT_ORIGINATED]=clientOriginated;wrapper[_warp_drive_core_types_identifier__WEBPACK_IMPORTED_MODULE_3__.DEBUG_IDENTIFIER_BUCKET]=bucket;IDENTIFIERS.add(wrapper);DEBUG_MAP.set(wrapper,recordIdentifier);wrapper=freeze(wrapper);return wrapper;}return recordIdentifier;}function performRecordIdentifierUpdate(identifier,keyInfo,data,updateFn){{const{id,type}=keyInfo;// get the mutable instance behind our proxy wrapper\nconst wrapper=identifier;identifier=DEBUG_MAP.get(wrapper);if(hasLid(data)){const lid=data.lid;if(lid!==identifier.lid){throw new Error(`The 'lid' for a RecordIdentifier cannot be updated once it has been created. Attempted to set lid for '${wrapper.lid}' to '${lid}'.`);}}if(id&&identifier.id!==null&&identifier.id!==id){// here we warn and ignore, as this may be a mistake, but we allow the user\n// to have multiple cache-keys pointing at a single lid so we cannot error\n(0,_ember_debug__WEBPACK_IMPORTED_MODULE_0__.warn)(`The 'id' for a RecordIdentifier should not be updated once it has been set. Attempted to set id for '${wrapper.lid}' to '${id}'.`,false,{id:'ember-data:multiple-ids-for-identifier'});}// TODO consider just ignoring here to allow flexible polymorphic support\nif(type&&type!==identifier.type){throw new Error(`The 'type' for a RecordIdentifier cannot be updated once it has been set. Attempted to set type for '${wrapper.lid}' to '${type}'.`);}updateFn(wrapper,data,'record');}// upgrade the ID, this is a \"one time only\" ability\n// for the multiple-cache-key scenario we \"could\"\n// use a heuristic to guess the best id for display\n// (usually when `data.id` is available and `data.attributes` is not)\nif(data.id!==undefined){identifier.id=coerceId(data.id);}}function detectMerge(cache,keyInfo,identifier,data){const newId=keyInfo.id;const{id,type,lid}=identifier;const typeSet=cache.resourcesByType[identifier.type];// if the IDs are present but do not match\n// then check if we have an existing identifier\n// for the newer ID.\nif(id!==null&&id!==newId&&newId!==null){const existingIdentifier=typeSet&&typeSet.id.get(newId);return existingIdentifier!==undefined?existingIdentifier:false;}else{const newType=keyInfo.type;// If the ids and type are the same but lid is not the same, we should trigger a merge of the identifiers\n// we trigger a merge of the identifiers\n// though probably we should just throw an error here\nif(id!==null&&id===newId&&newType===type&&hasLid(data)&&data.lid!==lid){return getIdentifierFromLid(cache,data.lid,data)||false;// If the lids are the same, and ids are the same, but types are different we should trigger a merge of the identifiers\n}else if(id!==null&&id===newId&&newType&&newType!==type&&hasLid(data)&&data.lid===lid){const newTypeSet=cache.resourcesByType[newType];const existingIdentifier=newTypeSet&&newTypeSet.id.get(newId);return existingIdentifier!==undefined?existingIdentifier:false;}}return false;}function getIdentifierFromLid(cache,lid,resource){const identifier=cache.resources.get(lid);return identifier||null;}function addResourceToCache(cache,identifier){cache.resources.set(identifier.lid,identifier);let typeSet=cache.resourcesByType[identifier.type];if(!typeSet){typeSet={lid:new Map(),id:new Map()};cache.resourcesByType[identifier.type]=typeSet;}typeSet.lid.set(identifier.lid,identifier);if(identifier.id){typeSet.id.set(identifier.id,identifier);}}/**\n  @module @ember-data/store\n*//**\n   A `RecordReference` is a low-level API that allows users and\n   addon authors to perform meta-operations on a record.\n\n   @class RecordReference\n   @public\n*/class RecordReference{constructor(store,identifier){// unsubscribe token given to us by the notification manager\n_defineProperty(this,\"___token\",void 0);_defineProperty(this,\"___identifier\",void 0);this.store=store;this.___identifier=identifier;this.___token=store.notifications.subscribe(identifier,(_,bucket,notifiedKey)=>{if(bucket==='identity'||bucket==='attributes'&&notifiedKey==='id'){this._ref++;}});}destroy(){this.store.notifications.unsubscribe(this.___token);}get type(){return this.identifier().type;}/**\n     The `id` of the record that this reference refers to.\n      Together, the `type` and `id` properties form a composite key for\n     the identity map.\n      Example\n      ```javascript\n     let userRef = store.getReference('user', 1);\n      userRef.id(); // '1'\n     ```\n      @method id\n    @public\n     @return {String} The id of the record.\n  */id(){// eslint-disable-next-line @typescript-eslint/no-unused-expressions\nthis._ref;// consume the tracked prop\nreturn this.___identifier.id;}/**\n     The `identifier` of the record that this reference refers to.\n      Together, the `type` and `id` properties form a composite key for\n     the identity map.\n      Example\n      ```javascript\n     let userRef = store.getReference('user', 1);\n      userRef.identifier(); // '1'\n     ```\n      @method identifier\n    @public\n     @return {String} The identifier of the record.\n  */identifier(){return this.___identifier;}/**\n     How the reference will be looked up when it is loaded. Currently\n     this always returns `identity` to signify that a record will be\n     loaded by its `type` and `id`.\n      Example\n      ```javascript\n     const userRef = store.getReference('user', 1);\n      userRef.remoteType(); // 'identity'\n     ```\n      @method remoteType\n     @public\n     @return {String} 'identity'\n  */remoteType(){return'identity';}/**\n    This API allows you to provide a reference with new data. The\n    simplest usage of this API is similar to `store.push`: you provide a\n    normalized hash of data and the object represented by the reference\n    will update.\n     If you pass a promise to `push`, Ember Data will not ask the adapter\n    for the data if another attempt to fetch it is made in the\n    interim. When the promise resolves, the underlying object is updated\n    with the new data, and the promise returned by *this function* is resolved\n    with that object.\n     For example, `recordReference.push(promise)` will be resolved with a\n    record.\n      Example\n      ```javascript\n     let userRef = store.getReference('user', 1);\n      // provide data for reference\n     userRef.push({\n       data: {\n         id: \"1\",\n         type: \"user\",\n         attributes: {\n           username: \"@user\"\n         }\n       }\n     }).then(function(user) {\n       userRef.value() === user;\n     });\n     ```\n     @method push\n    @public\n    @param objectOrPromise a JSON:API ResourceDocument or a promise resolving to one\n    @return a promise for the value (record or relationship)\n  */push(objectOrPromise){// TODO @deprecate pushing unresolved payloads\nreturn Promise.resolve(objectOrPromise).then(data=>{return this.store.push(data);});}/**\n    If the entity referred to by the reference is already loaded, it is\n    present as `reference.value`. Otherwise the value returned by this function\n    is `null`.\n      Example\n      ```javascript\n     let userRef = store.getReference('user', 1);\n      userRef.value(); // user\n     ```\n      @method value\n    @public\n     @return {Model} the record for this RecordReference\n  */value(){return this.store.peekRecord(this.___identifier);}/**\n     Triggers a fetch for the backing entity based on its `remoteType`\n     (see `remoteType` definitions per reference type).\n      Example\n      ```javascript\n     let userRef = store.getReference('user', 1);\n      // load user (via store.find)\n     userRef.load().then(...)\n     ```\n      @method load\n    @public\n     @return {Promise<record>} the record for this RecordReference\n  */load(){const id=this.id();if(id!==null){return this.store.findRecord(this.type,id);}(test=>{{throw new Error(`Unable to fetch record of type ${this.type} without an id`);}})();}/**\n     Reloads the record if it is already loaded. If the record is not\n     loaded it will load the record via `store.findRecord`\n      Example\n      ```javascript\n     let userRef = store.getReference('user', 1);\n      // or trigger a reload\n     userRef.reload().then(...)\n     ```\n      @method reload\n    @public\n     @return {Promise<record>} the record for this RecordReference\n  */reload(){const id=this.id();if(id!==null){return this.store.findRecord(this.type,id,{reload:true});}(test=>{{throw new Error(`Unable to fetch record of type ${this.type} without an id`);}})();}}(0,_ember_data_tracking_private__WEBPACK_IMPORTED_MODULE_5__.defineSignal)(RecordReference.prototype,'_ref');/**\n  @module @ember-data/store\n*/class CacheCapabilitiesManager{constructor(_store){this._store=_store;this._willNotify=false;this._pendingNotifies=new Map();}get identifierCache(){return this._store.identifierCache;}_scheduleNotification(identifier,key){let pending=this._pendingNotifies.get(identifier);if(!pending){pending=new Set();this._pendingNotifies.set(identifier,pending);}pending.add(key);if(this._willNotify===true){return;}this._willNotify=true;// it's possible a cache adhoc notifies us,\n// in which case we sync flush\nif(this._store._cbs){this._store._schedule('notify',()=>this._flushNotifications());}else{// TODO @runspired determine if relationship mutations should schedule\n// into join/run vs immediate flush\nthis._flushNotifications();}}_flushNotifications(){if(this._willNotify===false){return;}const pending=this._pendingNotifies;this._pendingNotifies=new Map();this._willNotify=false;pending.forEach((set,identifier)=>{set.forEach(key=>{this._store.notifications.notify(identifier,'relationships',key);});});}notifyChange(identifier,namespace,key){(test=>{if(!test){throw new Error(`Expected a stable identifier`);}})(isStableIdentifier(identifier)||isDocumentIdentifier(identifier));// TODO do we still get value from this?\nif(namespace==='relationships'&&key){this._scheduleNotification(identifier,key);return;}// @ts-expect-error\nthis._store.notifications.notify(identifier,namespace,key);}get schema(){return this._store.schema;}setRecordId(identifier,id){(test=>{if(!test){throw new Error(`Expected a stable identifier`);}})(isStableIdentifier(identifier));this._store._instanceCache.setRecordId(identifier,id);}hasRecord(identifier){return Boolean(this._store._instanceCache.peek(identifier));}disconnectRecord(identifier){(test=>{if(!test){throw new Error(`Expected a stable identifier`);}})(isStableIdentifier(identifier));this._store._instanceCache.disconnect(identifier);this._pendingNotifies.delete(identifier);}}{CacheCapabilitiesManager.prototype.getSchemaDefinitionService=function(){// FIXME add deprecation for this\nreturn this._store.schema;};}/*\n * Returns the Cache instance associated with a given\n * Model or Identifier\n */const CacheForIdentifierCache=(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_2__.getOrSetGlobal)('CacheForIdentifierCache',new Map());function setCacheFor(identifier,cache){(test=>{if(!test){throw new Error(`Illegal set of identifier`);}})(!CacheForIdentifierCache.has(identifier)||CacheForIdentifierCache.get(identifier)===cache);CacheForIdentifierCache.set(identifier,cache);}function removeRecordDataFor(identifier){CacheForIdentifierCache.delete(identifier);}function peekCache(instance){if(CacheForIdentifierCache.has(instance)){return CacheForIdentifierCache.get(instance);}return null;}function isDestroyable(record){return Boolean(record&&typeof record==='object'&&typeof record.destroy==='function');}/**\n  @module @ember-data/store\n*/const RecordCache=(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_2__.getOrSetGlobal)('RecordCache',new Map());function peekRecordIdentifier(record){return RecordCache.get(record);}/**\n  Retrieves the unique referentially-stable [RecordIdentifier](/ember-data/release/classes/StableRecordIdentifier)\n  assigned to the given record instance.\n  ```js\n  import { recordIdentifierFor } from \"@ember-data/store\";\n  // ... gain access to a record, for instance with peekRecord or findRecord\n  const record = store.peekRecord(\"user\", \"1\");\n  // get the identifier for the record (see docs for StableRecordIdentifier)\n  const identifier = recordIdentifierFor(record);\n  // access the identifier's properties.\n  const { id, type, lid } = identifier;\n  ```\n  @method recordIdentifierFor\n  @public\n  @static\n  @for @ember-data/store\n  @param {Object} record a record instance previously obstained from the store.\n  @return {StableRecordIdentifier}\n */function recordIdentifierFor(record){(test=>{if(!test){throw new Error(`${String(record)} is not a record instantiated by @ember-data/store`);}})(RecordCache.has(record));return RecordCache.get(record);}function setRecordIdentifier(record,identifier){{if(RecordCache.has(record)&&RecordCache.get(record)!==identifier){throw new Error(`${String(record)} was already assigned an identifier`);}}/*\n  It would be nice to do a reverse check here that an identifier has not\n  previously been assigned a record; however, unload + rematerialization\n  prevents us from having a great way of doing so when CustomRecordClasses\n  don't necessarily give us access to a `isDestroyed` for dematerialized\n  instance.\n  */RecordCache.set(record,identifier);}const StoreMap=(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_2__.getOrSetGlobal)('StoreMap',new Map());function storeFor(record){const store=StoreMap.get(record);(test=>{if(!test){throw new Error(`A record in a disconnected state cannot utilize the store. This typically means the record has been destroyed, most commonly by unloading it.`);}})(store);return store;}class InstanceCache{constructor(store){_defineProperty(this,\"__instances\",{record:new Map(),reference:new WeakMap()});this.store=store;this._storeWrapper=new CacheCapabilitiesManager(this.store);store.identifierCache.__configureMerge((identifier,matchedIdentifier,resourceData)=>{let keptIdentifier=identifier;if(identifier.id!==matchedIdentifier.id){// @ts-expect-error TODO this needs to be fixed\nkeptIdentifier='id'in resourceData&&identifier.id===resourceData.id?identifier:matchedIdentifier;}else if(identifier.type!==matchedIdentifier.type){keptIdentifier=// @ts-expect-error TODO this needs to be fixed\n'type'in resourceData&&identifier.type===resourceData.type?identifier:matchedIdentifier;}const staleIdentifier=identifier===keptIdentifier?matchedIdentifier:identifier;// check for duplicate entities\nconst keptHasRecord=this.__instances.record.has(keptIdentifier);const staleHasRecord=this.__instances.record.has(staleIdentifier);// we cannot merge entities when both have records\n// (this may not be strictly true, we could probably swap the cache data the record points at)\nif(keptHasRecord&&staleHasRecord){// TODO we probably don't need to throw these errors anymore\n// we can probably just \"swap\" what data source the abandoned\n// record points at so long as\n// it itself is not retained by the store in any way.\n// @ts-expect-error TODO this needs to be fixed\nif('id'in resourceData){throw new Error(`Failed to update the 'id' for the RecordIdentifier '${identifier.type}:${String(identifier.id)} (${identifier.lid})' to '${String(resourceData.id)}', because that id is already in use by '${matchedIdentifier.type}:${String(matchedIdentifier.id)} (${matchedIdentifier.lid})'`);}(test=>{{throw new Error(`Failed to update the RecordIdentifier '${identifier.type}:${String(identifier.id)} (${identifier.lid})' to merge with the detected duplicate identifier '${matchedIdentifier.type}:${String(matchedIdentifier.id)} (${String(matchedIdentifier.lid)})'`);}})();}this.store.cache.patch({op:'mergeIdentifiers',record:staleIdentifier,value:keptIdentifier});/*\n      TODO @runspired consider adding this to make polymorphism even nicer\n      if (identifier.type !== matchedIdentifier.type) {\n      this.store._graph?.registerPolymorphicType(identifier.type, matchedIdentifier.type);\n      }\n      */this.unloadRecord(staleIdentifier);return keptIdentifier;});}peek(identifier){return this.__instances.record.get(identifier);}getRecord(identifier,properties){let record=this.__instances.record.get(identifier);if(!record){(test=>{if(!test){throw new Error(`Cannot create a new record instance while the store is being destroyed`);}})(!this.store.isDestroying&&!this.store.isDestroyed);const cache=this.store.cache;setCacheFor(identifier,cache);record=this.store.instantiateRecord(identifier,properties||{});setRecordIdentifier(record,identifier);setCacheFor(record,cache);StoreMap.set(record,this.store);this.__instances.record.set(identifier,record);}return record;}getReference(identifier){const cache=this.__instances.reference;let reference=cache.get(identifier);if(!reference){reference=new RecordReference(this.store,identifier);cache.set(identifier,reference);}return reference;}recordIsLoaded(identifier,filterDeleted=false){const cache=this.cache;if(!cache){return false;}const isNew=cache.isNew(identifier);const isEmpty=cache.isEmpty(identifier);// if we are new we must consider ourselves loaded\nif(isNew){return!cache.isDeleted(identifier);}// even if we have a past request, if we are now empty we are not loaded\n// typically this is true after an unloadRecord call\n// if we are not empty, not new && we have a fulfilled request then we are loaded\n// we should consider allowing for something to be loaded that is simply \"not empty\".\n// which is how RecordState currently handles this case; however, RecordState is buggy\n// in that it does not account for unloading.\nreturn filterDeleted&&cache.isDeletionCommitted(identifier)?false:!isEmpty;}disconnect(identifier){const record=this.__instances.record.get(identifier);(test=>{if(!test){throw new Error('Cannot destroy record while it is still materialized');}})(!isDestroyable(record)||record.isDestroyed||record.isDestroying);this.store._graph?.remove(identifier);this.store.identifierCache.forgetRecordIdentifier(identifier);removeRecordDataFor(identifier);this.store._requestCache._clearEntries(identifier);}unloadRecord(identifier){{const requests=this.store.getRequestStateService().getPendingRequestsForRecord(identifier);if(requests.some(req=>{return req.type==='mutation';})){(test=>{{throw new Error(`You can only unload a record which is not inFlight. '${String(identifier)}'`);}})();}}// TODO is this join still necessary?\nthis.store._join(()=>{const record=this.__instances.record.get(identifier);const cache=this.cache;if(record){this.store.teardownRecord(record);this.__instances.record.delete(identifier);StoreMap.delete(record);RecordCache.delete(record);removeRecordDataFor(record);}if(cache){cache.unloadRecord(identifier);removeRecordDataFor(identifier);}else{this.disconnect(identifier);}this.store._requestCache._clearEntries(identifier);});}clear(type){const cache=this.store.identifierCache._cache;if(type===undefined){// it would be cool if we could just de-ref cache here\n// but probably would require WeakRef models to do so.\ncache.resources.forEach(identifier=>{this.unloadRecord(identifier);});}else{const typeCache=cache.resourcesByType;const identifiers=typeCache[type]?.lid;if(identifiers){identifiers.forEach(identifier=>{// if (rds.has(identifier)) {\nthis.unloadRecord(identifier);// }\n// TODO we don't remove the identifier, should we?\n});}}}// TODO this should move into something coordinating operations\nsetRecordId(identifier,id){const{type,lid}=identifier;const oldId=identifier.id;// ID absolutely can't be missing if the oldID is empty (missing Id in response for a new record)\n(test=>{if(!test){throw new Error(`'${type}' was saved to the server, but the response does not have an id and your record does not either.`);}})(!(id===null&&oldId===null));// ID absolutely can't be different than oldID if oldID is not null\n// TODO this assertion and restriction may not strictly be needed in the identifiers world\n(test=>{if(!test){throw new Error(`Cannot update the id for '${type}:${lid}' from '${String(oldId)}' to '${id}'.`);}})(!(oldId!==null&&id!==oldId));// ID can be null if oldID is not null (altered ID in response for a record)\n// however, this is more than likely a developer error.\nif(oldId!==null&&id===null){(0,_ember_debug__WEBPACK_IMPORTED_MODULE_0__.warn)(`Your ${type} record was saved to the server, but the response does not have an id.`,!(oldId!==null&&id===null));return;}const existingIdentifier=this.store.identifierCache.peekRecordIdentifier({type,id});(test=>{if(!test){throw new Error(`'${type}' was saved to the server, but the response returned the new id '${id}', which has already been used with another record.'`);}})(!existingIdentifier||existingIdentifier===identifier);if(identifier.id===null){// TODO potentially this needs to handle merged result\nthis.store.identifierCache.updateRecordIdentifier(identifier,{type,id});}// TODO update resource cache if needed ?\n// TODO handle consequences of identifier merge for notifications\nthis.store.notifications.notify(identifier,'identity');}}function _resourceIsFullDeleted(identifier,cache){return cache.isDeletionCommitted(identifier)||cache.isNew(identifier)&&cache.isDeleted(identifier);}function resourceIsFullyDeleted(instanceCache,identifier){const cache=instanceCache.cache;return!cache||_resourceIsFullDeleted(identifier,cache);}/*\n    When a find request is triggered on the store, the user can optionally pass in\n    attributes and relationships to be preloaded. These are meant to behave as if they\n    came back from the server, except the user obtained them out of band and is informing\n    the store of their existence. The most common use case is for supporting client side\n    nested URLs, such as `/posts/1/comments/2` so the user can do\n    `store.findRecord('comment', 2, { preload: { post: 1 } })` without having to fetch the post.\n\n    Preloaded data can be attributes and relationships passed in either as IDs or as actual\n    models.\n  */function preloadData(store,identifier,preload){const jsonPayload={};//TODO(Igor) consider the polymorphic case\nconst schemas=store.schema;const fields=schemas.fields(identifier);Object.keys(preload).forEach(key=>{const preloadValue=preload[key];const field=fields.get(key);if(field&&(field.kind==='hasMany'||field.kind==='belongsTo')){if(!jsonPayload.relationships){jsonPayload.relationships={};}jsonPayload.relationships[key]=preloadRelationship(field,preloadValue);}else{if(!jsonPayload.attributes){jsonPayload.attributes={};}jsonPayload.attributes[key]=preloadValue;}});const cache=store.cache;const hasRecord=Boolean(store._instanceCache.peek(identifier));cache.upsert(identifier,jsonPayload,hasRecord);}function preloadRelationship(schema,preloadValue){const relatedType=schema.type;if(schema.kind==='hasMany'){(test=>{if(!test){throw new Error('You need to pass in an array to set a hasMany property on a record');}})(Array.isArray(preloadValue));return{data:preloadValue.map(value=>_convertPreloadRelationshipToJSON(value,relatedType))};}(test=>{if(!test){throw new Error('You should not pass in an array to set a belongsTo property on a record');}})(!Array.isArray(preloadValue));return{data:preloadValue?_convertPreloadRelationshipToJSON(preloadValue,relatedType):null};}/*\n  findRecord('user', '1', { preload: { friends: ['1'] }});\n  findRecord('user', '1', { preload: { friends: [record] }});\n*/function _convertPreloadRelationshipToJSON(value,type){if(typeof value==='string'||typeof value==='number'){return{type,id:ensureStringId(value)};}// TODO if not a record instance assert it's an identifier\n// and allow identifiers to be used\nreturn recordIdentifierFor(value);}function _clearCaches(){RecordCache.clear();StoreMap.clear();CacheForIdentifierCache.clear();}// if modelFor turns out to be a bottleneck we should replace with a Map\n// and clear it during store teardown.\nconst AvailableShims=(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_2__.getOrSetGlobal)('AvailableShims',new WeakMap());function getShimClass(store,modelName){let shims=AvailableShims.get(store);if(!shims){shims=Object.create(null);AvailableShims.set(store,shims);}let shim=shims[modelName];if(shim===undefined){shim=shims[modelName]=new ShimModelClass(store,modelName);}return shim;}// Mimics the static apis of @ember-data/model\nclass ShimModelClass{constructor(store,modelName){this.__store=store;this.modelName=modelName;}get fields(){const fields=new Map();const fieldSchemas=this.__store.schema.fields({type:this.modelName});fieldSchemas.forEach((schema,key)=>{if(schema.kind==='attribute'||schema.kind==='belongsTo'||schema.kind==='hasMany'){fields.set(key,schema.kind);}});return fields;}get attributes(){const attrs=new Map();const fields=this.__store.schema.fields({type:this.modelName});fields.forEach((schema,key)=>{if(schema.kind==='attribute'){attrs.set(key,schema);}});return attrs;}get relationshipsByName(){const rels=new Map();const fields=this.__store.schema.fields({type:this.modelName});fields.forEach((schema,key)=>{if(schema.kind==='belongsTo'||schema.kind==='hasMany'){rels.set(key,schema);}});return rels;}eachAttribute(callback,binding){this.__store.schema.fields({type:this.modelName}).forEach((schema,key)=>{if(schema.kind==='attribute'){callback.call(binding,key,schema);}});}eachRelationship(callback,binding){this.__store.schema.fields({type:this.modelName}).forEach((schema,key)=>{if(schema.kind==='belongsTo'||schema.kind==='hasMany'){callback.call(binding,key,schema);}});}eachTransformedAttribute(callback,binding){this.__store.schema.fields({type:this.modelName}).forEach((schema,key)=>{if(schema.kind==='attribute'){const type=schema.type;if(type)callback.call(binding,key,type);}});}}/**\n * The CacheManager wraps a Cache enforcing that only\n * the public API surface area is exposed.\n *\n * Hence, it is the value of `Store.cache`, wrapping\n * the cache instance returned by `Store.createCache`.\n *\n * It handles translating between cache versions when\n * necessary, for instance when a Store is configured\n * to use both a v1 and a v2 cache depending on some\n * heuristic.\n *\n * Starting with the v2 spec, the cache is designed such\n * that it must be implemented as a singleton.\n *\n * @class CacheManager\n * @public\n */var _cache=/*#__PURE__*/new WeakMap();class CacheManager{constructor(cache){_defineProperty(this,\"version\",'2');_classPrivateFieldInitSpec(this,_cache,void 0);_classPrivateFieldSet(_cache,this,cache);}// Cache Management\n// ================\n/**\n   * Cache the response to a request\n   *\n   * Unlike `store.push` which has UPSERT\n   * semantics, `put` has `replace` semantics similar to\n   * the `http` method `PUT`\n   *\n   * the individually cacheable\n   * e resource data it may contain\n   * should upsert, but the document data surrounding it should\n   * fully replace any existing information\n   *\n   * Note that in order to support inserting arbitrary data\n   * to the cache that did not originate from a request `put`\n   * should expect to sometimes encounter a document with only\n   * a `content` member and therefor must not assume the existence\n   * of `request` and `response` on the document.\n   *\n   * @method put\n   * @param {StructuredDocument} doc\n   * @return {ResourceDocument}\n   * @public\n   */put(doc){return _classPrivateFieldGet(_cache,this).put(doc);}/**\n   * Perform an operation on the cache to update the remote state.\n   *\n   * Note: currently the only valid operation is a MergeOperation\n   * which occurs when a collision of identifiers is detected.\n   *\n   * @method patch\n   * @public\n   * @param op the operation to perform\n   * @return {void}\n   */patch(op){_classPrivateFieldGet(_cache,this).patch(op);}/**\n   * Update resource data with a local mutation. Currently supports operations\n   * on relationships only.\n   *\n   * @method mutate\n   * @public\n   * @param mutation\n   */mutate(mutation){_classPrivateFieldGet(_cache,this).mutate(mutation);}/**\n   * Peek resource data from the Cache.\n   *\n   * In development, if the return value\n   * is JSON the return value\n   * will be deep-cloned and deep-frozen\n   * to prevent mutation thereby enforcing cache\n   * Immutability.\n   *\n   * This form of peek is useful for implementations\n   * that want to feed raw-data from cache to the UI\n   * or which want to interact with a blob of data\n   * directly from the presentation cache.\n   *\n   * An implementation might want to do this because\n   * de-referencing records which read from their own\n   * blob is generally safer because the record does\n   * not require retaining connections to the Store\n   * and Cache to present data on a per-field basis.\n   *\n   * This generally takes the place of `getAttr` as\n   * an API and may even take the place of `getRelationship`\n   * depending on implementation specifics, though this\n   * latter usage is less recommended due to the advantages\n   * of the Graph handling necessary entanglements and\n   * notifications for relational data.\n   *\n   * @method peek\n   * @public\n   * @param {StableRecordIdentifier | StableDocumentIdentifier} identifier\n   * @return {ResourceDocument | ResourceBlob | null} the known resource data\n   */peek(identifier){return _classPrivateFieldGet(_cache,this).peek(identifier);}/**\n   * Peek the Cache for the existing request data associated with\n   * a cacheable request\n   *\n   * @method peekRequest\n   * @param {StableDocumentIdentifier}\n   * @return {StableDocumentIdentifier | null}\n   * @public\n   */peekRequest(identifier){return _classPrivateFieldGet(_cache,this).peekRequest(identifier);}/**\n   * Push resource data from a remote source into the cache for this identifier\n   *\n   * @method upsert\n   * @public\n   * @param identifier\n   * @param data\n   * @param hasRecord\n   * @return {void | string[]} if `hasRecord` is true then calculated key changes should be returned\n   */upsert(identifier,data,hasRecord){return _classPrivateFieldGet(_cache,this).upsert(identifier,data,hasRecord);}// Cache Forking Support\n// =====================\n/**\n   * Create a fork of the cache from the current state.\n   *\n   * Applications should typically not call this method themselves,\n   * preferring instead to fork at the Store level, which will\n   * utilize this method to fork the cache.\n   *\n   * @method fork\n   * @public\n   * @return Promise<Cache>\n   */fork(){return _classPrivateFieldGet(_cache,this).fork();}/**\n   * Merge a fork back into a parent Cache.\n   *\n   * Applications should typically not call this method themselves,\n   * preferring instead to merge at the Store level, which will\n   * utilize this method to merge the caches.\n   *\n   * @method merge\n   * @param {Cache} cache\n   * @public\n   * @return Promise<void>\n   */merge(cache){return _classPrivateFieldGet(_cache,this).merge(cache);}/**\n   * Generate the list of changes applied to all\n   * record in the store.\n   *\n   * Each individual resource or document that has\n   * been mutated should be described as an individual\n   * `Change` entry in the returned array.\n   *\n   * A `Change` is described by an object containing up to\n   * three properties: (1) the `identifier` of the entity that\n   * changed; (2) the `op` code of that change being one of\n   * `upsert` or `remove`, and if the op is `upsert` a `patch`\n   * containing the data to merge into the cache for the given\n   * entity.\n   *\n   * This `patch` is opaque to the Store but should be understood\n   * by the Cache and may expect to be utilized by an Adapter\n   * when generating data during a `save` operation.\n   *\n   * It is generally recommended that the `patch` contain only\n   * the updated state, ignoring fields that are unchanged\n   *\n   * ```ts\n   * interface Change {\n   *  identifier: StableRecordIdentifier | StableDocumentIdentifier;\n   *  op: 'upsert' | 'remove';\n   *  patch?: unknown;\n   * }\n   * ```\n   *\n   * @method diff\n   * @public\n   */diff(){return _classPrivateFieldGet(_cache,this).diff();}// SSR Support\n// ===========\n/**\n   * Serialize the entire contents of the Cache into a Stream\n   * which may be fed back into a new instance of the same Cache\n   * via `cache.hydrate`.\n   *\n   * @method dump\n   * @return {Promise<ReadableStream>}\n   * @public\n   */dump(){return _classPrivateFieldGet(_cache,this).dump();}/**\n   * hydrate a Cache from a Stream with content previously serialized\n   * from another instance of the same Cache, resolving when hydration\n   * is complete.\n   *\n   * This method should expect to be called both in the context of restoring\n   * the Cache during application rehydration after SSR **AND** at unknown\n   * times during the lifetime of an already booted application when it is\n   * desired to bulk-load additional information into the cache. This latter\n   * behavior supports optimizing pre/fetching of data for route transitions\n   * via data-only SSR modes.\n   *\n   * @method hydrate\n   * @param {ReadableStream} stream\n   * @return {Promise<void>}\n   * @public\n   */hydrate(stream){return _classPrivateFieldGet(_cache,this).hydrate(stream);}// Cache\n// =====\n// Resource Support\n// ================\n/**\n   * [LIFECYCLE] Signal to the cache that a new record has been instantiated on the client\n   *\n   * It returns properties from options that should be set on the record during the create\n   * process. This return value behavior is deprecated.\n   *\n   * @method clientDidCreate\n   * @public\n   * @param identifier\n   * @param options\n   */clientDidCreate(identifier,options){return _classPrivateFieldGet(_cache,this).clientDidCreate(identifier,options);}/**\n   * [LIFECYCLE] Signals to the cache that a resource\n   * will be part of a save transaction.\n   *\n   * @method willCommit\n   * @public\n   * @param identifier\n   */willCommit(identifier,context){_classPrivateFieldGet(_cache,this).willCommit(identifier,context);}/**\n   * [LIFECYCLE] Signals to the cache that a resource\n   * was successfully updated as part of a save transaction.\n   *\n   * @method didCommit\n   * @public\n   * @param identifier\n   * @param data\n   */didCommit(identifier,result){return _classPrivateFieldGet(_cache,this).didCommit(identifier,result);}/**\n   * [LIFECYCLE] Signals to the cache that a resource\n   * was update via a save transaction failed.\n   *\n   * @method commitWasRejected\n   * @public\n   * @param identifier\n   * @param errors\n   */commitWasRejected(identifier,errors){_classPrivateFieldGet(_cache,this).commitWasRejected(identifier,errors);}/**\n   * [LIFECYCLE] Signals to the cache that all data for a resource\n   * should be cleared.\n   *\n   * @method unloadRecord\n   * @public\n   * @param identifier\n   */unloadRecord(identifier){_classPrivateFieldGet(_cache,this).unloadRecord(identifier);}// Granular Resource Data APIs\n// ===========================\n/**\n   * Retrieve the data for an attribute from the cache\n   *\n   * @method getAttr\n   * @public\n   * @param identifier\n   * @param propertyName\n   * @return {unknown}\n   */getAttr(identifier,propertyName){return _classPrivateFieldGet(_cache,this).getAttr(identifier,propertyName);}/**\n   * Mutate the data for an attribute in the cache\n   *\n   * @method setAttr\n   * @public\n   * @param identifier\n   * @param propertyName\n   * @param value\n   */setAttr(identifier,propertyName,value){_classPrivateFieldGet(_cache,this).setAttr(identifier,propertyName,value);}/**\n   * Query the cache for the changed attributes of a resource.\n   *\n   * @method changedAttrs\n   * @public\n   * @param identifier\n   * @return\n   */changedAttrs(identifier){return _classPrivateFieldGet(_cache,this).changedAttrs(identifier);}/**\n   * Query the cache for whether any mutated attributes exist\n   *\n   * @method hasChangedAttrs\n   * @public\n   * @param identifier\n   * @return {boolean}\n   */hasChangedAttrs(identifier){return _classPrivateFieldGet(_cache,this).hasChangedAttrs(identifier);}/**\n   * Tell the cache to discard any uncommitted mutations to attributes\n   *\n   * @method rollbackAttrs\n   * @public\n   * @param identifier\n   * @return the names of attributes that were restored\n   */rollbackAttrs(identifier){return _classPrivateFieldGet(_cache,this).rollbackAttrs(identifier);}// Relationships\n// =============\n/**\n   * Query the cache for the changes to relationships of a resource.\n   *\n   * Returns a map of relationship names to RelationshipDiff objects.\n   *\n   * ```ts\n   * type RelationshipDiff =\n  | {\n      kind: 'collection';\n      remoteState: StableRecordIdentifier[];\n      additions: Set<StableRecordIdentifier>;\n      removals: Set<StableRecordIdentifier>;\n      localState: StableRecordIdentifier[];\n      reordered: boolean;\n    }\n  | {\n      kind: 'resource';\n      remoteState: StableRecordIdentifier | null;\n      localState: StableRecordIdentifier | null;\n    };\n    ```\n   *\n   * @method changedRelationships\n   * @public\n   * @param {StableRecordIdentifier} identifier\n   * @return {Map<string, RelationshipDiff>}\n   */changedRelationships(identifier){return _classPrivateFieldGet(_cache,this).changedRelationships(identifier);}/**\n   * Query the cache for whether any mutated attributes exist\n   *\n   * @method hasChangedRelationships\n   * @public\n   * @param {StableRecordIdentifier} identifier\n   * @return {boolean}\n   */hasChangedRelationships(identifier){return _classPrivateFieldGet(_cache,this).hasChangedRelationships(identifier);}/**\n   * Tell the cache to discard any uncommitted mutations to relationships.\n   *\n   * This will also discard the change on any appropriate inverses.\n   *\n   * This method is a candidate to become a mutation\n   *\n   * @method rollbackRelationships\n   * @public\n   * @param {StableRecordIdentifier} identifier\n   * @return {string[]} the names of relationships that were restored\n   */rollbackRelationships(identifier){return _classPrivateFieldGet(_cache,this).rollbackRelationships(identifier);}/**\n   * Query the cache for the current state of a relationship property\n   *\n   * @method getRelationship\n   * @public\n   * @param identifier\n   * @param propertyName\n   * @return resource relationship object\n   */getRelationship(identifier,propertyName){return _classPrivateFieldGet(_cache,this).getRelationship(identifier,propertyName);}// Resource State\n// ===============\n/**\n   * Update the cache state for the given resource to be marked as locally deleted,\n   * or remove such a mark.\n   *\n   * @method setIsDeleted\n   * @public\n   * @param identifier\n   * @param isDeleted\n   */setIsDeleted(identifier,isDeleted){_classPrivateFieldGet(_cache,this).setIsDeleted(identifier,isDeleted);}/**\n   * Query the cache for any validation errors applicable to the given resource.\n   *\n   * @method getErrors\n   * @public\n   * @param identifier\n   * @return\n   */getErrors(identifier){return _classPrivateFieldGet(_cache,this).getErrors(identifier);}/**\n   * Query the cache for whether a given resource has any available data\n   *\n   * @method isEmpty\n   * @public\n   * @param identifier\n   * @return {boolean}\n   */isEmpty(identifier){return _classPrivateFieldGet(_cache,this).isEmpty(identifier);}/**\n   * Query the cache for whether a given resource was created locally and not\n   * yet persisted.\n   *\n   * @method isNew\n   * @public\n   * @param identifier\n   * @return {boolean}\n   */isNew(identifier){return _classPrivateFieldGet(_cache,this).isNew(identifier);}/**\n   * Query the cache for whether a given resource is marked as deleted (but not\n   * necessarily persisted yet).\n   *\n   * @method isDeleted\n   * @public\n   * @param identifier\n   * @return {boolean}\n   */isDeleted(identifier){return _classPrivateFieldGet(_cache,this).isDeleted(identifier);}/**\n   * Query the cache for whether a given resource has been deleted and that deletion\n   * has also been persisted.\n   *\n   * @method isDeletionCommitted\n   * @public\n   * @param identifier\n   * @return {boolean}\n   */isDeletionCommitted(identifier){return _classPrivateFieldGet(_cache,this).isDeletionCommitted(identifier);}}/**\n * @module @ember-data/store\n */// eslint-disable-next-line no-restricted-imports\nlet tokenId=0;const CacheOperations=new Set(['added','removed','state','updated','invalidated']);function isCacheOperationValue(value){return CacheOperations.has(value);}function runLoopIsFlushing(){//@ts-expect-error\nreturn!!_ember_runloop__WEBPACK_IMPORTED_MODULE_6__._backburner.currentInstance&&_ember_runloop__WEBPACK_IMPORTED_MODULE_6__._backburner._autorun!==true;}function _unsubscribe(tokens,token,cache){const identifier=tokens.get(token);if(identifier){tokens.delete(token);const map=cache.get(identifier);map?.delete(token);}}/**\n * The NotificationManager provides the ability to subscribe to\n * changes to Cache state.\n *\n * This Feature is what allows EmberData to create subscriptions that\n * work with any framework or change-notification system.\n *\n * @class NotificationManager\n * @public\n */class NotificationManager{constructor(store){this.store=store;this.isDestroyed=false;this._buffered=new Map();this._hasFlush=false;this._cache=new Map();this._tokens=new Map();}/**\n   * Subscribe to changes for a given resource identifier, resource addition/removal, or document addition/removal.\n   *\n   * ```ts\n   * export type CacheOperation = 'added' | 'removed' | 'updated' | 'state';\n   *\n   * export interface NotificationCallback {\n   *   (identifier: StableRecordIdentifier, notificationType: 'attributes' | 'relationships', key?: string): void;\n   *   (identifier: StableRecordIdentifier, notificationType: 'errors' | 'meta' | 'identity' | 'state'): void;\n   *   (identifier: StableRecordIdentifier, notificationType: NotificationType, key?: string): void;\n   * }\n   * export interface ResourceOperationCallback {\n   *   // resource updates\n   *   (identifier: StableRecordIdentifier, notificationType: CacheOperation): void;\n   * }\n   * export interface DocumentOperationCallback {\n   *   // document updates\n   *   (identifier: StableDocumentIdentifier, notificationType: CacheOperation): void;\n   * }\n   * ```\n   *\n   * @method subscribe\n   * @public\n   * @param {StableDocumentIdentifier | StableRecordIdentifier | 'resource' | 'document'} identifier\n   * @param {NotificationCallback | ResourceOperationCallback | DocumentOperationCallback} callback\n   * @return {UnsubscribeToken} an opaque token to be used with unsubscribe\n   */subscribe(identifier,callback){(test=>{if(!test){throw new Error(`Expected to receive a stable Identifier to subscribe to`);}})(identifier==='resource'||identifier==='document'||isStableIdentifier(identifier)||isDocumentIdentifier(identifier));let map=this._cache.get(identifier);if(!map){map=new Map();this._cache.set(identifier,map);}const unsubToken={_tokenRef:tokenId++};map.set(unsubToken,callback);this._tokens.set(unsubToken,identifier);return unsubToken;}/**\n   * remove a previous subscription\n   *\n   * @method unsubscribe\n   * @public\n   * @param {UnsubscribeToken} token\n   */unsubscribe(token){if(!this.isDestroyed){_unsubscribe(this._tokens,token,this._cache);}}/**\n   * Custom Caches and Application Code should not call this method directly.\n   *\n   * @method notify\n   * @param identifier\n   * @param value\n   * @param key\n   * @return {Boolean} whether a notification was delivered to any subscribers\n   * @private\n   */notify(identifier,value,key){(test=>{if(!test){throw new Error(`Notify does not accept a key argument for the namespace '${value}'. Received key '${key||''}'.`);}})(!key||value==='attributes'||value==='relationships');if(!isStableIdentifier(identifier)&&!isDocumentIdentifier(identifier)){return false;}const hasSubscribers=Boolean(this._cache.get(identifier)?.size);if(isCacheOperationValue(value)||hasSubscribers){let buffer=this._buffered.get(identifier);if(!buffer){buffer=[];this._buffered.set(identifier,buffer);}buffer.push([value,key]);this._scheduleNotify();}return hasSubscribers;}_onNextFlush(cb){this._onFlushCB=cb;}_scheduleNotify(){const asyncFlush=this.store._enableAsyncFlush;if(this._hasFlush){if(asyncFlush!==false&&!runLoopIsFlushing()){return;}}if(asyncFlush&&!runLoopIsFlushing()){this._hasFlush=true;return;}this._flush();}_flush(){const buffered=this._buffered;if(buffered.size){this._buffered=new Map();buffered.forEach((states,identifier)=>{states.forEach(args=>{// @ts-expect-error\nthis._flushNotification(identifier,args[0],args[1]);});});}this._hasFlush=false;this._onFlushCB?.();this._onFlushCB=undefined;}_flushNotification(identifier,value,key){// TODO for documents this will need to switch based on Identifier kind\nif(isCacheOperationValue(value)){const callbackMap=this._cache.get(isDocumentIdentifier(identifier)?'document':'resource');if(callbackMap){callbackMap.forEach(cb=>{cb(identifier,value);});}}const callbackMap=this._cache.get(identifier);if(!callbackMap||!callbackMap.size){return false;}callbackMap.forEach(cb=>{// @ts-expect-error overload doesn't narrow within body\ncb(identifier,value,key);});return true;}destroy(){this.isDestroyed=true;this._tokens.clear();this._cache.clear();}}/* eslint-disable @typescript-eslint/no-explicit-any *//*\n  We redefine Proxy because the native Proxy type treats the `target` and\n  `receiver` as the same type incorrectly.\n\n  We ported this from Typescript's own Proxy types on 3/10/2024.\n*/const NativeProxy=Proxy;var __defProp=Object.defineProperty;var __export=(target,all)=>{for(var name in all)__defProp(target,name,{get:all[name],enumerable:true});};// src/runtime.ts\nvar runtime_exports={};__export(runtime_exports,{c:()=>decorateClass,f:()=>decorateFieldV1,g:()=>decorateFieldV2,i:()=>initializeDeferredDecorator,m:()=>decorateMethodV1,n:()=>decorateMethodV2,p:()=>decoratePOJO});var deferred=/* @__PURE__ */new WeakMap();function deferDecorator(proto,prop,desc){let map=deferred.get(proto);if(!map){map=/* @__PURE__ */new Map();deferred.set(proto,map);}map.set(prop,desc);}function findDeferredDecorator(target,prop){let cursor=target.prototype;while(cursor){let desc=deferred.get(cursor)?.get(prop);if(desc){return desc;}cursor=cursor.prototype;}}function decorateFieldV1(target,prop,decorators,initializer){return decorateFieldV2(target.prototype,prop,decorators,initializer);}function decorateFieldV2(prototype,prop,decorators,initializer){let desc={configurable:true,enumerable:true,writable:true,initializer:null};if(initializer){desc.initializer=initializer;}for(let decorator of decorators){desc=decorator(prototype,prop,desc)||desc;}if(desc.initializer===void 0){Object.defineProperty(prototype,prop,desc);}else{deferDecorator(prototype,prop,desc);}}function decorateMethodV1({prototype},prop,decorators){return decorateMethodV2(prototype,prop,decorators);}function decorateMethodV2(prototype,prop,decorators){const origDesc=Object.getOwnPropertyDescriptor(prototype,prop);let desc={...origDesc};for(let decorator of decorators){desc=decorator(prototype,prop,desc)||desc;}if(desc.initializer!==void 0){desc.value=desc.initializer?desc.initializer.call(prototype):void 0;desc.initializer=void 0;}Object.defineProperty(prototype,prop,desc);}function initializeDeferredDecorator(target,prop){let desc=findDeferredDecorator(target.constructor,prop);if(desc){Object.defineProperty(target,prop,{enumerable:desc.enumerable,configurable:desc.configurable,writable:desc.writable,value:desc.initializer?desc.initializer.call(target):void 0});}}function decorateClass(target,decorators){return decorators.reduce((accum,decorator)=>decorator(accum)||accum,target);}function decoratePOJO(pojo,decorated){for(let[type,prop,decorators]of decorated){if(type===\"field\"){decoratePojoField(pojo,prop,decorators);}else{decorateMethodV2(pojo,prop,decorators);}}return pojo;}function decoratePojoField(pojo,prop,decorators){let desc={configurable:true,enumerable:true,writable:true,initializer:()=>Object.getOwnPropertyDescriptor(pojo,prop)?.value};for(let decorator of decorators){desc=decorator(pojo,prop,desc)||desc;}if(desc.initializer){desc.value=desc.initializer.call(pojo);delete desc.initializer;}Object.defineProperty(pojo,prop,desc);}/**\n  @module @ember-data/store\n*/const ARRAY_GETTER_METHODS=new Set([Symbol.iterator,'concat','entries','every','fill','filter','find','findIndex','flat','flatMap','forEach','includes','indexOf','join','keys','lastIndexOf','map','reduce','reduceRight','slice','some','values']);const ARRAY_SETTER_METHODS=new Set(['push','pop','unshift','shift','splice','sort']);const SYNC_PROPS=new Set(['[]','length','links','meta']);function isArrayGetter(prop){return ARRAY_GETTER_METHODS.has(prop);}function isArraySetter(prop){return ARRAY_SETTER_METHODS.has(prop);}function isSelfProp(self,prop){return prop in self;}const ARRAY_SIGNAL=(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_2__.getOrSetGlobal)('#signal',Symbol('#signal'));const SOURCE=(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_2__.getOrSetGlobal)('#source',Symbol('#source'));const MUTATE=(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_2__.getOrSetGlobal)('#update',Symbol('#update'));const NOTIFY=(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_2__.getOrSetGlobal)('#notify',Symbol('#notify'));const IS_COLLECTION=(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_2__.getOrSetGlobal)('IS_COLLECTION',Symbol.for('Collection'));function notifyArray(arr){(0,_ember_data_tracking_private__WEBPACK_IMPORTED_MODULE_5__.addToTransaction)(arr[ARRAY_SIGNAL]);}function convertToInt(prop){if(typeof prop==='symbol')return null;const num=Number(prop);if(isNaN(num))return null;return num%1===0?num:null;}function safeForEach(instance,arr,store,callback,target){if(target===undefined){target=null;}// clone to prevent mutation\narr=arr.slice();(test=>{if(!test){throw new Error('`forEach` expects a function as first argument.');}})(typeof callback==='function');// because we retrieveLatest above we need not worry if array is mutated during iteration\n// by unloadRecord/rollbackAttributes\n// push/add/removeObject may still be problematic\n// but this is a more traditionally expected forEach bug.\nconst length=arr.length;// we need to access length to ensure we are consumed\nfor(let index=0;index<length;index++){callback.call(target,store._instanceCache.getRecord(arr[index]),index,instance);}return instance;}/**\n  A record array is an array that contains records of a certain type (or modelName).\n  The record array materializes records as needed when they are retrieved for the first\n  time. You should not create record arrays yourself. Instead, an instance of\n  `RecordArray` or its subclasses will be returned by your application's store\n  in response to queries.\n\n  This class should not be imported and instantiated by consuming applications.\n\n  @class RecordArray\n  @public\n*/class IdentifierArray{[NOTIFY](){notifyArray(this);}/**\n    The store that created this record array.\n     @property store\n    @private\n    @type Store\n    */destroy(clear){this.isDestroying=!clear;// changing the reference breaks the Proxy\n// this[SOURCE] = [];\nthis[SOURCE].length=0;this[NOTIFY]();this.isDestroyed=!clear;}// length must be on self for proxied methods to work properly\nget length(){return this[SOURCE].length;}set length(value){this[SOURCE].length=value;}constructor(options){/**\n    The flag to signal a `RecordArray` is currently loading data.\n    Example\n    ```javascript\n    let people = store.peekAll('person');\n    people.isUpdating; // false\n    people.update();\n    people.isUpdating; // true\n    ```\n    @property isUpdating\n    @public\n    @type Boolean\n  */_defineProperty(this,\"isLoaded\",true);_defineProperty(this,\"isDestroying\",false);_defineProperty(this,\"isDestroyed\",false);_defineProperty(this,\"_updatingPromise\",null);_defineProperty(this,IS_COLLECTION,true);_defineProperty(this,SOURCE,void 0);// eslint-disable-next-line @typescript-eslint/no-this-alias\nconst self=this;this.modelName=options.type;this.store=options.store;this._manager=options.manager;this[SOURCE]=options.identifiers;this[ARRAY_SIGNAL]=(0,_ember_data_tracking_private__WEBPACK_IMPORTED_MODULE_5__.createSignal)(this,'length');const store=options.store;const boundFns=new Map();const _SIGNAL=this[ARRAY_SIGNAL];const PrivateState={links:options.links||null,meta:options.meta||null};let transaction=false;// when a mutation occurs\n// we track all mutations within the call\n// and forward them as one\nconst proxy=new NativeProxy(this[SOURCE],{get(target,prop,receiver){const index=convertToInt(prop);if(_SIGNAL.shouldReset&&(index!==null||SYNC_PROPS.has(prop)||isArrayGetter(prop))){options.manager._syncArray(receiver);_SIGNAL.t=false;_SIGNAL.shouldReset=false;}if(index!==null){const identifier=target[index];if(!transaction){(0,_ember_data_tracking_private__WEBPACK_IMPORTED_MODULE_5__.subscribe)(_SIGNAL);}return identifier&&store._instanceCache.getRecord(identifier);}if(prop==='meta')return (0,_ember_data_tracking_private__WEBPACK_IMPORTED_MODULE_5__.subscribe)(_SIGNAL),PrivateState.meta;if(prop==='links')return (0,_ember_data_tracking_private__WEBPACK_IMPORTED_MODULE_5__.subscribe)(_SIGNAL),PrivateState.links;if(prop==='[]')return (0,_ember_data_tracking_private__WEBPACK_IMPORTED_MODULE_5__.subscribe)(_SIGNAL),receiver;if(isArrayGetter(prop)){let fn=boundFns.get(prop);if(fn===undefined){if(prop==='forEach'){fn=function(){(0,_ember_data_tracking_private__WEBPACK_IMPORTED_MODULE_5__.subscribe)(_SIGNAL);transaction=true;const result=safeForEach(receiver,target,store,arguments[0],arguments[1]);transaction=false;return result;};}else{fn=function(){(0,_ember_data_tracking_private__WEBPACK_IMPORTED_MODULE_5__.subscribe)(_SIGNAL);// array functions must run through Reflect to work properly\n// binding via other means will not work.\ntransaction=true;const result=Reflect.apply(target[prop],receiver,arguments);transaction=false;return result;};}boundFns.set(prop,fn);}return fn;}if(isArraySetter(prop)){let fn=boundFns.get(prop);if(fn===undefined){fn=function(){// array functions must run through Reflect to work properly\n// binding via other means will not work.\nif(!options.allowMutation){(test=>{if(!test){throw new Error(`Mutating this array of records via ${String(prop)} is not allowed.`);}})(options.allowMutation);return;}const args=Array.prototype.slice.call(arguments);(test=>{if(!test){throw new Error(`Cannot start a new array transaction while a previous transaction is underway`);}})(!transaction);transaction=true;const result=self[MUTATE](target,receiver,prop,args,_SIGNAL);transaction=false;return result;};boundFns.set(prop,fn);}return fn;}if(isSelfProp(self,prop)){if(prop===NOTIFY||prop===ARRAY_SIGNAL||prop===SOURCE){return self[prop];}let fn=boundFns.get(prop);if(fn)return fn;const outcome=self[prop];if(typeof outcome==='function'){fn=function(){(0,_ember_data_tracking_private__WEBPACK_IMPORTED_MODULE_5__.subscribe)(_SIGNAL);// array functions must run through Reflect to work properly\n// binding via other means will not work.\nreturn Reflect.apply(outcome,receiver,arguments);};boundFns.set(prop,fn);return fn;}return (0,_ember_data_tracking_private__WEBPACK_IMPORTED_MODULE_5__.subscribe)(_SIGNAL),outcome;}return target[prop];},// FIXME: Should this get a generic like get above?\nset(target,prop,value,receiver){if(prop==='length'){if(!transaction&&value===0){transaction=true;self[MUTATE](target,receiver,'length 0',[],_SIGNAL);transaction=false;return true;}else if(transaction){return Reflect.set(target,prop,value);}else{(test=>{{throw new Error(`unexpected length set`);}})();}}if(prop==='links'){PrivateState.links=value||null;return true;}if(prop==='meta'){PrivateState.meta=value||null;return true;}const index=convertToInt(prop);// we do not allow \"holey\" arrays and so if the index is\n// greater than length then we will disallow setting it.\n// however, there is a special case for \"unshift\" with more than\n// one item being inserted since current items will be moved to the\n// new indices first.\n// we \"loosely\" detect this by just checking whether we are in\n// a transaction.\nif(index===null||index>target.length){if(index!==null&&transaction){const identifier=recordIdentifierFor(value);(test=>{if(!test){throw new Error(`Cannot set index ${index} past the end of the array.`);}})(isStableIdentifier(identifier));target[index]=identifier;return true;}else if(isSelfProp(self,prop)){// @ts-expect-error not all properties are indeces and we can't safely cast\nself[prop]=value;return true;}return false;}if(!options.allowMutation){(test=>{if(!test){throw new Error(`Mutating ${String(prop)} on this Array is not allowed.`);}})(options.allowMutation);return false;}const original=target[index];const newIdentifier=extractIdentifierFromRecord$1(value);target[index]=newIdentifier;(test=>{if(!test){throw new Error(`Expected a record`);}})(isStableIdentifier(newIdentifier));// We generate \"transactions\" whenever a setter method on the array\n// is called and might bulk update multiple array cells. Fundamentally,\n// all array operations decompose into individual cell replacements.\n// e.g. a push is really a \"replace cell at next index with new value\"\n// or a splice is \"shift all values left/right by X and set out of new\n// bounds cells to undefined\"\n//\n// so, if we are in a transaction, then this is not a user generated change\n// but one generated by a setter method. In this case we want to only apply\n// the change to the target array and not call the MUTATE method.\n// If there is no transaction though, then this means the user themselves has\n// directly changed the value of a specific index and we need to thus generate\n// a mutation for that change.\n// e.g. \"arr.push(newVal)\" is handled by a \"addToRelatedRecords\" mutation within\n// a transaction.\n// while \"arr[arr.length] = newVal;\" is handled by this replace cell code path.\nif(!transaction){self[MUTATE](target,receiver,'replace cell',[index,original,newIdentifier],_SIGNAL);}else{target[index]=newIdentifier;}return true;},deleteProperty(target,prop){(test=>{if(!test){throw new Error(`Deleting keys on managed arrays is disallowed`);}})(transaction);if(!transaction){return false;}return Reflect.deleteProperty(target,prop);},getPrototypeOf(){return IdentifierArray.prototype;}});(0,_ember_data_tracking_private__WEBPACK_IMPORTED_MODULE_5__.createArrayTags)(proxy,_SIGNAL);this[NOTIFY]=this[NOTIFY].bind(proxy);return proxy;}/**\n    Used to get the latest version of all of the records in this array\n    from the adapter.\n     Example\n     ```javascript\n    let people = store.peekAll('person');\n    people.isUpdating; // false\n     people.update().then(function() {\n      people.isUpdating; // false\n    });\n     people.isUpdating; // true\n    ```\n     @method update\n    @public\n  */update(){if(this.isUpdating){return this._updatingPromise;}this.isUpdating=true;const updatingPromise=this._update();void updatingPromise.finally(()=>{this._updatingPromise=null;if(this.isDestroying||this.isDestroyed){return;}this.isUpdating=false;});this._updatingPromise=updatingPromise;return updatingPromise;}/*\n    Update this Array and return a promise which resolves once the update\n    is finished.\n   */_update(){(test=>{if(!test){throw new Error(`_update cannot be used with this array`);}})(this.modelName);// @ts-expect-error typescript is unable to handle the complexity of\n//   T = unknown, modelName = string\n//   T extends TypedRecordInstance, modelName = TypeFromInstance<T>\n// both being valid options to pass through here.\nreturn this.store.findAll(this.modelName,{reload:true});}// TODO deprecate\n/**\n    Saves all of the records in the `RecordArray`.\n     Example\n     ```javascript\n    let messages = store.peekAll('message');\n    messages.forEach(function(message) {\n      message.hasBeenSeen = true;\n    });\n    messages.save();\n    ```\n     @method save\n    @public\n    @return {Promise<IdentifierArray>} promise\n  */save(){const promise=Promise.all(this.map(record=>this.store.saveRecord(record))).then(()=>this);return promise;}}// this will error if someone tries to call\n// A(identifierArray) since it is not configurable\n// which is preferable to the `meta` override we used\n// before which required importing all of Ember\n_IdentifierArray=IdentifierArray;decorateMethodV2(_IdentifierArray.prototype,\"length\",[_ember_data_tracking__WEBPACK_IMPORTED_MODULE_7__.compat]);const desc={enumerable:true,configurable:false,get:function(){return this;}};(0,_ember_data_tracking__WEBPACK_IMPORTED_MODULE_7__.compat)(desc);Object.defineProperty(IdentifierArray.prototype,'[]',desc);(0,_ember_data_tracking_private__WEBPACK_IMPORTED_MODULE_5__.defineSignal)(IdentifierArray.prototype,'isUpdating',false);class Collection extends IdentifierArray{constructor(options){super(options);_defineProperty(this,\"query\",null);this.query=options.query||null;this.isLoaded=options.isLoaded||false;}_update(){const{store,query}=this;// TODO save options from initial request?\n(test=>{if(!test){throw new Error(`update cannot be used with this array`);}})(this.modelName);(test=>{if(!test){throw new Error(`update cannot be used with no query`);}})(query);// @ts-expect-error typescript is unable to handle the complexity of\n//   T = unknown, modelName = string\n//   T extends TypedRecordInstance, modelName = TypeFromInstance<T>\n// both being valid options to pass through here.\nconst promise=store.query(this.modelName,query,{_recordArray:this});return promise;}destroy(clear){super.destroy(clear);this._manager._managed.delete(this);this._manager._pending.delete(this);}}// trick the proxy \"in\" check\nCollection.prototype.query=null;// Ensure instanceof works correctly\n// Object.setPrototypeOf(IdentifierArray.prototype, Array.prototype);\nfunction assertRecordPassedToHasMany(record){(test=>{if(!test){throw new Error(`All elements of a hasMany relationship must be instances of Model, you passed $${typeof record}`);}})(function(){try{recordIdentifierFor(record);return true;}catch{return false;}}());}function extractIdentifierFromRecord$1(record){if(!record){return null;}assertRecordPassedToHasMany(record);return recordIdentifierFor(record);}/**\n  @module @ember-data/store\n*/const FAKE_ARR=(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_2__.getOrSetGlobal)('FAKE_ARR',{});const SLICE_BATCH_SIZE=1200;/**\n * This is a clever optimization.\n *\n * clever optimizations rarely stand the test of time, so if you're\n * ever curious or think something better is possible please benchmark\n * and discuss. The benchmark for this at the time of writing is in\n * `scripts/benchmark-push.js`\n *\n * This approach turns out to be 150x faster in Chrome and node than\n * simply using push or concat. It's highly susceptible to the specifics\n * of the batch size, and may require tuning.\n *\n * Clever optimizations should always come with a `why`. This optimization\n * exists for two reasons.\n *\n * 1) array.push(...objects) and Array.prototype.push.apply(arr, objects)\n *   are susceptible to stack overflows. The size of objects at which this\n *   occurs varies by environment, browser, and current stack depth and memory\n *   pressure; however, it occurs in all browsers in fairly pristine conditions\n *   somewhere around 125k to 200k elements. Since EmberData regularly encounters\n *   arrays larger than this in size, we cannot use push.\n *\n * 2) `array.concat` or simply setting the array to a new reference is often an\n *   easier approach; however, native Proxy to an array cannot swap it's target array\n *   and attempts at juggling multiple array sources have proven to be victim to a number\n *   of browser implementation bugs. Should these bugs be addressed then we could\n *   simplify to using `concat`, however, do note this is currently 150x faster\n *   than concat, and due to the overloaded signature of concat will likely always\n *   be faster.\n *\n * Sincerely,\n *   - runspired (Chris Thoburn) 08/21/2022\n *\n * @function fastPush\n * @internal\n * @param target the array to push into\n * @param source the items to push into target\n */function fastPush(target,source){let startLength=0;const newLength=source.length;while(newLength-startLength>SLICE_BATCH_SIZE){// eslint-disable-next-line prefer-spread\ntarget.push.apply(target,source.slice(startLength,startLength+SLICE_BATCH_SIZE));startLength+=SLICE_BATCH_SIZE;}// eslint-disable-next-line prefer-spread\ntarget.push.apply(target,source.slice(startLength));}/**\n  @class RecordArrayManager\n  @internal\n*/class RecordArrayManager{constructor(options){this.store=options.store;this.isDestroying=false;this.isDestroyed=false;this._live=new Map();this._managed=new Set();this._pending=new Map();this._staged=new Map();this._keyedArrays=new Map();this._identifiers=new Map();this._set=new Map();this._visibilitySet=new Map();this._subscription=this.store.notifications.subscribe('resource',(identifier,type)=>{if(type==='added'){this._visibilitySet.set(identifier,true);this.identifierAdded(identifier);}else if(type==='removed'){this._visibilitySet.set(identifier,false);this.identifierRemoved(identifier);}else if(type==='state'){this.identifierChanged(identifier);}});}_syncArray(array){const pending=this._pending.get(array);if(!pending||this.isDestroying||this.isDestroyed){return;}sync(array,pending,this._set.get(array));this._pending.delete(array);}/**\n    Get the `RecordArray` for a modelName, which contains all loaded records of\n    given modelName.\n     @method liveArrayFor\n    @internal\n    @param {String} modelName\n    @return {RecordArray}\n  */liveArrayFor(type){let array=this._live.get(type);const identifiers=[];const staged=this._staged.get(type);if(staged){staged.forEach((value,key)=>{if(value==='add'){identifiers.push(key);}});this._staged.delete(type);}if(!array){array=new IdentifierArray({type,identifiers,store:this.store,allowMutation:false,manager:this});this._live.set(type,array);this._set.set(array,new Set(identifiers));}return array;}createArray(config){const options={type:config.type,links:config.doc?.links||null,meta:config.doc?.meta||null,query:config.query||null,identifiers:config.identifiers||[],isLoaded:!!config.identifiers?.length,allowMutation:false,store:this.store,manager:this};const array=new Collection(options);this._managed.add(array);this._set.set(array,new Set(options.identifiers||[]));if(config.identifiers){associate(this._identifiers,array,config.identifiers);}return array;}dirtyArray(array,delta){if(array===FAKE_ARR){return;}const tag=array[ARRAY_SIGNAL];if(!tag.shouldReset){tag.shouldReset=true;(0,_ember_data_tracking_private__WEBPACK_IMPORTED_MODULE_5__.addTransactionCB)(array[NOTIFY]);}else if(delta>0&&!tag.t){(0,_ember_data_tracking_private__WEBPACK_IMPORTED_MODULE_5__.addTransactionCB)(array[NOTIFY]);}}_getPendingFor(identifier,includeManaged,isRemove){if(this.isDestroying||this.isDestroyed){return;}const liveArray=this._live.get(identifier.type);const allPending=this._pending;const pending=new Map();if(includeManaged){const managed=this._identifiers.get(identifier);if(managed){managed.forEach(arr=>{let changes=allPending.get(arr);if(!changes){changes=new Map();allPending.set(arr,changes);}pending.set(arr,changes);});}}// during unloadAll we can ignore removes since we've already\n// cleared the array.\nif(liveArray&&liveArray[SOURCE].length===0&&isRemove){const pendingLive=allPending.get(liveArray);if(!pendingLive||pendingLive.size===0){return pending;}}if(!liveArray){// start building a changeset for when we eventually\n// do have a live array\nlet changes=this._staged.get(identifier.type);if(!changes){changes=new Map();this._staged.set(identifier.type,changes);}pending.set(FAKE_ARR,changes);}else{let changes=allPending.get(liveArray);if(!changes){changes=new Map();allPending.set(liveArray,changes);}pending.set(liveArray,changes);}return pending;}populateManagedArray(array,identifiers,payload){this._pending.delete(array);const source=array[SOURCE];const old=source.slice();source.length=0;fastPush(source,identifiers);this._set.set(array,new Set(identifiers));notifyArray(array);array.meta=payload.meta||null;array.links=payload.links||null;array.isLoaded=true;disassociate(this._identifiers,array,old);associate(this._identifiers,array,identifiers);}identifierAdded(identifier){const changeSets=this._getPendingFor(identifier,false);if(changeSets){changeSets.forEach((changes,array)=>{const existing=changes.get(identifier);if(existing==='del'){changes.delete(identifier);}else{changes.set(identifier,'add');this.dirtyArray(array,changes.size);}});}}identifierRemoved(identifier){const changeSets=this._getPendingFor(identifier,true,true);if(changeSets){changeSets.forEach((changes,array)=>{const existing=changes.get(identifier);if(existing==='add'){changes.delete(identifier);}else{changes.set(identifier,'del');this.dirtyArray(array,changes.size);}});}}identifierChanged(identifier){const newState=this.store._instanceCache.recordIsLoaded(identifier,true);// if the change matches the most recent direct added/removed\n// state, then we can ignore it\nif(this._visibilitySet.get(identifier)===newState){return;}if(newState){this.identifierAdded(identifier);}else{this.identifierRemoved(identifier);}}clear(isClear=true){this._live.forEach(array=>array.destroy(isClear));this._managed.forEach(array=>array.destroy(isClear));this._managed.clear();this._identifiers.clear();this._pending.clear();this._set.forEach(set=>set.clear());this._visibilitySet.clear();}destroy(){this.isDestroying=true;this.clear(false);this._live.clear();this.isDestroyed=true;this.store.notifications.unsubscribe(this._subscription);}}function associate(ArraysCache,array,identifiers){for(let i=0;i<identifiers.length;i++){const identifier=identifiers[i];let cache=ArraysCache.get(identifier);if(!cache){cache=new Set();ArraysCache.set(identifier,cache);}cache.add(array);}}function disassociate(ArraysCache,array,identifiers){for(let i=0;i<identifiers.length;i++){disassociateIdentifier(ArraysCache,array,identifiers[i]);}}function disassociateIdentifier(ArraysCache,array,identifier){const cache=ArraysCache.get(identifier);if(cache){cache.delete(array);}}function sync(array,changes,arraySet){const state=array[SOURCE];const adds=[];const removes=[];changes.forEach((value,key)=>{if(value==='add'){// likely we want to keep a Set along-side\nif(arraySet.has(key)){return;}adds.push(key);arraySet.add(key);}else{if(arraySet.has(key)){removes.push(key);arraySet.delete(key);}}});if(removes.length){if(removes.length===state.length){state.length=0;// changing the reference breaks the Proxy\n// state = array[SOURCE] = [];\n}else{removes.forEach(i=>{const index=state.indexOf(i);if(index!==-1){state.splice(index,1);arraySet.delete(i);}});}}if(adds.length){fastPush(state,adds);// changing the reference breaks the Proxy\n// else we could do this\n/*\n    if (state.length === 0) {\n      array[SOURCE] = adds;\n    } else {\n      array[SOURCE] = state.concat(adds);\n    }\n    */}}/**\n * @module @ember-data/store\n */const Touching=(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_2__.getOrSetGlobal)('Touching',Symbol('touching'));const RequestPromise=(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_2__.getOrSetGlobal)('RequestPromise',Symbol('promise'));const EMPTY_ARR=Object.freeze([]);function hasRecordIdentifier(op){return'recordIdentifier'in op;}/**\n * The RequestStateService is used to track the state of requests\n * for fetching or updating known resource identifies that are inflight.\n *\n * @class RequestStateService\n * @public\n */class RequestStateService{constructor(store){_defineProperty(this,\"_pending\",new Map());_defineProperty(this,\"_done\",new Map());_defineProperty(this,\"_subscriptions\",new Map());_defineProperty(this,\"_toFlush\",[]);_defineProperty(this,\"_store\",void 0);this._store=store;}_clearEntries(identifier){this._done.delete(identifier);}_enqueue(promise,queryRequest){const query=queryRequest.data[0];if(hasRecordIdentifier(query)){const identifier=query.recordIdentifier;const type=query.op==='saveRecord'?'mutation':'query';if(!this._pending.has(identifier)){this._pending.set(identifier,[]);}const request={state:'pending',request:queryRequest,type};request[Touching]=[query.recordIdentifier];request[RequestPromise]=promise;this._pending.get(identifier).push(request);this._triggerSubscriptions(request);return promise.then(result=>{this._dequeue(identifier,request);const finalizedRequest={state:'fulfilled',request:queryRequest,type,response:{data:result}};finalizedRequest[Touching]=request[Touching];this._addDone(finalizedRequest);this._triggerSubscriptions(finalizedRequest);return result;},error=>{this._dequeue(identifier,request);const finalizedRequest={state:'rejected',request:queryRequest,type,response:{data:error}};finalizedRequest[Touching]=request[Touching];this._addDone(finalizedRequest);this._triggerSubscriptions(finalizedRequest);throw error;});}(test=>{{throw new Error(`Expected a well formed  query`);}})();}_triggerSubscriptions(req){if(req.state==='pending'){this._flushRequest(req);return;}this._toFlush.push(req);if(this._toFlush.length===1){this._store.notifications._onNextFlush(()=>{this._flush();});}}_flush(){this._toFlush.forEach(req=>{this._flushRequest(req);});this._toFlush=[];}_flushRequest(req){req[Touching].forEach(identifier=>{const subscriptions=this._subscriptions.get(identifier);if(subscriptions){subscriptions.forEach(callback=>callback(req));}});}_dequeue(identifier,request){const pending=this._pending.get(identifier);this._pending.set(identifier,pending.filter(req=>req!==request));}_addDone(request){request[Touching].forEach(identifier=>{// TODO add support for multiple\nconst requestDataOp=request.request.data[0].op;let requests=this._done.get(identifier);if(requests){requests=requests.filter(req=>{// TODO add support for multiple\nlet data;if(Array.isArray(req.request.data)){data=req.request.data[0];}else{data=req.request.data;}return data.op!==requestDataOp;});}requests=requests||[];requests.push(request);this._done.set(identifier,requests);});}/**\n   * Subscribe to requests for a given resource identity.\n   *\n   * The callback will receive the current state of the request.\n   *\n   * ```ts\n   * interface RequestState {\n   *   state: 'pending' | 'fulfilled' | 'rejected';\n   *   type: 'query' | 'mutation';\n   *   request: Request;\n   *   response?: { data: unknown };\n   * }\n   * ```\n   *\n   * Note: It should be considered dangerous to use this API for more than simple\n   * state derivation or debugging. The `request` and `response` properties are poorly\n   * spec'd and may change unexpectedly when shifting what Handlers are in use or how\n   * requests are issued from the Store.\n   *\n   * We expect to revisit this API in the near future as we continue to refine the\n   * RequestManager ergonomics, as a simpler but more powerful direct integration\n   * with the RequestManager for these purposes is likely to be a better long-term\n   * design.\n   *\n   * @method subscribeForRecord\n   * @public\n   * @param {StableRecordIdentifier} identifier\n   * @param {(state: RequestState) => void} callback\n   */subscribeForRecord(identifier,callback){let subscriptions=this._subscriptions.get(identifier);if(!subscriptions){subscriptions=[];this._subscriptions.set(identifier,subscriptions);}subscriptions.push(callback);}/**\n   * Retrieve all active requests for a given resource identity.\n   *\n   * @method getPendingRequestsForRecord\n   * @public\n   * @param {StableRecordIdentifier} identifier\n   * @return {RequestState[]} an array of request states for any pending requests for the given identifier\n   */getPendingRequestsForRecord(identifier){return this._pending.get(identifier)||EMPTY_ARR;}/**\n   * Retrieve the last completed request for a given resource identity.\n   *\n   * @method getLastRequestForRecord\n   * @public\n   * @param {StableRecordIdentifier} identifier\n   * @return {RequestState | null} the state of the most recent request for the given identifier\n   */getLastRequestForRecord(identifier){const requests=this._done.get(identifier);if(requests){return requests[requests.length-1];}return null;}}function isNonEmptyString(str){return Boolean(str&&typeof str==='string');}function constructResource(type,id,lid){if(typeof type==='object'&&type!==null){const resource=type;if(isStableIdentifier(resource)){return resource;}if('id'in resource){resource.id=coerceId(resource.id);}(test=>{if(!test){throw new Error('Expected either id or lid to be a valid string');}})('id'in resource&&isNonEmptyString(resource.id)||isNonEmptyString(resource.lid));(test=>{if(!test){throw new Error('if id is present, the type must be a string');}})(!('id'in resource)||typeof resource.type==='string');return resource;}else{const trueId=coerceId(id);if(!isNonEmptyString(trueId)){if(isNonEmptyString(lid)){return{lid};}throw new Error('Expected either id or lid to be a valid string');}(test=>{if(!test){throw new Error('type must be a string');}})(typeof type==='string');if(isNonEmptyString(lid)){return{type,id:trueId,lid};}return{type,id:trueId};}}/**\n  @module @ember-data/store\n */// this import location is deprecated but breaks in 4.8 and older\n// `AwaitedKeys` is needed here to resolve any promise types like `PromiseBelongsTo`.\n/**\n * Currently only records that extend object can be created via\n * store.createRecord. This is a limitation of the current API,\n * but can be worked around by creating a new identifier, running\n * the cache.clientDidCreate method, and then peeking the record\n * for the identifier.\n *\n * To assign primary key to a record during creation, only `id` will\n * work correctly for `store.createRecord`, other primary key may be\n * handled by updating the record after creation or using the flow\n * described above.\n *\n * TODO: These are limitations we want to (and can) address. If you\n * have need of lifting these limitations, please open an issue.\n *\n * @typedoc\n *//**\n * A Store coordinates interaction between your application, a [Cache](https://api.emberjs.com/ember-data/release/classes/%3CInterface%3E%20Cache),\n * and sources of data (such as your API or a local persistence layer)\n * accessed via a [RequestManager](https://github.com/emberjs/data/tree/main/packages/request).\n *\n * ```app/services/store.js\n * import Store from '@ember-data/store';\n *\n * export default class extends Store {}\n * ```\n *\n * Most Applications will only have a single `Store` configured as a Service\n * in this manner. However, setting up multiple stores is possible, including using\n * each as a unique service or within a specific context.\n *\n\n  @class Store\n  @public\n*/// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nconst EmptyClass=class{// eslint-disable-next-line @typescript-eslint/no-useless-constructor\nconstructor(args){}};const BaseClass=EmptyClass;if(BaseClass!==EmptyClass){(0,_ember_debug__WEBPACK_IMPORTED_MODULE_0__.deprecate)(`The Store class extending from EmberObject is deprecated.\nPlease remove usage of EmberObject APIs and mark your class as not requiring it.\n\nTo mark the class as no longer extending from EmberObject, in ember-cli-build.js\nset the following config:\n\n\\`\\`\\`js\nconst app = new EmberApp(defaults, {\n  emberData: {\n    deprecations: {\n      DEPRECATE_STORE_EXTENDS_EMBER_OBJECT: false\n    }\n  }\n});\n\\`\\`\\`\n`,false,{id:'ember-data:deprecate-store-extends-ember-object',until:'6.0',for:'ember-data',since:{available:'5.4',enabled:'5.4'}});}class Store extends BaseClass{/**\n   * Provides access to the NotificationManager associated\n   * with this Store instance.\n   *\n   * The NotificationManager can be used to subscribe to\n   * changes to the cache.\n   *\n   * @property {NotificationManager} notifications\n   * @public\n   *//**\n   * Provides access to the SchemaService instance\n   * for this Store instance.\n   *\n   * The SchemaService can be used to query for\n   * information about the schema of a resource.\n   *\n   * @property {SchemaService} schema\n   * @public\n   */get schema(){if(!this._schema){this._schema=this.createSchemaService();}return this._schema;}/**\n   * Provides access to the IdentifierCache instance\n   * for this store.\n   *\n   * The IdentifierCache can be used to generate or\n   * retrieve a stable unique identifier for any resource.\n   *\n   * @property {IdentifierCache} identifierCache\n   * @public\n   *//**\n   * Provides access to the requestManager instance associated\n   * with this Store instance.\n   *\n   * When using `ember-data` this property is automatically\n   * set to an instance of `RequestManager`. When not using `ember-data`\n   * you must configure this property yourself, either by declaring\n   * it as a service or by initializing it.\n   *\n   * ```ts\n   * import Store, { CacheHandler } from '@ember-data/store';\n   * import RequestManager from '@ember-data/request';\n   * import Fetch from '@ember-data/request/fetch';\n   *\n   * class extends Store {\n   *   constructor() {\n   *     super(...arguments);\n   *     this.requestManager = new RequestManager();\n   *     this.requestManager.use([Fetch]);\n   *     this.requestManager.useCache(CacheHandler);\n   *   }\n   * }\n   * ```\n   *\n   * @public\n   * @property {RequestManager} requestManager\n   *//**\n   * A Property which an App may set to provide a CachePolicy\n   * to control when a cached request becomes stale.\n   *\n   * Note, when defined, these methods will only be invoked if a\n   * cache key exists for the request, either because the request\n   * contains `cacheOptions.key` or because the [IdentifierCache](/ember-data/release/classes/IdentifierCache)\n   * was able to generate a key for the request using the configured\n   * [generation method](/ember-data/release/functions/@ember-data%2Fstore/setIdentifierGenerationMethod).\n   *\n   * `isSoftExpired` will only be invoked if `isHardExpired` returns `false`.\n   *\n   * ```ts\n   * store.lifetimes = {\n   *   // make the request and ignore the current cache state\n   *   isHardExpired(identifier: StableDocumentIdentifier): boolean {\n   *     return false;\n   *   }\n   *\n   *   // make the request in the background if true, return cache state\n   *   isSoftExpired(identifier: StableDocumentIdentifier): boolean {\n   *     return false;\n   *   }\n   * }\n   * ```\n   *\n   * @public\n   * @property {CachePolicy|undefined} lifetimes\n   */// Private\n/**\n   * Async flush buffers notifications until flushed\n   * by finalization of a future configured by store.request\n   *\n   * This is useful for ensuring that notifications are delivered\n   * prior to the promise resolving but without risk of promise\n   * interleaving.\n   *\n   * @internal\n   */// DEBUG-only properties\nget isDestroying(){return this._isDestroying;}set isDestroying(value){this._isDestroying=value;}get isDestroyed(){return this._isDestroyed;}set isDestroyed(value){this._isDestroyed=value;}/**\n    @method init\n    @private\n  */constructor(createArgs){super(createArgs);Object.assign(this,createArgs);this.identifierCache=new IdentifierCache();this.notifications=new NotificationManager(this);// private but maybe useful to be here, somewhat intimate\nthis.recordArrayManager=new RecordArrayManager({store:this});// private\nthis._requestCache=new RequestStateService(this);this._instanceCache=new InstanceCache(this);this._documentCache=new Map();this.isDestroying=false;this.isDestroyed=false;}_run(cb){(test=>{if(!test){throw new Error(`EmberData should never encounter a nested run`);}})(!this._cbs);const _cbs=this._cbs={};{try{cb();if(_cbs.coalesce){_cbs.coalesce();}if(_cbs.sync){_cbs.sync();}if(_cbs.notify){_cbs.notify();}}finally{this._cbs=null;}}}/**\n   * Executes the callback, ensurng that any work that calls\n   * store._schedule is executed after in the right order.\n   *\n   * When queues already exist, scheduled callbacks will\n   * join the existing queue.\n   *\n   * @internal\n   */_join(cb){if(this._cbs){cb();}else{this._run(cb);}}_schedule(name,cb){(test=>{if(!test){throw new Error(`EmberData expects to schedule only when there is an active run`);}})(!!this._cbs);(test=>{if(!test){throw new Error(`EmberData expects only one flush per queue name, cannot schedule ${name}`);}})(!this._cbs[name]);this._cbs[name]=cb;}/**\n   * Retrieve the RequestStateService instance\n   * associated with this Store.\n   *\n   * This can be used to query the status of requests\n   * that have been initiated for a given identifier.\n   *\n   * @method getRequestStateService\n   * @return {RequestStateService}\n   * @public\n   */getRequestStateService(){return this._requestCache;}_getAllPending(){{const all=[];const pending=this._requestCache._pending;pending.forEach(requests=>{all.push(...requests.map(v=>v[RequestPromise]));});this.requestManager._pending.forEach(v=>all.push(v));const promise=Promise.allSettled(all);promise.length=all.length;return promise;}}/**\n   * Issue a request via the configured RequestManager,\n   * inserting the response into the cache and handing\n   * back a Future which resolves to a ResponseDocument\n   *\n   * ## Cache Keys\n   *\n   * Only GET requests with a url or requests with an explicit\n   * cache key (`cacheOptions.key`) will have the request result\n   * and document cached.\n   *\n   * The cache key used is `requestConfig.cacheOptions.key`\n   * if present, falling back to `requestConfig.url`.\n   *\n   * Params are not serialized as part of the cache-key, so\n   * either ensure they are already in the url or utilize\n   * `requestConfig.cacheOptions.key`. For queries issued\n   * via the `POST` method `requestConfig.cacheOptions.key`\n   * MUST be supplied for the document to be cached.\n   *\n   * ## Requesting Without a Cache Key\n   *\n   * Resource data within the request is always updated in the cache,\n   * regardless of whether a cache key is present for the request.\n   *\n   * ## Fulfilling From Cache\n   *\n   * When a cache-key is determined, the request may fulfill\n   * from cache provided the cache is not stale.\n   *\n   * Cache staleness is determined by the configured CachePolicy\n   * with priority given to the `cacheOptions.reload` and\n   * `cacheOptions.backgroundReload` on the request if present.\n   *\n   * If the cache data has soft expired or the request asks for a background\n   * reload, the request will fulfill from cache if possible and\n   * make a non-blocking request in the background to update the cache.\n   *\n   * If the cache data has hard expired or the request asks for a reload,\n   * the request will not fulfill from cache and will make a blocking\n   * request to update the cache.\n   *\n   * ## The Response\n   *\n   * The primary difference between `requestManager.request` and `store.request`\n   * is that `store.request` will attempt to hydrate the response content into\n   * a response Document containing RecordInstances.\n   *\n   * @method request\n   * @param {StoreRequestInput} requestConfig\n   * @return {Future}\n   * @public\n   */request(requestConfig){// we lazily set the cache handler when we issue the first request\n// because constructor doesn't allow for this to run after\n// the user has had the chance to set the prop.\nconst opts={store:this,[_warp_drive_core_types_request__WEBPACK_IMPORTED_MODULE_1__.EnableHydration]:true};if(requestConfig.records){const identifierCache=this.identifierCache;opts.records=requestConfig.records.map(r=>identifierCache.getOrCreateRecordIdentifier(r));}{if(this.DISABLE_WAITER){opts.disableTestWaiter=typeof requestConfig.disableTestWaiter==='boolean'?requestConfig.disableTestWaiter:true;}}const request=Object.assign({},requestConfig,opts);const future=this.requestManager.request(request);future.onFinalize(()=>{// skip flush for legacy belongsTo\nif(requestConfig.op==='findBelongsTo'&&!requestConfig.url){return;}this.notifications._flush();});return future;}/**\n   * A hook which an app or addon may implement. Called when\n   * the Store is attempting to create a Record Instance for\n   * a resource.\n   *\n   * This hook can be used to select or instantiate any desired\n   * mechanism of presenting cache data to the ui for access\n   * mutation, and interaction.\n   *\n   * @method instantiateRecord (hook)\n   * @param identifier\n   * @param createRecordArgs\n   * @param recordDataFor deprecated use this.cache\n   * @param notificationManager deprecated use this.notifications\n   * @return A record instance\n   * @public\n   *//**\n   * A hook which an app or addon may implement. Called when\n   * the Store is destroying a Record Instance. This hook should\n   * be used to teardown any custom record instances instantiated\n   * with `instantiateRecord`.\n   *\n   * @method teardownRecord (hook)\n   * @public\n   * @param record\n   *//**\n    Returns the schema for a particular resource type (modelName).\n     When used with Model from @ember-data/model the return is the model class,\n    but this is not guaranteed.\n     If looking to query attribute or relationship information it is\n    recommended to use `getSchemaDefinitionService` instead. This method\n    should be considered legacy and exists primarily to continue to support\n    Adapter/Serializer APIs which expect it's return value in their method\n    signatures.\n     The class of a model might be useful if you want to get a list of all the\n    relationship names of the model, see\n    [`relationshipNames`](/ember-data/release/classes/Model?anchor=relationshipNames)\n    for example.\n     @method modelFor\n    @public\n    @deprecated\n    @param {string} type\n    @return {ModelSchema}\n    */modelFor(type){// FIXME add deprecation and deprecation stripping\n// FIXME/TODO update RFC to remove this method\n{assertDestroyedStoreOnly(this,'modelFor');}(test=>{if(!test){throw new Error(`You need to pass <type> to the store's modelFor method`);}})(typeof type==='string'&&type.length);(test=>{if(!test){throw new Error(`No model was found for '${type}' and no schema handles the type`);}})(this.schema.hasResource({type}));return getShimClass(this,type);}/**\n    Create a new record in the current store. The properties passed\n    to this method are set on the newly created record.\n     To create a new instance of a `Post`:\n     ```js\n    store.createRecord('post', {\n      title: 'Ember is awesome!'\n    });\n    ```\n     To create a new instance of a `Post` that has a relationship with a `User` record:\n     ```js\n    let user = this.store.peekRecord('user', '1');\n    store.createRecord('post', {\n      title: 'Ember is awesome!',\n      user: user\n    });\n    ```\n     @method createRecord\n    @public\n    @param {String} type the name of the resource\n    @param {Object} inputProperties a hash of properties to set on the\n      newly created record.\n    @return {Model} record\n  */createRecord(type,inputProperties){{assertDestroyingStore(this,'createRecord');}(test=>{if(!test){throw new Error(`You need to pass a model name to the store's createRecord method`);}})(type);(test=>{if(!test){throw new Error(`Passing classes to store methods has been removed. Please pass a dasherized string instead of ${type}`);}})(typeof type==='string');// This is wrapped in a `run.join` so that in test environments users do not need to manually wrap\n//   calls to `createRecord`. The run loop usage here is because we batch the joining and updating\n//   of record-arrays via ember's run loop, not our own.\n//\n//   to remove this, we would need to move to a new `async` API.\nlet record;this._join(()=>{const normalizedModelName=normalizeModelName(type);const properties={...inputProperties};// If the passed properties do not include a primary key,\n// give the adapter an opportunity to generate one. Typically,\n// client-side ID generators will use something like uuid.js\n// to avoid conflicts.\nlet id=null;if(properties.id===null||properties.id===undefined){const adapter=this.adapterFor?.(normalizedModelName,true);if(adapter&&adapter.generateIdForRecord){id=properties.id=coerceId(adapter.generateIdForRecord(this,normalizedModelName,properties));}else{id=properties.id=null;}}else{id=properties.id=coerceId(properties.id);}const resource={type:normalizedModelName,id};if(resource.id){const identifier=this.identifierCache.peekRecordIdentifier(resource);(test=>{if(!test){throw new Error(`The id ${String(properties.id)} has already been used with another '${normalizedModelName}' record.`);}})(!identifier);}const identifier=this.identifierCache.createIdentifierForNewRecord(resource);const cache=this.cache;const createOptions=normalizeProperties(this,identifier,properties);const resultProps=cache.clientDidCreate(identifier,createOptions);record=this._instanceCache.getRecord(identifier,resultProps);});return record;}/**\n    For symmetry, a record can be deleted via the store.\n     Example\n     ```javascript\n    let post = store.createRecord('post', {\n      title: 'Ember is awesome!'\n    });\n     store.deleteRecord(post);\n    ```\n     @method deleteRecord\n    @public\n    @param {unknown} record\n  */deleteRecord(record){{assertDestroyingStore(this,'deleteRecord');}const identifier=peekRecordIdentifier(record);const cache=this.cache;(test=>{if(!test){throw new Error(`expected the record to be connected to a cache`);}})(identifier);this._join(()=>{cache.setIsDeleted(identifier,true);if(cache.isNew(identifier)){this._instanceCache.unloadRecord(identifier);}});}/**\n    For symmetry, a record can be unloaded via the store.\n    This will cause the record to be destroyed and freed up for garbage collection.\n     Example\n     ```javascript\n    store.findRecord('post', '1').then(function(post) {\n      store.unloadRecord(post);\n    });\n    ```\n     @method unloadRecord\n    @public\n    @param {Model} record\n  */unloadRecord(record){{assertDestroyingStore(this,'unloadRecord');}const identifier=peekRecordIdentifier(record);if(identifier){this._instanceCache.unloadRecord(identifier);}}/**\n    This method returns a record for a given identifier or type and id combination.\n     The `findRecord` method will always resolve its promise with the same\n    object for a given identifier or type and `id`.\n     The `findRecord` method will always return a **promise** that will be\n    resolved with the record.\n     **Example 1**\n     ```app/routes/post.js\n    export default class PostRoute extends Route {\n      model({ post_id }) {\n        return this.store.findRecord('post', post_id);\n      }\n    }\n    ```\n     **Example 2**\n     `findRecord` can be called with a single identifier argument instead of the combination\n    of `type` (modelName) and `id` as separate arguments. You may recognize this combo as\n    the typical pairing from [JSON:API](https://jsonapi.org/format/#document-resource-object-identification)\n     ```app/routes/post.js\n    export default class PostRoute extends Route {\n      model({ post_id: id }) {\n        return this.store.findRecord({ type: 'post', id });\n      }\n    }\n    ```\n     **Example 3**\n     If you have previously received an lid via an Identifier for this record, and the record\n    has already been assigned an id, you can find the record again using just the lid.\n     ```app/routes/post.js\n    store.findRecord({ lid });\n    ```\n     If the record is not yet available, the store will ask the adapter's `findRecord`\n    method to retrieve and supply the necessary data. If the record is already present\n    in the store, it depends on the reload behavior _when_ the returned promise\n    resolves.\n     ### Preloading\n     You can optionally `preload` specific attributes and relationships that you know of\n    by passing them via the passed `options`.\n     For example, if your Ember route looks like `/posts/1/comments/2` and your API route\n    for the comment also looks like `/posts/1/comments/2` if you want to fetch the comment\n    without also fetching the post you can pass in the post to the `findRecord` call:\n     ```app/routes/post-comments.js\n    export default class PostRoute extends Route {\n      model({ post_id, comment_id: id }) {\n        return this.store.findRecord({ type: 'comment', id, { preload: { post: post_id }} });\n      }\n    }\n    ```\n     In your adapter you can then access this id without triggering a network request via the\n    snapshot:\n     ```app/adapters/application.js\n    export default class Adapter {\n       findRecord(store, schema, id, snapshot) {\n        let type = schema.modelName;\n         if (type === 'comment')\n          let postId = snapshot.belongsTo('post', { id: true });\n           return fetch(`./posts/${postId}/comments/${id}`)\n            .then(response => response.json())\n        }\n      }\n       static create() {\n        return new this();\n      }\n    }\n    ```\n     This could also be achieved by supplying the post id to the adapter via the adapterOptions\n    property on the options hash.\n     ```app/routes/post-comments.js\n    export default class PostRoute extends Route {\n      model({ post_id, comment_id: id }) {\n        return this.store.findRecord({ type: 'comment', id, { adapterOptions: { post: post_id }} });\n      }\n    }\n    ```\n     ```app/adapters/application.js\n    export default class Adapter {\n      findRecord(store, schema, id, snapshot) {\n        let type = schema.modelName;\n         if (type === 'comment')\n          let postId = snapshot.adapterOptions.post;\n           return fetch(`./posts/${postId}/comments/${id}`)\n            .then(response => response.json())\n        }\n      }\n       static create() {\n        return new this();\n      }\n    }\n    ```\n     If you have access to the post model you can also pass the model itself to preload:\n     ```javascript\n    let post = await store.findRecord('post', '1');\n    let comment = await store.findRecord('comment', '2', { post: myPostModel });\n    ```\n     ### Reloading\n     The reload behavior is configured either via the passed `options` hash or\n    the result of the adapter's `shouldReloadRecord`.\n     If `{ reload: true }` is passed or `adapter.shouldReloadRecord` evaluates\n    to `true`, then the returned promise resolves once the adapter returns\n    data, regardless if the requested record is already in the store:\n     ```js\n    store.push({\n      data: {\n        id: 1,\n        type: 'post',\n        revision: 1\n      }\n    });\n     // adapter#findRecord resolves with\n    // [\n    //   {\n    //     id: 1,\n    //     type: 'post',\n    //     revision: 2\n    //   }\n    // ]\n    store.findRecord('post', '1', { reload: true }).then(function(post) {\n      post.revision; // 2\n    });\n    ```\n     If no reload is indicated via the above mentioned ways, then the promise\n    immediately resolves with the cached version in the store.\n     ### Background Reloading\n     Optionally, if `adapter.shouldBackgroundReloadRecord` evaluates to `true`,\n    then a background reload is started, which updates the records' data, once\n    it is available:\n     ```js\n    // app/adapters/post.js\n    import ApplicationAdapter from \"./application\";\n     export default class PostAdapter extends ApplicationAdapter {\n      shouldReloadRecord(store, snapshot) {\n        return false;\n      },\n       shouldBackgroundReloadRecord(store, snapshot) {\n        return true;\n      }\n    });\n     // ...\n     store.push({\n      data: {\n        id: 1,\n        type: 'post',\n        revision: 1\n      }\n    });\n     let blogPost = store.findRecord('post', '1').then(function(post) {\n      post.revision; // 1\n    });\n     // later, once adapter#findRecord resolved with\n    // [\n    //   {\n    //     id: 1,\n    //     type: 'post',\n    //     revision: 2\n    //   }\n    // ]\n     blogPost.revision; // 2\n    ```\n     If you would like to force or prevent background reloading, you can set a\n    boolean value for `backgroundReload` in the options object for\n    `findRecord`.\n     ```app/routes/post/edit.js\n    export default class PostEditRoute extends Route {\n      model(params) {\n        return this.store.findRecord('post', params.post_id, { backgroundReload: false });\n      }\n    }\n    ```\n     If you pass an object on the `adapterOptions` property of the options\n    argument it will be passed to your adapter via the snapshot\n     ```app/routes/post/edit.js\n    export default class PostEditRoute extends Route {\n      model(params) {\n        return this.store.findRecord('post', params.post_id, {\n          adapterOptions: { subscribe: false }\n        });\n      }\n    }\n    ```\n     ```app/adapters/post.js\n    import MyCustomAdapter from './custom-adapter';\n     export default class PostAdapter extends MyCustomAdapter {\n      findRecord(store, type, id, snapshot) {\n        if (snapshot.adapterOptions.subscribe) {\n          // ...\n        }\n        // ...\n      }\n    }\n    ```\n     See [peekRecord](../methods/peekRecord?anchor=peekRecord) to get the cached version of a record.\n     ### Retrieving Related Model Records\n     If you use an adapter such as Ember's default\n    [`JSONAPIAdapter`](/ember-data/release/classes/JSONAPIAdapter)\n    that supports the [JSON API specification](http://jsonapi.org/) and if your server\n    endpoint supports the use of an\n    ['include' query parameter](http://jsonapi.org/format/#fetching-includes),\n    you can use `findRecord()` or `findAll()` to automatically retrieve additional records related to\n    the one you request by supplying an `include` parameter in the `options` object.\n     For example, given a `post` model that has a `hasMany` relationship with a `comment`\n    model, when we retrieve a specific post we can have the server also return that post's\n    comments in the same request:\n     ```app/routes/post.js\n    export default class PostRoute extends Route {\n      model(params) {\n        return this.store.findRecord('post', params.post_id, { include: ['comments'] });\n      }\n    }\n    ```\n     ```app/adapters/application.js\n    export default class Adapter {\n      findRecord(store, schema, id, snapshot) {\n        let type = schema.modelName;\n         if (type === 'post')\n          let includes = snapshot.adapterOptions.include;\n           return fetch(`./posts/${postId}?include=${includes}`)\n            .then(response => response.json())\n        }\n      }\n       static create() {\n        return new this();\n      }\n    }\n    ```\n     In this case, the post's comments would then be available in your template as\n    `model.comments`.\n     Multiple relationships can be requested using an `include` parameter consisting of a\n    list of relationship names, while nested relationships can be specified\n    using a dot-separated sequence of relationship names. So to request both the post's\n    comments and the authors of those comments the request would look like this:\n     ```app/routes/post.js\n    export default class PostRoute extends Route {\n      model(params) {\n        return this.store.findRecord('post', params.post_id, { include: ['comments','comments.author'] });\n      }\n    }\n    ```\n     ### Retrieving Specific Fields by Type\n     If your server endpoint supports the use of a ['fields' query parameter](https://jsonapi.org/format/#fetching-sparse-fieldsets),\n    you can use pass those fields through to your server.  At this point in time, this requires a few manual steps on your part.\n     1. Implement `buildQuery` in your adapter.\n     ```app/adapters/application.js\n    buildQuery(snapshot) {\n      let query = super.buildQuery(...arguments);\n       let { fields } = snapshot.adapterOptions;\n       if (fields) {\n        query.fields = fields;\n      }\n       return query;\n    }\n    ```\n     2. Then pass through the applicable fields to your `findRecord` request.\n     Given a `post` model with attributes body, title, publishDate and meta, you can retrieve a filtered list of attributes.\n     ```app/routes/post.js\n    export default class extends Route {\n      model(params) {\n        return this.store.findRecord('post', params.post_id, { adapterOptions: { fields: { post: 'body,title' } });\n      }\n    }\n    ```\n     Moreover, you can filter attributes on related models as well. If a `post` has a `belongsTo` relationship to a user,\n    just include the relationship key and attributes.\n     ```app/routes/post.js\n    export default class extends Route {\n      model(params) {\n        return this.store.findRecord('post', params.post_id, { adapterOptions: { fields: { post: 'body,title', user: 'name,email' } });\n      }\n    }\n    ```\n     @since 1.13.0\n    @method findRecord\n    @public\n    @param {String|object} type - either a string representing the name of the resource or a ResourceIdentifier object containing both the type (a string) and the id (a string) for the record or an lid (a string) of an existing record\n    @param {(String|Integer|Object)} id - optional object with options for the request only if the first param is a ResourceIdentifier, else the string id of the record to be retrieved\n    @param {Object} [options] - if the first param is a string this will be the optional options for the request. See examples for available options.\n    @return {Promise} promise\n  */findRecord(resource,id,options){{assertDestroyingStore(this,'findRecord');}(test=>{if(!test){throw new Error(`You need to pass a modelName or resource identifier as the first argument to the store's findRecord method`);}})(resource);if(isMaybeIdentifier(resource)){options=id;}else{(test=>{if(!test){throw new Error(`Passing classes to store methods has been removed. Please pass a dasherized string instead of ${resource}`);}})(typeof resource==='string');const type=normalizeModelName(resource);const normalizedId=ensureStringId(id);resource=constructResource(type,normalizedId);}const identifier=this.identifierCache.getOrCreateRecordIdentifier(resource);options=options||{};if(options.preload){// force reload if we preload to ensure we don't resolve the promise\n// until we are complete, else we will end up background-reloading\n// even for initial load.\nif(!this._instanceCache.recordIsLoaded(identifier)){options.reload=true;}this._join(()=>{preloadData(this,identifier,options.preload);});}const promise=this.request({op:'findRecord',data:{record:identifier,options},cacheOptions:{[_warp_drive_core_types_request__WEBPACK_IMPORTED_MODULE_1__.SkipCache]:true}});return promise.then(document=>{return document.content;});}/**\n    Get the reference for the specified record.\n     Example\n     ```javascript\n    let userRef = store.getReference('user', '1');\n     // check if the user is loaded\n    let isLoaded = userRef.value() !== null;\n     // get the record of the reference (null if not yet available)\n    let user = userRef.value();\n     // get the identifier of the reference\n    if (userRef.remoteType() === 'id') {\n    let id = userRef.id();\n    }\n     // load user (via store.find)\n    userRef.load().then(...)\n     // or trigger a reload\n    userRef.reload().then(...)\n     // provide data for reference\n    userRef.push({ id: 1, username: '@user' }).then(function(user) {\n      userRef.value() === user;\n    });\n    ```\n     @method getReference\n    @public\n    @param {String|object} resource - modelName (string) or Identifier (object)\n    @param {String|Integer} id\n    @since 2.5.0\n    @return {RecordReference}\n  */// TODO @deprecate getReference (and references generally)\ngetReference(resource,id){{assertDestroyingStore(this,'getReference');}let resourceIdentifier;if(arguments.length===1&&isMaybeIdentifier(resource)){resourceIdentifier=resource;}else{const type=normalizeModelName(resource);const normalizedId=ensureStringId(id);resourceIdentifier=constructResource(type,normalizedId);}(test=>{if(!test){throw new Error('getReference expected to receive either a resource identifier or type and id as arguments');}})(isMaybeIdentifier(resourceIdentifier));const identifier=this.identifierCache.getOrCreateRecordIdentifier(resourceIdentifier);return this._instanceCache.getReference(identifier);}/**\n    Get a record by a given type and ID without triggering a fetch.\n     This method will synchronously return the record if it is available in the store,\n    otherwise it will return `null`. A record is available if it has been fetched earlier, or\n    pushed manually into the store.\n     See [findRecord](../methods/findRecord?anchor=findRecord) if you would like to request this record from the backend.\n     _Note: This is a synchronous method and does not return a promise._\n     **Example 1**\n     ```js\n    let post = store.peekRecord('post', '1');\n     post.id; // '1'\n    ```\n     `peekRecord` can be called with a single identifier argument instead of the combination\n    of `type` (modelName) and `id` as separate arguments. You may recognize this combo as\n    the typical pairing from [JSON:API](https://jsonapi.org/format/#document-resource-object-identification)\n     **Example 2**\n     ```js\n    let post = store.peekRecord({ type: 'post', id });\n    post.id; // '1'\n    ```\n     If you have previously received an lid from an Identifier for this record, you can lookup the record again using\n    just the lid.\n     **Example 3**\n     ```js\n    let post = store.peekRecord({ lid });\n    post.id; // '1'\n    ```\n      @since 1.13.0\n    @method peekRecord\n    @public\n    @param {String|object} modelName - either a string representing the modelName or a ResourceIdentifier object containing both the type (a string) and the id (a string) for the record or an lid (a string) of an existing record\n    @param {String|Integer} id - optional only if the first param is a ResourceIdentifier, else the string id of the record to be retrieved.\n    @return {Model|null} record\n  */peekRecord(identifier,id){if(arguments.length===1&&isMaybeIdentifier(identifier)){const stableIdentifier=this.identifierCache.peekRecordIdentifier(identifier);const isLoaded=stableIdentifier&&this._instanceCache.recordIsLoaded(stableIdentifier);// TODO come up with a better mechanism for determining if we have data and could peek.\n// this is basically an \"are we not empty\" query.\nreturn isLoaded?this._instanceCache.getRecord(stableIdentifier):null;}{assertDestroyingStore(this,'peekRecord');}(test=>{if(!test){throw new Error(`You need to pass a model name to the store's peekRecord method`);}})(identifier);(test=>{if(!test){throw new Error(`Passing classes to store methods has been removed. Please pass a dasherized string instead of ${String(identifier)}`);}})(typeof identifier==='string');const type=normalizeModelName(identifier);const normalizedId=ensureStringId(id);const resource={type,id:normalizedId};const stableIdentifier=this.identifierCache.peekRecordIdentifier(resource);const isLoaded=stableIdentifier&&this._instanceCache.recordIsLoaded(stableIdentifier);return isLoaded?this._instanceCache.getRecord(stableIdentifier):null;}/**\n    This method delegates a query to the adapter. This is the one place where\n    adapter-level semantics are exposed to the application.\n     Each time this method is called a new request is made through the adapter.\n     Exposing queries this way seems preferable to creating an abstract query\n    language for all server-side queries, and then require all adapters to\n    implement them.\n     ---\n     If you do something like this:\n     ```javascript\n    store.query('person', { page: 1 });\n    ```\n     The request made to the server will look something like this:\n     ```\n    GET \"/api/v1/person?page=1\"\n    ```\n     ---\n     If you do something like this:\n     ```javascript\n    store.query('person', { ids: ['1', '2', '3'] });\n    ```\n     The request made to the server will look something like this:\n     ```\n    GET \"/api/v1/person?ids%5B%5D=1&ids%5B%5D=2&ids%5B%5D=3\"\n    decoded: \"/api/v1/person?ids[]=1&ids[]=2&ids[]=3\"\n    ```\n     This method returns a promise, which is resolved with a\n    [`Collection`](/ember-data/release/classes/Collection)\n    once the server returns.\n     @since 1.13.0\n    @method query\n    @public\n    @param {String} type the name of the resource\n    @param {object} query a query to be used by the adapter\n    @param {Object} options optional, may include `adapterOptions` hash which will be passed to adapter.query\n    @return {Promise} promise\n  */query(type,query,options={}){{assertDestroyingStore(this,'query');}(test=>{if(!test){throw new Error(`You need to pass a model name to the store's query method`);}})(type);(test=>{if(!test){throw new Error(`You need to pass a query hash to the store's query method`);}})(query);(test=>{if(!test){throw new Error(`Passing classes to store methods has been removed. Please pass a dasherized string instead of ${type}`);}})(typeof type==='string');const promise=this.request({op:'query',data:{type:normalizeModelName(type),query,options:options},cacheOptions:{[_warp_drive_core_types_request__WEBPACK_IMPORTED_MODULE_1__.SkipCache]:true}});return promise.then(document=>document.content);}/**\n    This method makes a request for one record, where the `id` is not known\n    beforehand (if the `id` is known, use [`findRecord`](../methods/findRecord?anchor=findRecord)\n    instead).\n     This method can be used when it is certain that the server will return a\n    single object for the primary data.\n     Each time this method is called a new request is made through the adapter.\n     Let's assume our API provides an endpoint for the currently logged in user\n    via:\n     ```\n    // GET /api/current_user\n    {\n      user: {\n        id: 1234,\n        username: 'admin'\n      }\n    }\n    ```\n     Since the specific `id` of the `user` is not known beforehand, we can use\n    `queryRecord` to get the user:\n     ```javascript\n    store.queryRecord('user', {}).then(function(user) {\n      let username = user.username;\n      // do thing\n    });\n    ```\n     The request is made through the adapters' `queryRecord`:\n     ```app/adapters/user.js\n    import Adapter from '@ember-data/adapter';\n    import $ from 'jquery';\n     export default class UserAdapter extends Adapter {\n      queryRecord(modelName, query) {\n        return $.getJSON('/api/current_user');\n      }\n    }\n    ```\n     Note: the primary use case for `store.queryRecord` is when a single record\n    is queried and the `id` is not known beforehand. In all other cases\n    `store.query` and using the first item of the array is likely the preferred\n    way:\n     ```\n    // GET /users?username=unique\n    {\n      data: [{\n        id: 1234,\n        type: 'user',\n        attributes: {\n          username: \"unique\"\n        }\n      }]\n    }\n    ```\n     ```javascript\n    store.query('user', { username: 'unique' }).then(function(users) {\n      return users.firstObject;\n    }).then(function(user) {\n      let id = user.id;\n    });\n    ```\n     This method returns a promise, which resolves with the found record.\n     If the adapter returns no data for the primary data of the payload, then\n    `queryRecord` resolves with `null`:\n     ```\n    // GET /users?username=unique\n    {\n      data: null\n    }\n    ```\n     ```javascript\n    store.queryRecord('user', { username: 'unique' }).then(function(user) {\n       // user is null\n    });\n    ```\n     @since 1.13.0\n    @method queryRecord\n    @public\n    @param {string} type\n    @param {object} query an opaque query to be used by the adapter\n    @param {object} options optional, may include `adapterOptions` hash which will be passed to adapter.queryRecord\n    @return {Promise} promise which resolves with the found record or `null`\n  */queryRecord(type,query,options){{assertDestroyingStore(this,'queryRecord');}(test=>{if(!test){throw new Error(`You need to pass a model name to the store's queryRecord method`);}})(type);(test=>{if(!test){throw new Error(`You need to pass a query hash to the store's queryRecord method`);}})(query);(test=>{if(!test){throw new Error(`Passing classes to store methods has been removed. Please pass a dasherized string instead of ${type}`);}})(typeof type==='string');const promise=this.request({op:'queryRecord',data:{type:normalizeModelName(type),query,options:options||{}},cacheOptions:{[_warp_drive_core_types_request__WEBPACK_IMPORTED_MODULE_1__.SkipCache]:true}});return promise.then(document=>document.content);}/**\n    `findAll` asks the adapter's `findAll` method to find the records for the\n    given type, and returns a promise which will resolve with all records of\n    this type present in the store, even if the adapter only returns a subset\n    of them.\n     ```app/routes/authors.js\n    export default class AuthorsRoute extends Route {\n      model(params) {\n        return this.store.findAll('author');\n      }\n    }\n    ```\n     _When_ the returned promise resolves depends on the reload behavior,\n    configured via the passed `options` hash and the result of the adapter's\n    `shouldReloadAll` method.\n     ### Reloading\n     If `{ reload: true }` is passed or `adapter.shouldReloadAll` evaluates to\n    `true`, then the returned promise resolves once the adapter returns data,\n    regardless if there are already records in the store:\n     ```js\n    store.push({\n      data: {\n        id: 'first',\n        type: 'author'\n      }\n    });\n     // adapter#findAll resolves with\n    // [\n    //   {\n    //     id: 'second',\n    //     type: 'author'\n    //   }\n    // ]\n    store.findAll('author', { reload: true }).then(function(authors) {\n      authors.getEach('id'); // ['first', 'second']\n    });\n    ```\n     If no reload is indicated via the above mentioned ways, then the promise\n    immediately resolves with all the records currently loaded in the store.\n     ### Background Reloading\n     Optionally, if `adapter.shouldBackgroundReloadAll` evaluates to `true`,\n    then a background reload is started. Once this resolves, the array with\n    which the promise resolves, is updated automatically so it contains all the\n    records in the store:\n     ```app/adapters/application.js\n    import Adapter from '@ember-data/adapter';\n     export default class ApplicationAdapter extends Adapter {\n      shouldReloadAll(store, snapshotsArray) {\n        return false;\n      },\n       shouldBackgroundReloadAll(store, snapshotsArray) {\n        return true;\n      }\n    });\n     // ...\n     store.push({\n      data: {\n        id: 'first',\n        type: 'author'\n      }\n    });\n     let allAuthors;\n    store.findAll('author').then(function(authors) {\n      authors.getEach('id'); // ['first']\n       allAuthors = authors;\n    });\n     // later, once adapter#findAll resolved with\n    // [\n    //   {\n    //     id: 'second',\n    //     type: 'author'\n    //   }\n    // ]\n     allAuthors.getEach('id'); // ['first', 'second']\n    ```\n     If you would like to force or prevent background reloading, you can set a\n    boolean value for `backgroundReload` in the options object for\n    `findAll`.\n     ```app/routes/post/edit.js\n    export default class PostEditRoute extends Route {\n      model() {\n        return this.store.findAll('post', { backgroundReload: false });\n      }\n    }\n    ```\n     If you pass an object on the `adapterOptions` property of the options\n    argument it will be passed to you adapter via the `snapshotRecordArray`\n     ```app/routes/posts.js\n    export default class PostsRoute extends Route {\n      model(params) {\n        return this.store.findAll('post', {\n          adapterOptions: { subscribe: false }\n        });\n      }\n    }\n    ```\n     ```app/adapters/post.js\n    import MyCustomAdapter from './custom-adapter';\n     export default class UserAdapter extends MyCustomAdapter {\n      findAll(store, type, sinceToken, snapshotRecordArray) {\n        if (snapshotRecordArray.adapterOptions.subscribe) {\n          // ...\n        }\n        // ...\n      }\n    }\n    ```\n     See [peekAll](../methods/peekAll?anchor=peekAll) to get an array of current records in the\n    store, without waiting until a reload is finished.\n     ### Retrieving Related Model Records\n     If you use an adapter such as Ember's default\n    [`JSONAPIAdapter`](/ember-data/release/classes/JSONAPIAdapter)\n    that supports the [JSON API specification](http://jsonapi.org/) and if your server\n    endpoint supports the use of an\n    ['include' query parameter](http://jsonapi.org/format/#fetching-includes),\n    you can use `findAll()` to automatically retrieve additional records related to\n    those requested by supplying an `include` parameter in the `options` object.\n     For example, given a `post` model that has a `hasMany` relationship with a `comment`\n    model, when we retrieve all of the post records we can have the server also return\n    all of the posts' comments in the same request:\n     ```app/routes/posts.js\n    export default class PostsRoute extends Route {\n      model() {\n        return this.store.findAll('post', { include: ['comments'] });\n      }\n    }\n    ```\n    Multiple relationships can be requested using an `include` parameter consisting of a\n    list or relationship names, while nested relationships can be specified\n    using a dot-separated sequence of relationship names. So to request both the posts'\n    comments and the authors of those comments the request would look like this:\n     ```app/routes/posts.js\n    export default class PostsRoute extends Route {\n      model() {\n        return this.store.findAll('post', { include: ['comments','comments.author'] });\n      }\n    }\n    ```\n     See [query](../methods/query?anchor=query) to only get a subset of records from the server.\n     @since 1.13.0\n    @method findAll\n    @public\n    @param {string} type the name of the resource\n    @param {object} options\n    @return {Promise} promise\n  */findAll(type,options={}){{assertDestroyingStore(this,'findAll');}(test=>{if(!test){throw new Error(`You need to pass a model name to the store's findAll method`);}})(type);(test=>{if(!test){throw new Error(`Passing classes to store methods has been removed. Please pass a dasherized string instead of ${type}`);}})(typeof type==='string');const promise=this.request({op:'findAll',data:{type:normalizeModelName(type),options:options||{}},cacheOptions:{[_warp_drive_core_types_request__WEBPACK_IMPORTED_MODULE_1__.SkipCache]:true}});return promise.then(document=>document.content);}/**\n    This method returns a filtered array that contains all of the\n    known records for a given type in the store.\n     Note that because it's just a filter, the result will contain any\n    locally created records of the type, however, it will not make a\n    request to the backend to retrieve additional records. If you\n    would like to request all the records from the backend please use\n    [store.findAll](../methods/findAll?anchor=findAll).\n     Also note that multiple calls to `peekAll` for a given type will always\n    return the same `RecordArray`.\n     Example\n     ```javascript\n    let localPosts = store.peekAll('post');\n    ```\n     @since 1.13.0\n    @method peekAll\n    @public\n    @param {string} type the name of the resource\n    @return {RecordArray}\n  */peekAll(type){{assertDestroyingStore(this,'peekAll');}(test=>{if(!test){throw new Error(`You need to pass a model name to the store's peekAll method`);}})(type);(test=>{if(!test){throw new Error(`Passing classes to store methods has been removed. Please pass a dasherized string instead of ${type}`);}})(typeof type==='string');return this.recordArrayManager.liveArrayFor(normalizeModelName(type));}/**\n    This method unloads all records in the store.\n    It schedules unloading to happen during the next run loop.\n     Optionally you can pass a type which unload all records for a given type.\n     ```javascript\n    store.unloadAll();\n    store.unloadAll('post');\n    ```\n     @method unloadAll\n    @param {string} type the name of the resource\n    @public\n  */unloadAll(type){{assertDestroyedStoreOnly(this,'unloadAll');}(test=>{if(!test){throw new Error(`Passing classes to store methods has been removed. Please pass a dasherized string instead of ${String(type)}`);}})(!type||typeof type==='string');this._join(()=>{if(type===undefined){// destroy the graph before unloadAll\n// since then we avoid churning relationships\n// during unload\nthis._graph?.identifiers.clear();this.recordArrayManager.clear();this._instanceCache.clear();}else{this._instanceCache.clear(normalizeModelName(type));}});}/**\n    Push some data for a given type into the store.\n     This method expects normalized [JSON API](http://jsonapi.org/) document. This means you have to follow [JSON API specification](http://jsonapi.org/format/) with few minor adjustments:\n    - record's `type` should always be in singular, dasherized form\n    - members (properties) should be camelCased\n     [Your primary data should be wrapped inside `data` property](http://jsonapi.org/format/#document-top-level):\n     ```js\n    store.push({\n      data: {\n        // primary data for single record of type `Person`\n        id: '1',\n        type: 'person',\n        attributes: {\n          firstName: 'Daniel',\n          lastName: 'Kmak'\n        }\n      }\n    });\n    ```\n     [Demo.](http://ember-twiddle.com/fb99f18cd3b4d3e2a4c7)\n     `data` property can also hold an array (of records):\n     ```js\n    store.push({\n      data: [\n        // an array of records\n        {\n          id: '1',\n          type: 'person',\n          attributes: {\n            firstName: 'Daniel',\n            lastName: 'Kmak'\n          }\n        },\n        {\n          id: '2',\n          type: 'person',\n          attributes: {\n            firstName: 'Tom',\n            lastName: 'Dale'\n          }\n        }\n      ]\n    });\n    ```\n     [Demo.](http://ember-twiddle.com/69cdbeaa3702159dc355)\n     There are some typical properties for `JSONAPI` payload:\n    * `id` - mandatory, unique record's key\n    * `type` - mandatory string which matches `model`'s dasherized name in singular form\n    * `attributes` - object which holds data for record attributes - `attr`'s declared in model\n    * `relationships` - object which must contain any of the following properties under each relationships' respective key (example path is `relationships.achievements.data`):\n      - [`links`](http://jsonapi.org/format/#document-links)\n      - [`data`](http://jsonapi.org/format/#document-resource-object-linkage) - place for primary data\n      - [`meta`](http://jsonapi.org/format/#document-meta) - object which contains meta-information about relationship\n     For this model:\n     ```app/models/person.js\n    import Model, { attr, hasMany } from '@ember-data/model';\n     export default class PersonRoute extends Route {\n      @attr('string') firstName;\n      @attr('string') lastName;\n       @hasMany('person') children;\n    }\n    ```\n     To represent the children as IDs:\n     ```js\n    {\n      data: {\n        id: '1',\n        type: 'person',\n        attributes: {\n          firstName: 'Tom',\n          lastName: 'Dale'\n        },\n        relationships: {\n          children: {\n            data: [\n              {\n                id: '2',\n                type: 'person'\n              },\n              {\n                id: '3',\n                type: 'person'\n              },\n              {\n                id: '4',\n                type: 'person'\n              }\n            ]\n          }\n        }\n      }\n    }\n    ```\n     [Demo.](http://ember-twiddle.com/343e1735e034091f5bde)\n     To represent the children relationship as a URL:\n     ```js\n    {\n      data: {\n        id: '1',\n        type: 'person',\n        attributes: {\n          firstName: 'Tom',\n          lastName: 'Dale'\n        },\n        relationships: {\n          children: {\n            links: {\n              related: '/people/1/children'\n            }\n          }\n        }\n      }\n    }\n    ```\n     If you're streaming data or implementing an adapter, make sure\n    that you have converted the incoming data into this form. The\n    store's [normalize](../methods/normalize?anchor=normalize) method is a convenience\n    helper for converting a json payload into the form Ember Data\n    expects.\n     ```js\n    store.push(store.normalize('person', data));\n    ```\n     This method can be used both to push in brand new\n    records, as well as to update existing records.\n     @method push\n    @public\n    @param {Object} data\n    @return the record(s) that was created or\n      updated.\n  */push(data){{assertDestroyingStore(this,'push');}const pushed=this._push(data,false);if(Array.isArray(pushed)){return pushed.map(identifier=>this._instanceCache.getRecord(identifier));}if(pushed===null){return null;}return this._instanceCache.getRecord(pushed);}/**\n    Push some data in the form of a json-api document into the store,\n    without creating materialized records.\n     @method _push\n    @private\n    @param {Object} jsonApiDoc\n    @return {StableRecordIdentifier|Array<StableRecordIdentifier>|null} identifiers for the primary records that had data loaded\n  */_push(jsonApiDoc,asyncFlush){{assertDestroyingStore(this,'_push');}if(asyncFlush){this._enableAsyncFlush=true;}let ret;this._join(()=>{ret=this.cache.put({content:jsonApiDoc});});this._enableAsyncFlush=null;return'data'in ret?ret.data:null;}/**\n   * Trigger a save for a Record.\n   *\n   * Returns a promise resolving with the same record when the save is complete.\n   *\n   * @method saveRecord\n   * @public\n   * @param {unknown} record\n   * @param options\n   * @return {Promise<record>}\n   */saveRecord(record,options={}){{assertDestroyingStore(this,'saveRecord');}(test=>{if(!test){throw new Error(`Unable to initiate save for a record in a disconnected state`);}})(storeFor(record));const identifier=recordIdentifierFor(record);const cache=this.cache;if(!identifier){// this commonly means we're disconnected\n// but just in case we reject here to prevent bad things.\nreturn Promise.reject(new Error(`Record Is Disconnected`));}(test=>{if(!test){throw new Error(`Cannot initiate a save request for an unloaded record: ${identifier.lid}`);}})(this._instanceCache.recordIsLoaded(identifier));if(resourceIsFullyDeleted(this._instanceCache,identifier)){return Promise.resolve(record);}if(!options){options={};}let operation='updateRecord';if(cache.isNew(identifier)){operation='createRecord';}else if(cache.isDeleted(identifier)){operation='deleteRecord';}const request={op:operation,data:{options,record:identifier},records:[identifier],cacheOptions:{[_warp_drive_core_types_request__WEBPACK_IMPORTED_MODULE_1__.SkipCache]:true}};return this.request(request).then(document=>document.content);}/**\n   * Instantiation hook allowing applications or addons to configure the store\n   * to utilize a custom Cache implementation.\n   *\n   * This hook should not be called directly by consuming applications or libraries.\n   * Use `Store.cache` to access the Cache instance.\n   *\n   * @method createCache (hook)\n   * @public\n   * @param storeWrapper\n   * @return {Cache}\n   *//**\n   * Returns the cache instance associated to this Store, instantiates the Cache\n   * if necessary via `Store.createCache`\n   *\n   * @property {Cache} cache\n   * @public\n   */get cache(){let{cache}=this._instanceCache;if(!cache){cache=this._instanceCache.cache=this.createCache(this._instanceCache._storeWrapper);{cache=new CacheManager(cache);}}return cache;}destroy(){if(this.isDestroyed){// @ember/test-helpers will call destroy multiple times\nreturn;}this.isDestroying=true;this._graph?.destroy();this._graph=undefined;this.notifications.destroy();this.recordArrayManager.destroy();this.identifierCache.destroy();this.unloadAll();this.isDestroyed=true;}static create(args){return new this(args);}}{Store.prototype.getSchemaDefinitionService=function(){(test=>{if(!test){throw new Error(`You must registerSchemaDefinitionService with the store to use custom model classes`);}})(this._schema);(0,_ember_debug__WEBPACK_IMPORTED_MODULE_0__.deprecate)(`Use \\`store.schema\\` instead of \\`store.getSchemaDefinitionService()\\``,false,{id:'ember-data:schema-service-updates',until:'5.0',for:'ember-data',since:{available:'5.4',enabled:'5.4'}});return this._schema;};Store.prototype.registerSchemaDefinitionService=function(schema){(0,_ember_debug__WEBPACK_IMPORTED_MODULE_0__.deprecate)(`Use \\`store.createSchemaService\\` instead of \\`store.registerSchemaDefinitionService()\\``,false,{id:'ember-data:schema-service-updates',until:'5.0',for:'ember-data',since:{available:'5.4',enabled:'5.4'}});this._schema=schema;};Store.prototype.registerSchema=function(schema){(0,_ember_debug__WEBPACK_IMPORTED_MODULE_0__.deprecate)(`Use \\`store.createSchemaService\\` instead of \\`store.registerSchema()\\``,false,{id:'ember-data:schema-service-updates',until:'5.0',for:'ember-data',since:{available:'5.4',enabled:'5.4'}});this._schema=schema;};}let assertDestroyingStore;let assertDestroyedStoreOnly;{// eslint-disable-next-line @typescript-eslint/no-shadow\nassertDestroyingStore=function assertDestroyingStore(store,method){(test=>{if(!test){throw new Error(`Attempted to call store.${method}(), but the store instance has already been destroyed.`);}})(!(store.isDestroying||store.isDestroyed));};// eslint-disable-next-line @typescript-eslint/no-shadow\nassertDestroyedStoreOnly=function assertDestroyedStoreOnly(store,method){(test=>{if(!test){throw new Error(`Attempted to call store.${method}(), but the store instance has already been destroyed.`);}})(!store.isDestroyed);};}function isMaybeIdentifier(maybeIdentifier){return Boolean(maybeIdentifier!==null&&typeof maybeIdentifier==='object'&&('id'in maybeIdentifier&&'type'in maybeIdentifier&&maybeIdentifier.id&&maybeIdentifier.type||maybeIdentifier.lid));}function normalizeProperties(store,identifier,properties){// assert here\nif(properties!==undefined){if('id'in properties){(test=>{if(!test){throw new Error(`expected id to be a string or null`);}})(properties.id!==undefined);}(test=>{if(!test){throw new Error(`You passed '${typeof properties}' as properties for record creation instead of an object.`);}})(typeof properties==='object'&&properties!==null);const{type}=identifier;// convert relationship Records to RecordDatas before passing to RecordData\nconst defs=store.schema.fields({type});if(defs.size){const keys=Object.keys(properties);for(let i=0;i<keys.length;i++){const prop=keys[i];const field=defs.get(prop);if(!field)continue;if(field.kind==='hasMany'){{assertRecordsPassedToHasMany(properties[prop]);}properties[prop]=extractIdentifiersFromRecords(properties[prop]);}else if(field.kind==='belongsTo'){properties[prop]=extractIdentifierFromRecord(properties[prop]);}}}}return properties;}function assertRecordsPassedToHasMany(records){(test=>{if(!test){throw new Error(`You must pass an array of records to set a hasMany relationship`);}})(Array.isArray(records));(test=>{if(!test){throw new Error(`All elements of a hasMany relationship must be instances of Model, you passed ${records.map(r=>`${typeof r}`).join(', ')}`);}})(function(){return records.every(record=>{try{recordIdentifierFor(record);return true;}catch{return false;}});}());}function extractIdentifiersFromRecords(records){return records.map(record=>extractIdentifierFromRecord(record));}function extractIdentifierFromRecord(recordOrPromiseRecord){if(!recordOrPromiseRecord){return null;}const extract=recordIdentifierFor;return extract(recordOrPromiseRecord);}/**\n * @module @ember-data/store\n */function urlFromLink(link){if(typeof link==='string')return link;return link.href;}/**\n * A Document is a class that wraps the response content from a request to the API\n * returned by `Cache.put` or `Cache.peek`, converting resource-identifiers into\n * record instances.\n *\n * It is not directly instantiated by the user, and its properties should not\n * be directly modified. Whether individual properties are mutable or not is\n * determined by the record instance itself.\n *\n * @public\n * @class Document\n */var _store2=/*#__PURE__*/new WeakMap();var _Document_brand=/*#__PURE__*/new WeakSet();class Document{constructor(store,identifier){_classPrivateMethodInitSpec(this,_Document_brand);/**\n   * The links object for this document, if any\n   *\n   * e.g.\n   *\n   * ```\n   * {\n   *   self: '/articles?page[number]=3',\n   * }\n   * ```\n   *\n   * @property links\n   * @type {object|undefined} - a links object\n   * @public\n   *//**\n   * The primary data for this document, if any.\n   *\n   * If this document has no primary data (e.g. because it is an error document)\n   * this property will be `undefined`.\n   *\n   * For collections this will be an array of record instances,\n   * for single resource requests it will be a single record instance or null.\n   *\n   * @property data\n   * @public\n   * @type {object|Array<object>|null|undefined} - a data object\n   *//**\n   * The errors returned by the API for this request, if any\n   *\n   * @property errors\n   * @public\n   * @type {object|undefined} - an errors object\n   *//**\n   * The meta object for this document, if any\n   *\n   * @property meta\n   * @public\n   * @type {object|undefined} - a meta object\n   *//**\n   * The identifier associated with this document, if any\n   *\n   * @property identifier\n   * @public\n   * @type {StableDocumentIdentifier|null}\n   */_classPrivateFieldInitSpec(this,_store2,void 0);_classPrivateFieldSet(_store2,this,store);this.identifier=identifier;}/**\n   * Fetches the related link for this document, returning a promise that resolves\n   * with the document when the request completes. If no related link is present,\n   * will fallback to the self link if present\n   *\n   * @method fetch\n   * @public\n   * @param {object} options\n   * @return Promise<Document>\n   */fetch(options={}){(test=>{if(!test){throw new Error(`No self or related link`);}})(this.links?.related||this.links?.self);options.cacheOptions=options.cacheOptions||{};options.cacheOptions.key=this.identifier?.lid;return _assertClassBrand(_Document_brand,this,_request).call(this,this.links.related?'related':'self',options);}/**\n   * Fetches the next link for this document, returning a promise that resolves\n   * with the new document when the request completes, or null  if there is no\n   * next link.\n   *\n   * @method next\n   * @public\n   * @param {object} options\n   * @return Promise<Document | null>\n   */next(options={}){return _assertClassBrand(_Document_brand,this,_request).call(this,'next',options);}/**\n   * Fetches the prev link for this document, returning a promise that resolves\n   * with the new document when the request completes, or null if there is no\n   * prev link.\n   *\n   * @method prev\n   * @public\n   * @param {object} options\n   * @return Promise<Document | null>\n   */prev(options={}){return _assertClassBrand(_Document_brand,this,_request).call(this,'prev',options);}/**\n   * Fetches the first link for this document, returning a promise that resolves\n   * with the new document when the request completes, or null if there is no\n   * first link.\n   *\n   * @method first\n   * @public\n   * @param {object} options\n   * @return Promise<Document | null>\n   */first(options={}){return _assertClassBrand(_Document_brand,this,_request).call(this,'first',options);}/**\n   * Fetches the last link for this document, returning a promise that resolves\n   * with the new document when the request completes, or null if there is no\n   * last link.\n   *\n   * @method last\n   * @public\n   * @param {object} options\n   * @return Promise<Document | null>\n   */last(options={}){return _assertClassBrand(_Document_brand,this,_request).call(this,'last',options);}/**\n   * Implemented for `JSON.stringify` support.\n   *\n   * Returns the JSON representation of the document wrapper.\n   *\n   * This is a shallow serialization, it does not deeply serialize\n   * the document's contents, leaving that to the individual record\n   * instances to determine how to do, if at all.\n   *\n   * @method toJSON\n   * @public\n   * @return\n   */toJSON(){const data={};data.identifier=this.identifier;if(this.data!==undefined){data.data=this.data;}if(this.links!==undefined){data.links=this.links;}if(this.errors!==undefined){data.errors=this.errors;}if(this.meta!==undefined){data.meta=this.meta;}return data;}}async function _request(link,options){const href=this.links?.[link];if(!href){return null;}options.method=options.method||'GET';Object.assign(options,{url:urlFromLink(href)});const response=await _classPrivateFieldGet(_store2,this).request(options);return response.content;}(0,_ember_data_tracking_private__WEBPACK_IMPORTED_MODULE_5__.defineSignal)(Document.prototype,'data');(0,_ember_data_tracking_private__WEBPACK_IMPORTED_MODULE_5__.defineSignal)(Document.prototype,'links');(0,_ember_data_tracking_private__WEBPACK_IMPORTED_MODULE_5__.defineSignal)(Document.prototype,'errors');(0,_ember_data_tracking_private__WEBPACK_IMPORTED_MODULE_5__.defineSignal)(Document.prototype,'meta');const MUTATION_OPS=new Set(['createRecord','updateRecord','deleteRecord']);function calcShouldFetch(store,request,hasCachedValue,identifier){const{cacheOptions}=request;return request.op&&MUTATION_OPS.has(request.op)||cacheOptions?.reload||!hasCachedValue||(store.lifetimes&&identifier?store.lifetimes.isHardExpired(identifier,store):false);}function calcShouldBackgroundFetch(store,request,willFetch,identifier){const{cacheOptions}=request;return cacheOptions?.backgroundReload||(store.lifetimes&&identifier?store.lifetimes.isSoftExpired(identifier,store):false);}function isMutation(request){return Boolean(request.op&&MUTATION_OPS.has(request.op));}function copyDocumentProperties(target,source){if('links'in source){target.links=source.links;}if('meta'in source){target.meta=source.meta;}if('errors'in source){target.errors=source.errors;}}function isCacheAffecting(document){if(!isMutation(document.request)){return true;}// a mutation combined with a 204 has no cache impact when no known records were involved\n// a createRecord with a 201 with an empty response and no known records should similarly\n// have no cache impact\nif(document.request.op==='createRecord'&&document.response?.status===201){return document.content?Object.keys(document.content).length>0:false;}return document.response?.status!==204;}function isAggregateError(error){return error instanceof AggregateError||error.name==='AggregateError'&&Array.isArray(error.errors);}// TODO @runspired, consider if we should deep freeze errors (potentially only in debug) vs cloning them\nfunction cloneError(error){const isAggregate=isAggregateError(error);const cloned=isAggregate?new AggregateError(structuredClone(error.errors),error.message):new Error(error.message);cloned.stack=error.stack;cloned.error=error.error;// copy over enumerable properties\nObject.assign(cloned,error);return cloned;}function isErrorDocument(document){return'errors'in document;}function getPriority(identifier,deduped,priority){if(identifier){const existing=deduped.get(identifier);if(existing){return existing.priority;}}return priority;}/**\n * @module @ember-data/store\n *//**\n * A CacheHandler that adds support for using an EmberData Cache with a RequestManager.\n *\n * This handler will only run when a request has supplied a `store` instance. Requests\n * issued by the store via `store.request()` will automatically have the `store` instance\n * attached to the request.\n *\n * ```ts\n * requestManager.request({\n *   store: store,\n *   url: '/api/posts',\n *   method: 'GET'\n * });\n * ```\n *\n * When this handler elects to handle a request, it will return the raw `StructuredDocument`\n * unless the request has `[EnableHydration]` set to `true`. In this case, the handler will\n * return a `Document` instance that will automatically update the UI when the cache is updated\n * in the future and will hydrate any identifiers in the StructuredDocument into Record instances.\n *\n * When issuing a request via the store, [EnableHydration] is automatically set to `true`. This\n * means that if desired you can issue requests that utilize the cache without needing to also\n * utilize Record instances if desired.\n *\n * Said differently, you could elect to issue all requests via a RequestManager, without ever using\n * the store directly, by setting [EnableHydration] to `true` and providing a store instance. Not\n * necessarily the most useful thing, but the decoupled nature of the RequestManager and incremental-feature\n * approach of EmberData allows for this flexibility.\n *\n * ```ts\n * import { EnableHydration } from '@warp-drive/core-types/request';\n *\n * requestManager.request({\n *   store: store,\n *   url: '/api/posts',\n *   method: 'GET',\n *   [EnableHydration]: true\n * });\n *\n * @typedoc\n */const CacheHandler={request(context,next){// if we have no cache or no cache-key skip cache handling\nif(!context.request.store||context.request.cacheOptions?.[_warp_drive_core_types_request__WEBPACK_IMPORTED_MODULE_1__.SkipCache]){return next(context.request);}const{store}=context.request;const identifier=store.identifierCache.getOrCreateDocumentIdentifier(context.request);if(identifier){context.setIdentifier(identifier);}// used to dedupe existing requests that match\nconst DEDUPE=store.requestManager._deduped;const activeRequest=identifier&&DEDUPE.get(identifier);const peeked=identifier?store.cache.peekRequest(identifier):null;// determine if we should skip cache\nif(calcShouldFetch(store,context.request,!!peeked,identifier)){if(activeRequest){activeRequest.priority={blocking:true};return activeRequest.promise;}let promise=fetchContentAndHydrate(next,context,identifier,{blocking:true});if(identifier){promise=promise.finally(()=>{DEDUPE.delete(identifier);store.notifications.notify(identifier,'state');});DEDUPE.set(identifier,{priority:{blocking:true},promise});store.notifications.notify(identifier,'state');}return promise;}// if we have not skipped cache, determine if we should update behind the scenes\nif(calcShouldBackgroundFetch(store,context.request,false,identifier)){let promise=activeRequest?.promise||fetchContentAndHydrate(next,context,identifier,{blocking:false});if(identifier&&!activeRequest){promise=promise.finally(()=>{DEDUPE.delete(identifier);store.notifications.notify(identifier,'state');});DEDUPE.set(identifier,{priority:{blocking:false},promise});store.notifications.notify(identifier,'state');}store.requestManager._pending.set(context.id,promise);}(test=>{if(!test){throw new Error(`Expected a peeked request to be present`);}})(peeked);const shouldHydrate=context.request[_warp_drive_core_types_request__WEBPACK_IMPORTED_MODULE_1__.EnableHydration]||false;context.setResponse(peeked.response);if('error'in peeked){const content=shouldHydrate?maybeUpdateErrorUiObjects(store,{shouldHydrate,identifier},peeked.content,true):peeked.content;const newError=cloneError(peeked);newError.content=content;throw newError;}const result=shouldHydrate?maybeUpdateUiObjects(store,context.request,{shouldHydrate,identifier},peeked.content,true):peeked.content;return result;}};function maybeUpdateUiObjects(store,request,options,document,isFromCache){const{identifier}=options;if(!document){(test=>{if(!test){throw new Error(`The CacheHandler expected response content but none was found`);}})(!options.shouldHydrate);return document;}if(Array.isArray(document.data)){const{recordArrayManager}=store;if(!identifier){if(!options.shouldHydrate){return document;}const data=recordArrayManager.createArray({type:request.url,identifiers:document.data,doc:document,query:request});const doc=new Document(store,null);doc.data=data;doc.meta=document.meta;doc.links=document.links;return doc;}let managed=recordArrayManager._keyedArrays.get(identifier.lid);if(!managed){managed=recordArrayManager.createArray({type:identifier.lid,identifiers:document.data,doc:document});recordArrayManager._keyedArrays.set(identifier.lid,managed);const doc=new Document(store,identifier);doc.data=managed;doc.meta=document.meta;doc.links=document.links;store._documentCache.set(identifier,doc);return options.shouldHydrate?doc:document;}else{const doc=store._documentCache.get(identifier);if(!isFromCache){recordArrayManager.populateManagedArray(managed,document.data,document);doc.data=managed;doc.meta=document.meta;doc.links=document.links;}return options.shouldHydrate?doc:document;}}else{if(!identifier&&!options.shouldHydrate){return document;}const data=document.data?store.peekRecord(document.data):null;let doc;if(identifier){doc=store._documentCache.get(identifier);}if(!doc){doc=new Document(store,identifier);doc.data=data;copyDocumentProperties(doc,document);if(identifier){store._documentCache.set(identifier,doc);}}else if(!isFromCache){doc.data=data;copyDocumentProperties(doc,document);}return options.shouldHydrate?doc:document;}}function maybeUpdateErrorUiObjects(store,options,document,isFromCache){const{identifier}=options;// TODO investigate why ResourceErrorDocument is insufficient for expressing all error types\nif(!isErrorDocument(document)||!identifier&&!options.shouldHydrate){return document;}let doc;if(identifier){doc=store._documentCache.get(identifier);}if(!doc){doc=new Document(store,identifier);copyDocumentProperties(doc,document);if(identifier){store._documentCache.set(identifier,doc);}}else if(!isFromCache){doc.data=undefined;copyDocumentProperties(doc,document);}return options.shouldHydrate?doc:document;}function updateCacheForSuccess(store,request,options,document){let response=null;if(isMutation(request)){const record=request.data?.record||request.records?.[0];if(record){response=store.cache.didCommit(record,document);// a mutation combined with a 204 has no cache impact when no known records were involved\n// a createRecord with a 201 with an empty response and no known records should similarly\n// have no cache impact\n}else if(isCacheAffecting(document)){response=store.cache.put(document);}}else{response=store.cache.put(document);}return maybeUpdateUiObjects(store,request,options,response,false);}function handleFetchSuccess(store,context,options,document){const{request}=context;store.requestManager._pending.delete(context.id);store._enableAsyncFlush=true;let response;store._join(()=>{response=updateCacheForSuccess(store,request,options,document);});store._enableAsyncFlush=null;if(store.lifetimes?.didRequest){store.lifetimes.didRequest(context.request,document.response,options.identifier,store);}const finalPriority=getPriority(options.identifier,store.requestManager._deduped,options.priority);if(finalPriority.blocking){return response;}else{store.notifications._flush();}}function updateCacheForError(store,context,options,error){let response;if(isMutation(context.request)){// TODO similar to didCommit we should spec this to be similar to cache.put for handling full response\n// currently we let the response remain undefiend.\nconst errors=error&&error.content&&typeof error.content==='object'&&'errors'in error.content&&Array.isArray(error.content.errors)?error.content.errors:undefined;const record=context.request.data?.record||context.request.records?.[0];store.cache.commitWasRejected(record,errors);}else{response=store.cache.put(error);return maybeUpdateErrorUiObjects(store,options,response,false);}}function handleFetchError(store,context,options,error){store.requestManager._pending.delete(context.id);if(context.request.signal?.aborted){throw error;}store._enableAsyncFlush=true;let response;store._join(()=>{response=updateCacheForError(store,context,options,error);});store._enableAsyncFlush=null;if(options.identifier&&store.lifetimes?.didRequest){store.lifetimes.didRequest(context.request,error.response,options.identifier,store);}if(isMutation(context.request)){throw error;}const finalPriority=getPriority(options.identifier,store.requestManager._deduped,options.priority);if(finalPriority.blocking){const newError=cloneError(error);newError.content=response;throw newError;}else{store.notifications._flush();}}function fetchContentAndHydrate(next,context,identifier,priority){const{store}=context.request;const shouldHydrate=context.request[_warp_drive_core_types_request__WEBPACK_IMPORTED_MODULE_1__.EnableHydration]||false;const options={shouldHydrate,identifier,priority};let isMut=false;if(isMutation(context.request)){isMut=true;// TODO should we handle multiple records in request.records by iteratively calling willCommit for each\nconst record=context.request.data?.record||context.request.records?.[0];(test=>{if(!test){throw new Error(`Expected to receive a list of records included in the ${context.request.op} request`);}})(record||!shouldHydrate);if(record){store.cache.willCommit(record,context);}}if(store.lifetimes?.willRequest){store.lifetimes.willRequest(context.request,identifier,store);}const promise=next(context.request).then(document=>{return handleFetchSuccess(store,context,options,document);},error=>{return handleFetchError(store,context,options,error);});if(!isMut){return promise;}(test=>{if(!test){throw new Error(`Expected a mutation`);}})(isMutation(context.request));// for mutations we need to enqueue the promise with the requestStateService\n// TODO should we enque a request per record in records?\nconst record=context.request.data?.record||context.request.records?.[0];return store._requestCache._enqueue(promise,{data:[{op:'saveRecord',recordIdentifier:record,options:undefined}]});}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@ember-data/store/dist/handler-CET_Ja8V.js?");

/***/ }),

/***/ "./node_modules/@ember-data/store/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@ember-data/store/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CacheHandler: () => (/* reexport safe */ _handler_CET_Ja8V_js__WEBPACK_IMPORTED_MODULE_0__.C),\n/* harmony export */   \"default\": () => (/* reexport safe */ _handler_CET_Ja8V_js__WEBPACK_IMPORTED_MODULE_0__.S),\n/* harmony export */   recordIdentifierFor: () => (/* reexport safe */ _handler_CET_Ja8V_js__WEBPACK_IMPORTED_MODULE_0__.r),\n/* harmony export */   setIdentifierForgetMethod: () => (/* reexport safe */ _handler_CET_Ja8V_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   setIdentifierGenerationMethod: () => (/* reexport safe */ _handler_CET_Ja8V_js__WEBPACK_IMPORTED_MODULE_0__.a),\n/* harmony export */   setIdentifierResetMethod: () => (/* reexport safe */ _handler_CET_Ja8V_js__WEBPACK_IMPORTED_MODULE_0__.d),\n/* harmony export */   setIdentifierUpdateMethod: () => (/* reexport safe */ _handler_CET_Ja8V_js__WEBPACK_IMPORTED_MODULE_0__.b),\n/* harmony export */   setKeyInfoForResource: () => (/* reexport safe */ _handler_CET_Ja8V_js__WEBPACK_IMPORTED_MODULE_0__.e),\n/* harmony export */   storeFor: () => (/* reexport safe */ _handler_CET_Ja8V_js__WEBPACK_IMPORTED_MODULE_0__.s)\n/* harmony export */ });\n/* harmony import */ var _handler_CET_Ja8V_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./handler-CET_Ja8V.js */ \"./node_modules/@ember-data/store/dist/handler-CET_Ja8V.js\");\n/* harmony import */ var _ember_debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ember/debug */ \"@ember/debug\");\n/* harmony import */ var _ember_debug__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_ember_debug__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _ember_data_request_utils_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ember-data/request-utils/string */ \"./node_modules/@ember-data/request-utils/dist/string.js\");\n\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@ember-data/store/dist/index.js?");

/***/ }),

/***/ "./node_modules/@ember-data/tracking/dist/-private.js":
/*!************************************************************!*\
  !*** ./node_modules/@ember-data/tracking/dist/-private.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Signals: () => (/* binding */ Signals),\n/* harmony export */   addToTransaction: () => (/* binding */ addToTransaction),\n/* harmony export */   addTransactionCB: () => (/* binding */ addTransactionCB),\n/* harmony export */   createArrayTags: () => (/* binding */ createArrayTags),\n/* harmony export */   createSignal: () => (/* binding */ createSignal),\n/* harmony export */   defineSignal: () => (/* binding */ defineSignal),\n/* harmony export */   entangleSignal: () => (/* binding */ entangleSignal),\n/* harmony export */   getSignal: () => (/* binding */ getSignal),\n/* harmony export */   memoTransact: () => (/* binding */ memoTransact),\n/* harmony export */   peekSignal: () => (/* binding */ peekSignal),\n/* harmony export */   subscribe: () => (/* binding */ subscribe),\n/* harmony export */   transact: () => (/* binding */ transact),\n/* harmony export */   untracked: () => (/* binding */ untracked)\n/* harmony export */ });\n/* harmony import */ var _ember_internals_metal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ember/-internals/metal */ \"@ember/-internals/metal\");\n/* harmony import */ var _ember_internals_metal__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ember_internals_metal__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _glimmer_validator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @glimmer/validator */ \"@glimmer/validator\");\n/* harmony import */ var _glimmer_validator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_glimmer_validator__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @warp-drive/core-types/-private */ \"./node_modules/@warp-drive/core-types/dist/-private.js\");\nfunction createTransaction(){const transaction={cbs:new Set(),props:new Set(),sub:new Set(),parent:null};const TRANSACTION=(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_2__.peekTransient)('TRANSACTION');if(TRANSACTION){transaction.parent=TRANSACTION;}(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_2__.setTransient)('TRANSACTION',transaction);}function maybeConsume(tag){if(tag){(0,_glimmer_validator__WEBPACK_IMPORTED_MODULE_1__.consumeTag)(tag);}}function maybeDirty(tag){if(tag){// @ts-expect-error - we are using Ember's Tag not Glimmer's\n(0,_glimmer_validator__WEBPACK_IMPORTED_MODULE_1__.dirtyTag)(tag);}}/**\n * If there is a current transaction, ensures that the relevant tag (and any\n * array computed chains symbols, if applicable) will be consumed during the\n * transaction.\n *\n * If there is no current transaction, will consume the tag(s) immediately.\n *\n * @internal\n * @param obj\n */function subscribe(obj){const TRANSACTION=(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_2__.peekTransient)('TRANSACTION');if(TRANSACTION){TRANSACTION.sub.add(obj);}else if('tag'in obj){{maybeConsume(obj['[]']);maybeConsume(obj['@length']);}(0,_glimmer_validator__WEBPACK_IMPORTED_MODULE_1__.consumeTag)(obj.tag);}else{// eslint-disable-next-line @typescript-eslint/no-unused-expressions\nobj.ref;}}function updateRef(obj){{try{if('tag'in obj){{maybeDirty(obj['[]']);maybeDirty(obj['@length']);}// @ts-expect-error - we are using Ember's Tag not Glimmer's\n(0,_glimmer_validator__WEBPACK_IMPORTED_MODULE_1__.dirtyTag)(obj.tag);}else{obj.ref=null;}}catch(e){if(e instanceof Error){if(e.message.includes('You attempted to update `undefined`')){// @ts-expect-error\nconst key=`<${obj._debug_base}>.${obj.key}`;e.message=e.message.replace('You attempted to update `undefined`',`You attempted to update ${key}`);e.stack=e.stack?.replace('You attempted to update `undefined`',`You attempted to update ${key}`);const lines=e.stack?.split(`\\n`);const finalLines=[];let lastFile=null;lines?.forEach(line=>{if(line.trim().startsWith('at ')){// get the last string in the line which contains the code source location\nconst location=line.split(' ').at(-1);// remove the line and char offset info\nif(location.includes(':')){const parts=location.split(':');parts.pop();parts.pop();const file=parts.join(':');if(file!==lastFile){lastFile=file;finalLines.push('');}}finalLines.push(line);}});const splitstr='`undefined` was first used:';const parts=e.message.split(splitstr);parts.splice(1,0,`Original Stack\\n=============\\n${finalLines.join(`\\n`)}\\n\\n\\`${key}\\` was first used:`);e.message=parts.join('');}}throw e;}}}function flushTransaction(){const transaction=(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_2__.peekTransient)('TRANSACTION');(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_2__.setTransient)('TRANSACTION',transaction.parent);transaction.cbs.forEach(cb=>{cb();});transaction.props.forEach(obj=>{// mark this mutation as part of a transaction\nobj.t=true;updateRef(obj);});transaction.sub.forEach(obj=>{if('tag'in obj){{maybeConsume(obj['[]']);maybeConsume(obj['@length']);}(0,_glimmer_validator__WEBPACK_IMPORTED_MODULE_1__.consumeTag)(obj.tag);}else{// eslint-disable-next-line @typescript-eslint/no-unused-expressions\nobj.ref;}});}async function untrack(){const transaction=(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_2__.peekTransient)('TRANSACTION');(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_2__.setTransient)('TRANSACTION',transaction.parent);// defer writes\nawait Promise.resolve();transaction.cbs.forEach(cb=>{cb();});transaction.props.forEach(obj=>{// mark this mutation as part of a transaction\nobj.t=true;updateRef(obj);});}function addToTransaction(obj){const transaction=(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_2__.peekTransient)('TRANSACTION');if(transaction){transaction.props.add(obj);}else{updateRef(obj);}}function addTransactionCB(method){const transaction=(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_2__.peekTransient)('TRANSACTION');if(transaction){transaction.cbs.add(method);}else{method();}}/**\n * Run `method` without subscribing to any tracked properties\n * controlled by EmberData.\n *\n * This should rarely be used except by libraries that really\n * know what they are doing. It is most useful for wrapping\n * certain kinds of fetch/query logic from within a `Resource`\n * `hook` or other similar pattern.\n *\n * @function untracked\n * @public\n * @static\n * @for @ember-data/tracking\n * @param method\n * @return result of invoking method\n */function untracked(method){createTransaction();const ret=method();void untrack();return ret;}/**\n * Run the method, subscribing to any tracked properties\n * managed by EmberData that were accessed or written during\n * the method's execution as per-normal but while allowing\n * interleaving of reads and writes.\n *\n * This is useful when for instance you want to perform\n * a mutation based on existing state that must be read first.\n *\n * @function transact\n * @public\n * @static\n * @for @ember-data/tracking\n * @param method\n * @return result of invoking method\n */function transact(method){createTransaction();const ret=method();flushTransaction();return ret;}/**\n * A helpful utility for creating a new function that\n * always runs in a transaction. E.G. this \"memoizes\"\n * calling `transact(fn)`, currying args as necessary.\n *\n * @method memoTransact\n * @public\n * @static\n * @for @ember-data/tracking\n * @param method\n * @return a function that will invoke method in a transaction with any provided args and return its result\n */function memoTransact(method){return function(...args){createTransaction();const ret=method(...args);flushTransaction();return ret;};}const Signals=(0,_warp_drive_core_types_private__WEBPACK_IMPORTED_MODULE_2__.getOrSetGlobal)('Signals',Symbol('Signals'));/**\n *  use to add a signal property to the prototype of something.\n *\n *  First arg is the thing to define on\n *  Second arg is the property name\n *  Third agg is the initial value of the property if any.\n *\n *  for instance\n *\n *  ```ts\n *  class Model {}\n *  defineSignal(Model.prototype, 'isLoading', false);\n *  ```\n *\n *  This is sort of like using a stage-3 decorator but works today\n *  while we are still on legacy decorators.\n *\n *  e.g. it is equivalent to\n *\n *  ```ts\n *  class Model {\n *    @signal accessor isLoading = false;\n *  }\n *  ```\n *\n *  @internal\n */function defineSignal(obj,key,v){Object.defineProperty(obj,key,{enumerable:true,configurable:false,get(){const signals=this[Signals]=this[Signals]||new Map();const existing=signals.has(key);const _signal=entangleSignal(signals,this,key);if(!existing&&v!==undefined){_signal.lastValue=v;}return _signal.lastValue;},set(value){const signals=this[Signals]=this[Signals]||new Map();let _signal=signals.get(key);if(!_signal){_signal=createSignal(this,key);signals.set(key,_signal);}if(_signal.lastValue!==value){_signal.lastValue=value;addToTransaction(_signal);}}});}function createArrayTags(obj,signal){{signal['[]']=(0,_ember_internals_metal__WEBPACK_IMPORTED_MODULE_0__.tagForProperty)(obj,'[]');signal['@length']=(0,_ember_internals_metal__WEBPACK_IMPORTED_MODULE_0__.tagForProperty)(obj,'length');}}/**\n * Create a signal for the key/object pairing.\n *\n * @internal\n * @param obj Object we're creating the signal on\n * @param key Key to create the signal for\n * @return the signal\n */function createSignal(obj,key){const _signal={key,tag:(0,_ember_internals_metal__WEBPACK_IMPORTED_MODULE_0__.tagForProperty)(obj,key),t:false,shouldReset:false,'[]':null,'@length':null,lastValue:undefined};{function tryGet(prop){try{return obj[prop];}catch{return;}}const modelName=tryGet('$type')??tryGet('modelName')??tryGet('constructor')?.modelName??'';// eslint-disable-next-line @typescript-eslint/no-base-to-string\nconst className=obj.constructor?.name??obj.toString?.()??'unknown';_signal._debug_base=`${className}${modelName&&!className.startsWith('SchemaRecord')?`:${modelName}`:''}`;}return _signal;}/**\n * Create a signal for the key/object pairing and subscribes to the signal.\n *\n * Use when you need to ensure a signal exists and is subscribed to.\n *\n * @internal\n * @param signals Map of signals\n * @param obj Object we're creating the signal on\n * @param key Key to create the signal for\n * @return the signal\n */function entangleSignal(signals,obj,key){let _signal=signals.get(key);if(!_signal){_signal=createSignal(obj,key);signals.set(key,_signal);}subscribe(_signal);return _signal;}function getSignal(obj,key,initialState){let signals=obj[Signals];if(!signals){signals=new Map();obj[Signals]=signals;}let _signal=signals.get(key);if(!_signal){_signal=createSignal(obj,key);_signal.shouldReset=initialState;signals.set(key,_signal);}return _signal;}function peekSignal(obj,key){const signals=obj[Signals];if(signals){return signals.get(key);}}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@ember-data/tracking/dist/-private.js?");

/***/ }),

/***/ "./node_modules/@ember-data/tracking/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@ember-data/tracking/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cached: () => (/* binding */ cached),\n/* harmony export */   compat: () => (/* reexport safe */ _ember_object_compat__WEBPACK_IMPORTED_MODULE_2__.dependentKeyCompat),\n/* harmony export */   createCache: () => (/* reexport safe */ _glimmer_tracking_primitives_cache__WEBPACK_IMPORTED_MODULE_0__.createCache),\n/* harmony export */   getValue: () => (/* reexport safe */ _glimmer_tracking_primitives_cache__WEBPACK_IMPORTED_MODULE_0__.getValue),\n/* harmony export */   memoTransact: () => (/* reexport safe */ _private_js__WEBPACK_IMPORTED_MODULE_1__.memoTransact),\n/* harmony export */   transact: () => (/* reexport safe */ _private_js__WEBPACK_IMPORTED_MODULE_1__.transact),\n/* harmony export */   untracked: () => (/* reexport safe */ _private_js__WEBPACK_IMPORTED_MODULE_1__.untracked)\n/* harmony export */ });\n/* harmony import */ var _glimmer_tracking_primitives_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @glimmer/tracking/primitives/cache */ \"@glimmer/tracking/primitives/cache\");\n/* harmony import */ var _glimmer_tracking_primitives_cache__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_glimmer_tracking_primitives_cache__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _private_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./-private.js */ \"./node_modules/@ember-data/tracking/dist/-private.js\");\n/* harmony import */ var _ember_object_compat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ember/object/compat */ \"@ember/object/compat\");\n/* harmony import */ var _ember_object_compat__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_ember_object_compat__WEBPACK_IMPORTED_MODULE_2__);\nfunction cached(target,key,descriptor){// Error on `@cached()`, `@cached(...args)`, and `@cached propName = value;`\n(test=>{if(!test){throw new Error('You attempted to use @cached(), which is not necessary nor supported. Remove the parentheses and you will be good to go!');}})(target!==undefined);(test=>{if(!test){throw new Error(`You attempted to use @cached on with ${arguments.length>1?'arguments':'an argument'} ( @cached(${Array.from(arguments).map(d=>`'${d}'`).join(', ')}), which is not supported. Dependencies are automatically tracked, so you can just use ${'`@cached`'}`);}})(typeof target==='object'&&typeof key==='string'&&typeof descriptor==='object'&&arguments.length===3);(test=>{if(!test){throw new Error(`The @cached decorator must be applied to getters. '${key}' is not a getter.`);}})(typeof descriptor.get==='function');const caches=new WeakMap();// eslint-disable-next-line @typescript-eslint/unbound-method\nconst getter=descriptor.get;descriptor.get=function(){if(!caches.has(this))caches.set(this,(0,_glimmer_tracking_primitives_cache__WEBPACK_IMPORTED_MODULE_0__.createCache)(getter.bind(this)));return (0,_glimmer_tracking_primitives_cache__WEBPACK_IMPORTED_MODULE_0__.getValue)(caches.get(this));};}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@ember-data/tracking/dist/index.js?");

/***/ }),

/***/ "./node_modules/@embroider/macros/src/addon/es-compat2.js":
/*!****************************************************************!*\
  !*** ./node_modules/@embroider/macros/src/addon/es-compat2.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ esCompat)\n/* harmony export */ });\nfunction esCompat(m){return m?.__esModule?m:{default:m,...m};}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@embroider/macros/src/addon/es-compat2.js?");

/***/ }),

/***/ "./node_modules/@warp-drive/core-types/dist/-private.js":
/*!**************************************************************!*\
  !*** ./node_modules/@warp-drive/core-types/dist/-private.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getOrSetGlobal: () => (/* binding */ getOrSetGlobal),\n/* harmony export */   getOrSetUniversal: () => (/* binding */ getOrSetUniversal),\n/* harmony export */   peekTransient: () => (/* binding */ peekTransient),\n/* harmony export */   peekUniversalTransient: () => (/* binding */ peekUniversalTransient),\n/* harmony export */   setTransient: () => (/* binding */ setTransient),\n/* harmony export */   setUniversalTransient: () => (/* binding */ setUniversalTransient)\n/* harmony export */ });\nconst name=\"@warp-drive/core-types\";const version=\"0.0.0-beta.12\";// in testing mode, we utilize globals to ensure only one copy exists of\n// these maps, due to bugs in ember-auto-import\nconst GlobalRef=globalThis;const UniversalCache=GlobalRef.__warpDrive_universalCache=GlobalRef.__warpDrive_universalCache??{};// in order to support mirror packages, we ensure that each\n// unique package name has its own global cache\nGlobalRef[name]=GlobalRef[name]??{__version:version};const GlobalSink=GlobalRef[name];{if(GlobalSink.__version!==version){throw new Error('Multiple versions of WarpDrive detected, the application will malfunction.');}}const ModuleScopedCaches=GlobalSink.__warpDrive_ModuleScopedCaches??{};{if(!GlobalSink.__warpDrive_ModuleScopedCaches){GlobalSink.__warpDrive_ModuleScopedCaches=ModuleScopedCaches;}else{// eslint-disable-next-line no-console\nconsole.warn(`\nMultiple copies of EmberData have been detected. This may be due to a bug in ember-auto-import\n  in which test assets get their own copy of some v2-addons. This can cause the application to\n  malfunction as each copy will maintain its own separate state.`);}}function getOrSetGlobal(key,value){{const existing=ModuleScopedCaches[key];if(existing===undefined){return ModuleScopedCaches[key]=value;}else{return existing;}}}function peekTransient(key){const globalKey=`(transient) ${key}`;return ModuleScopedCaches[globalKey]??null;}function setTransient(key,value){const globalKey=`(transient) ${key}`;return ModuleScopedCaches[globalKey]=value;}function getOrSetUniversal(key,value){{const existing=UniversalCache[key];if(existing===undefined){return UniversalCache[key]=value;}else{return existing;}}}function peekUniversalTransient(key){const globalKey=`(transient) ${key}`;return UniversalCache[globalKey]??null;}function setUniversalTransient(key,value){const globalKey=`(transient) ${key}`;return UniversalCache[globalKey]=value;}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@warp-drive/core-types/dist/-private.js?");

/***/ }),

/***/ "./node_modules/@warp-drive/core-types/dist/identifier.js":
/*!****************************************************************!*\
  !*** ./node_modules/@warp-drive/core-types/dist/identifier.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CACHE_OWNER: () => (/* binding */ CACHE_OWNER),\n/* harmony export */   DEBUG_CLIENT_ORIGINATED: () => (/* binding */ DEBUG_CLIENT_ORIGINATED),\n/* harmony export */   DEBUG_IDENTIFIER_BUCKET: () => (/* binding */ DEBUG_IDENTIFIER_BUCKET),\n/* harmony export */   DEBUG_STALE_CACHE_OWNER: () => (/* binding */ DEBUG_STALE_CACHE_OWNER)\n/* harmony export */ });\n/**\n  @module @ember-data/store\n*/// provided for additional debuggability\nconst DEBUG_CLIENT_ORIGINATED=Symbol('record-originated-on-client');const DEBUG_IDENTIFIER_BUCKET=Symbol('identifier-bucket');const DEBUG_STALE_CACHE_OWNER=Symbol('warpDriveStaleCache');// also present in production\nconst CACHE_OWNER=Symbol('warpDriveCache');/**\n * An Identifier specific to a record which may or may not\n * be present in the cache.\n *\n * The absence of an `id` DOES NOT indicate that this\n * Identifier is for a new client-created record as it\n * may also indicate that it was generated for a secondary\n * index and the primary `id` index is not yet known.\n *\n * @internal\n *//**\n * Used when an Identifier is known to be the stable version\n *\n * @internal\n *//**\n * Used when a StableRecordIdentifier was not created locally as part\n * of a call to store.createRecord\n *\n * Distinguishing between this Identifier and one for a client created\n * record that was created with an ID is generally speaking not possible\n * at runtime, so anything with an ID typically narrows to this.\n *\n * @internal\n *//**\n * Used when a StableRecordIdentifier was created locally\n * (by a call to store.createRecord).\n *\n * It is possible in rare circumstances to have a StableRecordIdentifier\n * that is not for a new record but does not have an ID. This would\n * happen if a user intentionally created one for use with a secondary-index\n * prior to the record having been fully loaded.\n *\n * @internal\n *//**\n * A referentially stable object with a unique string (lid) that can be used\n * as a reference to data in the cache.\n *\n * Every record instance has a unique identifier, and identifiers may refer\n * to data that has never been loaded (for instance, in an async relationship).\n *\n * @class StableRecordIdentifier\n * @public\n *//**\n * A string representing a unique identity.\n *\n * @property {string} lid\n * @public\n *//**\n * the primary resource `type` or `modelName` this identity belongs to.\n *\n * @property {string} type\n * @public\n *//**\n * the primary id for the record this identity belongs to. `null`\n * if not yet assigned an id.\n *\n * @property {string | null} id\n * @public\n */\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@warp-drive/core-types/dist/identifier.js?");

/***/ }),

/***/ "./node_modules/@warp-drive/core-types/dist/request.js":
/*!*************************************************************!*\
  !*** ./node_modules/@warp-drive/core-types/dist/request.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EnableHydration: () => (/* binding */ EnableHydration),\n/* harmony export */   IS_FUTURE: () => (/* binding */ IS_FUTURE),\n/* harmony export */   STRUCTURED: () => (/* binding */ STRUCTURED),\n/* harmony export */   SkipCache: () => (/* binding */ SkipCache)\n/* harmony export */ });\n/* harmony import */ var _private_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./-private.js */ \"./node_modules/@warp-drive/core-types/dist/-private.js\");\nconst SkipCache=(0,_private_js__WEBPACK_IMPORTED_MODULE_0__.getOrSetUniversal)('SkipCache',Symbol.for('wd:skip-cache'));const EnableHydration=(0,_private_js__WEBPACK_IMPORTED_MODULE_0__.getOrSetUniversal)('EnableHydration',Symbol.for('wd:enable-hydration'));const IS_FUTURE=(0,_private_js__WEBPACK_IMPORTED_MODULE_0__.getOrSetGlobal)('IS_FUTURE',Symbol('IS_FUTURE'));const STRUCTURED=(0,_private_js__WEBPACK_IMPORTED_MODULE_0__.getOrSetGlobal)('DOC',Symbol('DOC'));/**\n * Use these options to adjust CacheHandler behavior for a request.\n *\n * @typedoc\n *//**\n * JavaScript's native Request class.\n *\n * EmberData provides our own typings due to incompleteness in the native typings.\n *\n * @typedoc\n *//**\n * Extends JavaScript's native {@link Request} object with additional\n * properties specific to the RequestManager's capabilities.\n *\n * @typedoc\n *//**\n * Immutable version of {@link RequestInfo}. This is what is passed to handlers.\n *\n * @typedoc\n */\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@warp-drive/core-types/dist/request.js?");

/***/ }),

/***/ "./node_modules/@warp-drive/core-types/dist/symbols.js":
/*!*************************************************************!*\
  !*** ./node_modules/@warp-drive/core-types/dist/symbols.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RecordStore: () => (/* binding */ RecordStore),\n/* harmony export */   RequestSignature: () => (/* binding */ RequestSignature),\n/* harmony export */   ResourceType: () => (/* binding */ ResourceType),\n/* harmony export */   TransformName: () => (/* binding */ TransformName),\n/* harmony export */   Type: () => (/* binding */ Type)\n/* harmony export */ });\n/* harmony import */ var _private_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./-private.js */ \"./node_modules/@warp-drive/core-types/dist/-private.js\");\n/*\n * @module @warp-drive/core-types\n */const RecordStore=(0,_private_js__WEBPACK_IMPORTED_MODULE_0__.getOrSetGlobal)('Store',Symbol('Store'));/**\n * Symbol for the name of a resource, transformation\n * or derivation.\n *\n * ### With Resources\n *\n * This is an optional feature that can be used by\n * record implementations to provide a typescript\n * hint for the type of the resource.\n *\n * When used, EmberData and WarpDrive APIs can\n * take advantage of this to provide better type\n * safety and intellisense.\n *\n * ### With Derivations\n *\n * Required for derivations registered with\n * `store.registerDerivation(derivation)`.\n *\n * ```ts\n * function concat(record: object, options: ObjectValue | null, prop: string): string {}\n * concat[Name] = 'concat';\n * ```\n *\n * ### With Transforms\n *\n * Required for new-style transformations registered\n * with `store.registerTransform(transform)`.\n *\n * For legacy transforms, if not used,\n * `attr<Transform>('name')` will allow any string name.\n * `attr('name')` will always allow any string name.\n *\n * If used, `attr<Transform>('name')` will enforce\n * that the name is the same as the transform name.\n *\n * @type {Symbol}\n * @typedoc\n */const Type=(0,_private_js__WEBPACK_IMPORTED_MODULE_0__.getOrSetGlobal)('$type',Symbol('$type'));/**\n * Symbol for the type of a resource.\n *\n * This is an optional feature that can be used by\n * record implementations to provide a typescript\n * hint for the type of the resource.\n *\n * When used, EmberData and WarpDrive APIs can\n * take advantage of this to provide better type\n * safety and intellisense.\n *\n * @type {Symbol}\n * @typedoc\n */const ResourceType=Type;/**\n * Symbol for the name of a transform.\n *\n * This is an optional feature that can be used by\n * transform implementations to provide a typescript\n * hint for the name of the transform.\n *\n * If not used, `attr<Transform>('name')` will\n * allow any string name. `attr('name')` will always\n * allow any string name.\n *\n * If used, `attr<Transform>('name')` will enforce\n * that the name is the same as the transform name.\n *\n * @type {Symbol}\n * @typedoc\n */const TransformName=Type;/**\n * Symbol for use by builders to indicate the return type\n * generic to use for store.request()\n *\n * @type {Symbol}\n * @typedoc\n */const RequestSignature=(0,_private_js__WEBPACK_IMPORTED_MODULE_0__.getOrSetGlobal)('RequestSignature',Symbol('RequestSignature'));\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/@warp-drive/core-types/dist/symbols.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports=function(cssWithMappingToString){var list=[];// return the list of modules as css string\nlist.toString=function toString(){return this.map(function(item){var content=cssWithMappingToString(item);if(item[2]){return\"@media \".concat(item[2],\" {\").concat(content,\"}\");}return content;}).join(\"\");};// import a list of modules into the list\n// eslint-disable-next-line func-names\nlist.i=function(modules,mediaQuery,dedupe){if(typeof modules===\"string\"){// eslint-disable-next-line no-param-reassign\nmodules=[[null,modules,\"\"]];}var alreadyImportedModules={};if(dedupe){for(var i=0;i<this.length;i++){// eslint-disable-next-line prefer-destructuring\nvar id=this[i][0];if(id!=null){alreadyImportedModules[id]=true;}}}for(var _i=0;_i<modules.length;_i++){var item=[].concat(modules[_i]);if(dedupe&&alreadyImportedModules[item[0]]){// eslint-disable-next-line no-continue\ncontinue;}if(mediaQuery){if(!item[2]){item[2]=mediaQuery;}else{item[2]=\"\".concat(mediaQuery,\" and \").concat(item[2]);}}list.push(item);}};return list;};\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/ember-data/dist/store.js":
/*!***********************************************!*\
  !*** ./node_modules/ember-data/dist/store.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Store)\n/* harmony export */ });\n/* harmony import */ var _ember_data_json_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ember-data/json-api */ \"./node_modules/@ember-data/json-api/dist/index.js\");\n/* harmony import */ var _ember_data_legacy_compat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ember-data/legacy-compat */ \"./node_modules/@ember-data/legacy-compat/dist/index.js\");\n/* harmony import */ var _ember_data_model_hooks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ember-data/model/hooks */ \"./node_modules/@ember-data/model/dist/hooks.js\");\n/* harmony import */ var _ember_data_request__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ember-data/request */ \"./node_modules/@ember-data/request/dist/index.js\");\n/* harmony import */ var _ember_data_request_fetch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ember-data/request/fetch */ \"./node_modules/@ember-data/request/dist/fetch.js\");\n/* harmony import */ var _ember_data_store__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ember-data/store */ \"./node_modules/@ember-data/store/dist/index.js\");\nfunction _defineProperty(e,r,t){return(r=_toPropertyKey(r))in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e;}function _toPropertyKey(t){var i=_toPrimitive(t,\"string\");return\"symbol\"==typeof i?i:i+\"\";}function _toPrimitive(t,r){if(\"object\"!=typeof t||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e.call(t,r||\"default\");if(\"object\"!=typeof i)return i;throw new TypeError(\"@@toPrimitive must return a primitive value.\");}return(\"string\"===r?String:Number)(t);}function hasRequestManager(store){return'requestManager'in store;}class Store extends _ember_data_store__WEBPACK_IMPORTED_MODULE_5__[\"default\"]{constructor(args){super(args);_defineProperty(this,\"adapterFor\",_ember_data_legacy_compat__WEBPACK_IMPORTED_MODULE_1__.adapterFor);_defineProperty(this,\"serializerFor\",_ember_data_legacy_compat__WEBPACK_IMPORTED_MODULE_1__.serializerFor);_defineProperty(this,\"pushPayload\",_ember_data_legacy_compat__WEBPACK_IMPORTED_MODULE_1__.pushPayload);_defineProperty(this,\"normalize\",_ember_data_legacy_compat__WEBPACK_IMPORTED_MODULE_1__.normalize);_defineProperty(this,\"serializeRecord\",_ember_data_legacy_compat__WEBPACK_IMPORTED_MODULE_1__.serializeRecord);if(!hasRequestManager(this)){this.requestManager=new _ember_data_request__WEBPACK_IMPORTED_MODULE_3__[\"default\"]();this.requestManager.use([_ember_data_legacy_compat__WEBPACK_IMPORTED_MODULE_1__.LegacyNetworkHandler,_ember_data_request_fetch__WEBPACK_IMPORTED_MODULE_4__[\"default\"]]);}this.requestManager.useCache(_ember_data_store__WEBPACK_IMPORTED_MODULE_5__.CacheHandler);}createSchemaService(){return (0,_ember_data_model_hooks__WEBPACK_IMPORTED_MODULE_2__.buildSchema)(this);}createCache(storeWrapper){return new _ember_data_json_api__WEBPACK_IMPORTED_MODULE_0__[\"default\"](storeWrapper);}instantiateRecord(identifier,createRecordArgs){return _ember_data_model_hooks__WEBPACK_IMPORTED_MODULE_2__.instantiateRecord.call(this,identifier,createRecordArgs);}teardownRecord(record){_ember_data_model_hooks__WEBPACK_IMPORTED_MODULE_2__.teardownRecord.call(this,record);}modelFor(type){return _ember_data_model_hooks__WEBPACK_IMPORTED_MODULE_2__.modelFor.call(this,type)||super.modelFor(type);}destroy(){_ember_data_legacy_compat__WEBPACK_IMPORTED_MODULE_1__.cleanup.call(this);super.destroy();}}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/ember-data/dist/store.js?");

/***/ }),

/***/ "./node_modules/ember-page-title/dist/_rollupPluginBabelHelpers-9wjJaosZ.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/ember-page-title/dist/_rollupPluginBabelHelpers-9wjJaosZ.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: () => (/* binding */ _applyDecoratedDescriptor),\n/* harmony export */   a: () => (/* binding */ _initializerDefineProperty),\n/* harmony export */   b: () => (/* binding */ _defineProperty)\n/* harmony export */ });\nfunction _toPrimitive(t,r){if(\"object\"!=typeof t||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e.call(t,r||\"default\");if(\"object\"!=typeof i)return i;throw new TypeError(\"@@toPrimitive must return a primitive value.\");}return(\"string\"===r?String:Number)(t);}function _toPropertyKey(t){var i=_toPrimitive(t,\"string\");return\"symbol\"==typeof i?i:String(i);}function _defineProperty(obj,key,value){key=_toPropertyKey(key);if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}function _initializerDefineProperty(target,property,descriptor,context){if(!descriptor)return;Object.defineProperty(target,property,{enumerable:descriptor.enumerable,configurable:descriptor.configurable,writable:descriptor.writable,value:descriptor.initializer?descriptor.initializer.call(context):void 0});}function _applyDecoratedDescriptor(target,property,decorators,descriptor,context){var desc={};Object.keys(descriptor).forEach(function(key){desc[key]=descriptor[key];});desc.enumerable=!!desc.enumerable;desc.configurable=!!desc.configurable;if('value'in desc||desc.initializer){desc.writable=true;}desc=decorators.slice().reverse().reduce(function(desc,decorator){return decorator(target,property,desc)||desc;},desc);if(context&&desc.initializer!==void 0){desc.value=desc.initializer?desc.initializer.call(context):void 0;desc.initializer=undefined;}if(desc.initializer===void 0){Object.defineProperty(target,property,desc);desc=null;}return desc;}\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/ember-page-title/dist/_rollupPluginBabelHelpers-9wjJaosZ.js?");

/***/ }),

/***/ "./node_modules/ember-page-title/dist/helpers/page-title.js":
/*!******************************************************************!*\
  !*** ./node_modules/ember-page-title/dist/helpers/page-title.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ PageTitle)\n/* harmony export */ });\n/* harmony import */ var _rollupPluginBabelHelpers_9wjJaosZ_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_rollupPluginBabelHelpers-9wjJaosZ.js */ \"./node_modules/ember-page-title/dist/_rollupPluginBabelHelpers-9wjJaosZ.js\");\n/* harmony import */ var _ember_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ember/service */ \"@ember/service\");\n/* harmony import */ var _ember_service__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_ember_service__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _ember_component_helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ember/component/helper */ \"@ember/component/helper\");\n/* harmony import */ var _ember_component_helper__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_ember_component_helper__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _ember_object_internals__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ember/object/internals */ \"@ember/object/internals\");\n/* harmony import */ var _ember_object_internals__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_ember_object_internals__WEBPACK_IMPORTED_MODULE_3__);\nvar _dec,_class,_descriptor;/**\n * `{{pageTitle}}` helper used to set the title of the current route context.\n *\n * ```gjs\n * import { pageTitle } from 'ember-page-title';\n *\n * <template>\n *   {{pageTitle \"the text to set the tab's title to\"}}\n *   {{pageTitle \\@model.post.title}}\n * </template>\n * ```\n */let PageTitle=(_dec=(0,_ember_service__WEBPACK_IMPORTED_MODULE_1__.inject)('page-title'),_class=class PageTitle extends (_ember_component_helper__WEBPACK_IMPORTED_MODULE_2___default()){constructor(owner){super(owner);(0,_rollupPluginBabelHelpers_9wjJaosZ_js__WEBPACK_IMPORTED_MODULE_0__.a)(this,\"tokens\",_descriptor,this);(0,_rollupPluginBabelHelpers_9wjJaosZ_js__WEBPACK_IMPORTED_MODULE_0__.b)(this,\"tokenId\",(0,_ember_object_internals__WEBPACK_IMPORTED_MODULE_3__.guidFor)(this));this.tokens.push({id:this.tokenId});}compute(params,userOptions){const options={...userOptions,id:this.tokenId,title:params.join('')};this.tokens.push(options);this.tokens.scheduleTitleUpdate();// We must return an empty value here because otherwise\n// invoking the pageTitle helper will render something\n// in the component it's used in, and we don't want that.\n//\n// pageTitle is a side-effecting helper.\n// We *synchronize* the document.title with our internal state.\nreturn'';}willDestroy(){super.willDestroy();this.tokens.remove(this.tokenId);this.tokens.scheduleTitleUpdate();}},_descriptor=(0,_rollupPluginBabelHelpers_9wjJaosZ_js__WEBPACK_IMPORTED_MODULE_0__._)(_class.prototype,\"tokens\",[_dec],{configurable:true,enumerable:true,writable:true,initializer:null}),_class);\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/ember-page-title/dist/helpers/page-title.js?");

/***/ }),

/***/ "./node_modules/ember-page-title/dist/services/page-title.js":
/*!*******************************************************************!*\
  !*** ./node_modules/ember-page-title/dist/services/page-title.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ PageTitleService)\n/* harmony export */ });\n/* harmony import */ var _rollupPluginBabelHelpers_9wjJaosZ_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_rollupPluginBabelHelpers-9wjJaosZ.js */ \"./node_modules/ember-page-title/dist/_rollupPluginBabelHelpers-9wjJaosZ.js\");\n/* harmony import */ var _ember_runloop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ember/runloop */ \"@ember/runloop\");\n/* harmony import */ var _ember_runloop__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_ember_runloop__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _ember_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ember/service */ \"@ember/service\");\n/* harmony import */ var _ember_service__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_ember_service__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _ember_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ember/utils */ \"@ember/utils\");\n/* harmony import */ var _ember_utils__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_ember_utils__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _ember_debug__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ember/debug */ \"@ember/debug\");\n/* harmony import */ var _ember_debug__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_ember_debug__WEBPACK_IMPORTED_MODULE_4__);\nvar _dec,_dec2,_class,_descriptor,_descriptor2;const isFastBoot=typeof FastBoot!=='undefined';const RouterEvent={ROUTE_DID_CHANGE:'routeDidChange'};function hasResolveRegistration(owner){return`resolveRegistration`in owner;}function hasPageTitleConfig(fromEnv){if(typeof fromEnv!=='object')return false;if(fromEnv===null)return false;// all properties on the pageTitle config are optional,\n// so we can't check for more\nreturn'pageTitle'in fromEnv;}const configKeys=['separator','prepend','replace'];/**\n  @class page-title\n  @extends Ember.Service\n */let PageTitleService=(_dec=(0,_ember_service__WEBPACK_IMPORTED_MODULE_2__.inject)('router'),_dec2=(0,_ember_service__WEBPACK_IMPORTED_MODULE_2__.inject)('-document'),_class=class PageTitleService extends (_ember_service__WEBPACK_IMPORTED_MODULE_2___default()){constructor(owner){super(owner);(0,_rollupPluginBabelHelpers_9wjJaosZ_js__WEBPACK_IMPORTED_MODULE_0__.a)(this,\"router\",_descriptor,this);// in fastboot context \"document\" is instance of\n// ember-fastboot/simple-dom document\n(0,_rollupPluginBabelHelpers_9wjJaosZ_js__WEBPACK_IMPORTED_MODULE_0__.a)(this,\"document\",_descriptor2,this);(0,_rollupPluginBabelHelpers_9wjJaosZ_js__WEBPACK_IMPORTED_MODULE_0__.b)(this,\"tokens\",[]);(0,_rollupPluginBabelHelpers_9wjJaosZ_js__WEBPACK_IMPORTED_MODULE_0__.b)(this,\"_defaultConfig\",{// The default separator to use between tokens.\nseparator:' | ',// The default prepend value to use.\nprepend:true,// The default replace value to use.\nreplace:null});(0,_rollupPluginBabelHelpers_9wjJaosZ_js__WEBPACK_IMPORTED_MODULE_0__.b)(this,\"scheduleTitleUpdate\",()=>{(0,_ember_runloop__WEBPACK_IMPORTED_MODULE_1__.scheduleOnce)('afterRender',this,this._updateTitle);});this._validateExistingTitleElement();if(hasResolveRegistration(owner)){const config=owner.resolveRegistration('config:environment');if(hasPageTitleConfig(config)){configKeys.forEach(key=>{if(!(0,_ember_utils__WEBPACK_IMPORTED_MODULE_3__.isEmpty)(config.pageTitle[key])){const configValue=config.pageTitle[key];// SAFETY: how is one supposed to iterate over keys for an object and have it\n//         known to the compiler that both objects, having the same shape,\n//         will have the same type per-value?\n//         as-is, the `configValue` is a union of all value-types from the object.\nthis._defaultConfig[key]=configValue;}});}}this.router.on(RouterEvent.ROUTE_DID_CHANGE,this.scheduleTitleUpdate);}applyTokenDefaults(token){const defaultSeparator=this._defaultConfig.separator;const defaultPrepend=this._defaultConfig.prepend;const defaultReplace=this._defaultConfig.replace;token.previous??=null;token.next??=null;if(token.separator==null){token.separator=defaultSeparator;}if(token.prepend==null&&defaultPrepend!=null){token.prepend=defaultPrepend;}if(token.replace==null&&defaultReplace!=null){token.replace=defaultReplace;}}inheritFromPrevious(token){const previous=token.previous;if(previous){if(token.separator==null){token.separator=previous.separator;}if(token.prepend==null){token.prepend=previous.prepend;}}}push(token){const tokenForId=this._findTokenById(token.id);if(tokenForId){const index=this.tokens.indexOf(tokenForId);const tokens=[...this.tokens];const previous=tokenForId.previous;token.previous=previous;token.next=tokenForId.next;this.inheritFromPrevious(token);this.applyTokenDefaults(token);tokens.splice(index,1,token);this.tokens=tokens;return;}const previous=this.tokens.slice(-1)[0];if(previous){token.previous=previous??null;previous.next=token;this.inheritFromPrevious(token);}this.applyTokenDefaults(token);this.tokens=[...this.tokens,token];}remove(id){const token=this._findTokenById(id);if(!token)return;const{next,previous}=token;if(next){next.previous=previous;}if(previous){previous.next=next;}token.previous=token.next=null;const tokens=[...this.tokens];tokens.splice(tokens.indexOf(token),1);this.tokens=tokens;}get visibleTokens(){const tokens=this.tokens;let i=tokens?tokens.length:0;const visible=[];while(i--){const token=tokens[i];if(!token)continue;if(token.replace){visible.unshift(token);break;}else{visible.unshift(token);}}return visible;}get sortedTokens(){const visible=this.visibleTokens;if(!visible)return[];let appending=true;let group=[];const groups=[group];const frontGroups=[];visible.forEach(token=>{if(token.front){frontGroups.unshift(token);}else if(token.prepend){if(appending){appending=false;group=[];groups.push(group);}const lastToken=group[0];if(lastToken){token={...token};token.separator=lastToken.separator;}group.unshift(token);}else{if(!appending){appending=true;group=[];groups.push(group);}group.push(token);}});return frontGroups.concat(groups.reduce((E,group)=>E.concat(group),[]));}toString(){const tokens=this.sortedTokens;const title=[];for(let i=0,len=tokens.length;i<len;i++){const token=tokens[i];if(!token)continue;if(token.title){title.push(token.title);if(i+1<len){title.push(token.separator);}}}return title.join('');}willDestroy(){super.willDestroy();this.router.off(RouterEvent.ROUTE_DID_CHANGE,this.scheduleTitleUpdate);}_updateTitle(){const toBeTitle=this.toString();if(isFastBoot){this.updateFastbootTitle(toBeTitle);}else{/**\n       * When rendering app with \"?fastboot=false\" (http://ember-fastboot.com/docs/user-guide#disabling-fastboot)\n       * We will not have <title> element present in DOM.\n       *\n       * But this is fine as by HTML spec,\n       * one is created upon assigning \"document.title\" value;\n       *\n       * https://html.spec.whatwg.org/multipage/dom.html#dom-tree-accessors\n       */this.document.title=toBeTitle;}this.titleDidUpdate(toBeTitle);}/**\n   * Validate if there's more than one title element present.\n   *\n   * Example: ember-cli-head can cause conflicting updates.\n   * @private\n   */_validateExistingTitleElement(){if(isFastBoot){return;}(0,_ember_debug__WEBPACK_IMPORTED_MODULE_4__.assert)('[ember-page-title]: Multiple title elements found. Check for other addons like ember-cli-head updating <title> as well.',document.head.querySelectorAll('title').length<=1);}/**\n   * Find token by id\n   *\n   * @param {String} id\n   * @private\n   */_findTokenById(id){return this.tokens.find(token=>token.id===id);}updateFastbootTitle(toBeTitle){if(!isFastBoot){return;}const headElement=this.document.head;const headChildNodes=headElement.childNodes;// Remove existing title elements from previous render cycle\nfor(let i=0;i<headChildNodes.length;i++){const node=headChildNodes[i];if(!node)continue;if(node.nodeName.toLowerCase()==='title'){headElement.removeChild(node);}}// Add title element with latest value\nconst titleEl=this.document.createElement('title');const titleContents=this.document.createTextNode(toBeTitle);titleEl.appendChild(titleContents);headElement.appendChild(titleEl);}// eslint-disable-next-line @typescript-eslint/no-unused-vars\ntitleDidUpdate(_title){// default is empty, meant to be overriden by user if desired\n}},_descriptor=(0,_rollupPluginBabelHelpers_9wjJaosZ_js__WEBPACK_IMPORTED_MODULE_0__._)(_class.prototype,\"router\",[_dec],{configurable:true,enumerable:true,writable:true,initializer:null}),_descriptor2=(0,_rollupPluginBabelHelpers_9wjJaosZ_js__WEBPACK_IMPORTED_MODULE_0__._)(_class.prototype,\"document\",[_dec2],{configurable:true,enumerable:true,writable:true,initializer:null}),_class);\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/ember-page-title/dist/services/page-title.js?");

/***/ }),

/***/ "./node_modules/ember-welcome-page/dist/components/welcome-page.js":
/*!*************************************************************************!*\
  !*** ./node_modules/ember-welcome-page/dist/components/welcome-page.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WelcomePageComponent)\n/* harmony export */ });\n/* harmony import */ var _ember_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ember/component */ \"@ember/component\");\n/* harmony import */ var _ember_component__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ember_component__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _ember_application__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ember/application */ \"@ember/application\");\n/* harmony import */ var _ember_application__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_ember_application__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _ember_version__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ember/version */ \"@ember/version\");\n/* harmony import */ var _ember_version__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_ember_version__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _glimmer_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @glimmer/component */ \"@glimmer/component\");\n/* harmony import */ var _glimmer_component__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_glimmer_component__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _welcome_page_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./welcome-page.css */ \"./node_modules/ember-welcome-page/dist/components/welcome-page.css\");\n/* harmony import */ var _ember_template_factory__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ember/template-factory */ \"@ember/template-factory\");\n/* harmony import */ var _ember_template_factory__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_ember_template_factory__WEBPACK_IMPORTED_MODULE_5__);\nvar TEMPLATE=(0,_ember_template_factory__WEBPACK_IMPORTED_MODULE_5__.createTemplateFactory)(/*\n  <main id=\"ember-welcome-page-id-selector\">\n  <div class=\"columns\">\n    <div class=\"tomster\">\n      <img src=\"{{this.rootURL}}ember-welcome-page/images/construction.png\" alt=\"Under construction\">\n    </div>\n    <div class=\"welcome\">\n      <h1 id=\"title\">Congratulations, you made it!</h1>\n\n      <p>You&rsquo;ve officially spun up your Ember app. You&rsquo;ve got one more decision to make: what do you want to do next? We&rsquo;d suggest one of the following to help you get going:</p>\n      <ul>\n        <li><a href=\"{{this.urlForEmberGuides}}/getting-started/quick-start/\">Quick Start</a> - a quick introduction to how Ember works. Learn about defining your first route, writing a UI component and deploying your application.</li>\n        <li><a href=\"{{this.urlForEmberGuides}}/tutorial/\">Tutorial</a> - this is our more thorough, hands-on intro to Ember. Your crash course in Ember philosophy, background and some in-depth discussion of how things work (and why they work the way they do).</li>\n      </ul>\n      <p>If you run into problems, please join <a href=\"https://discord.gg/emberjs\">our community's Discord server</a> or visit <a href=\"http://discuss.emberjs.com/\">our forums</a> for ideas and answers— our community is filled with friendly folks who are willing to help! We enjoy helping new Ember developers get started, and our <a href=\"https://emberjs.com/community/\">Ember Community</a> is incredibly supportive.</p>\n    </div>\n  </div>\n  <p class=\"postscript\">To remove this welcome message, remove the\n    <code>\n      &lt;WelcomePage /&gt;\n    </code>\n    component from your\n    <code>\n      app/templates/application.hbs\n    </code>\n    file and save it...you'll see this page update soon after!\n  </p>\n</main>\n\n\n*/{\"id\":\"rcYIbyp9\",\"block\":\"[[[10,\\\"main\\\"],[14,1,\\\"ember-welcome-page-id-selector\\\"],[12],[1,\\\"\\\\n  \\\"],[10,0],[14,0,\\\"columns\\\"],[12],[1,\\\"\\\\n    \\\"],[10,0],[14,0,\\\"tomster\\\"],[12],[1,\\\"\\\\n      \\\"],[10,\\\"img\\\"],[15,\\\"src\\\",[29,[[30,0,[\\\"rootURL\\\"]],\\\"ember-welcome-page/images/construction.png\\\"]]],[14,\\\"alt\\\",\\\"Under construction\\\"],[12],[13],[1,\\\"\\\\n    \\\"],[13],[1,\\\"\\\\n    \\\"],[10,0],[14,0,\\\"welcome\\\"],[12],[1,\\\"\\\\n      \\\"],[10,\\\"h1\\\"],[14,1,\\\"title\\\"],[12],[1,\\\"Congratulations, you made it!\\\"],[13],[1,\\\"\\\\n\\\\n      \\\"],[10,2],[12],[1,\\\"You’ve officially spun up your Ember app. You’ve got one more decision to make: what do you want to do next? We’d suggest one of the following to help you get going:\\\"],[13],[1,\\\"\\\\n      \\\"],[10,\\\"ul\\\"],[12],[1,\\\"\\\\n        \\\"],[10,\\\"li\\\"],[12],[10,3],[15,6,[29,[[30,0,[\\\"urlForEmberGuides\\\"]],\\\"/getting-started/quick-start/\\\"]]],[12],[1,\\\"Quick Start\\\"],[13],[1,\\\" - a quick introduction to how Ember works. Learn about defining your first route, writing a UI component and deploying your application.\\\"],[13],[1,\\\"\\\\n        \\\"],[10,\\\"li\\\"],[12],[10,3],[15,6,[29,[[30,0,[\\\"urlForEmberGuides\\\"]],\\\"/tutorial/\\\"]]],[12],[1,\\\"Tutorial\\\"],[13],[1,\\\" - this is our more thorough, hands-on intro to Ember. Your crash course in Ember philosophy, background and some in-depth discussion of how things work (and why they work the way they do).\\\"],[13],[1,\\\"\\\\n      \\\"],[13],[1,\\\"\\\\n      \\\"],[10,2],[12],[1,\\\"If you run into problems, please join \\\"],[10,3],[14,6,\\\"https://discord.gg/emberjs\\\"],[12],[1,\\\"our community's Discord server\\\"],[13],[1,\\\" or visit \\\"],[10,3],[14,6,\\\"http://discuss.emberjs.com/\\\"],[12],[1,\\\"our forums\\\"],[13],[1,\\\" for ideas and answers— our community is filled with friendly folks who are willing to help! We enjoy helping new Ember developers get started, and our \\\"],[10,3],[14,6,\\\"https://emberjs.com/community/\\\"],[12],[1,\\\"Ember Community\\\"],[13],[1,\\\" is incredibly supportive.\\\"],[13],[1,\\\"\\\\n    \\\"],[13],[1,\\\"\\\\n  \\\"],[13],[1,\\\"\\\\n  \\\"],[10,2],[14,0,\\\"postscript\\\"],[12],[1,\\\"To remove this welcome message, remove the\\\\n    \\\"],[10,\\\"code\\\"],[12],[1,\\\"\\\\n      <WelcomePage />\\\\n    \\\"],[13],[1,\\\"\\\\n    component from your\\\\n    \\\"],[10,\\\"code\\\"],[12],[1,\\\"\\\\n      app/templates/application.hbs\\\\n    \\\"],[13],[1,\\\"\\\\n    file and save it...you'll see this page update soon after!\\\\n  \\\"],[13],[1,\\\"\\\\n\\\"],[13],[1,\\\"\\\\n\\\\n\\\"]],[],false,[\\\"main\\\",\\\"div\\\",\\\"img\\\",\\\"h1\\\",\\\"p\\\",\\\"ul\\\",\\\"li\\\",\\\"a\\\",\\\"code\\\"]]\",\"moduleName\":\"C:\\\\gitlocal\\\\super-rentals\\\\super-rentals\\\\node_modules\\\\ember-welcome-page\\\\dist\\\\components\\\\welcome-page.js\",\"isStrictMode\":false});function isLatestVersion(){const stableRegex=/^\\d+\\.\\d+\\.\\d+$/;return!stableRegex.test(_ember_version__WEBPACK_IMPORTED_MODULE_2__.VERSION);}/* eslint-disable-next-line @typescript-eslint/no-empty-interface */class WelcomePageComponent extends (_glimmer_component__WEBPACK_IMPORTED_MODULE_3___default()){get rootURL(){const config=(0,_ember_application__WEBPACK_IMPORTED_MODULE_1__.getOwner)(this).factoryFor('config:environment');if(config){return config.class.rootURL;}return'/';}get urlForEmberGuides(){if(isLatestVersion()){return`https://guides.emberjs.com/release`;}const[majorVersion,minorVersion]=_ember_version__WEBPACK_IMPORTED_MODULE_2__.VERSION.split('.');const emberVersion=`${majorVersion}.${minorVersion}.0`;return`https://guides.emberjs.com/v${emberVersion}`;}}(0,_ember_component__WEBPACK_IMPORTED_MODULE_0__.setComponentTemplate)(TEMPLATE,WelcomePageComponent);\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/ember-welcome-page/dist/components/welcome-page.js?");

/***/ }),

/***/ "./node_modules/qunit/qunit/qunit.js":
/*!*******************************************!*\
  !*** ./node_modules/qunit/qunit/qunit.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * QUnit 2.22.0\n * https://qunitjs.com/\n *\n * Copyright OpenJS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n */(function(){'use strict';function _arrayLikeToArray(r,a){(null==a||a>r.length)&&(a=r.length);for(var e=0,n=Array(a);e<a;e++)n[e]=r[e];return n;}function _arrayWithHoles(r){if(Array.isArray(r))return r;}function _arrayWithoutHoles(r){if(Array.isArray(r))return _arrayLikeToArray(r);}function _classCallCheck(a,n){if(!(a instanceof n))throw new TypeError(\"Cannot call a class as a function\");}function _defineProperties(e,r){for(var t=0;t<r.length;t++){var o=r[t];o.enumerable=o.enumerable||!1,o.configurable=!0,\"value\"in o&&(o.writable=!0),Object.defineProperty(e,_toPropertyKey(o.key),o);}}function _createClass(e,r,t){return r&&_defineProperties(e.prototype,r),t&&_defineProperties(e,t),Object.defineProperty(e,\"prototype\",{writable:!1}),e;}function _createForOfIteratorHelper(r,e){var t=\"undefined\"!=typeof Symbol&&r[Symbol.iterator]||r[\"@@iterator\"];if(!t){if(Array.isArray(r)||(t=_unsupportedIterableToArray(r))||e&&r&&\"number\"==typeof r.length){t&&(r=t);var n=0,F=function(){};return{s:F,n:function(){return n>=r.length?{done:!0}:{done:!1,value:r[n++]};},e:function(r){throw r;},f:F};}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}var o,a=!0,u=!1;return{s:function(){t=t.call(r);},n:function(){var r=t.next();return a=r.done,r;},e:function(r){u=!0,o=r;},f:function(){try{a||null==t.return||t.return();}finally{if(u)throw o;}}};}function _iterableToArray(r){if(\"undefined\"!=typeof Symbol&&null!=r[Symbol.iterator]||null!=r[\"@@iterator\"])return Array.from(r);}function _iterableToArrayLimit(r,l){var t=null==r?null:\"undefined\"!=typeof Symbol&&r[Symbol.iterator]||r[\"@@iterator\"];if(null!=t){var e,n,i,u,a=[],f=!0,o=!1;try{if(i=(t=t.call(r)).next,0===l){if(Object(t)!==t)return;f=!1;}else for(;!(f=(e=i.call(t)).done)&&(a.push(e.value),a.length!==l);f=!0);}catch(r){o=!0,n=r;}finally{try{if(!f&&null!=t.return&&(u=t.return(),Object(u)!==u))return;}finally{if(o)throw n;}}return a;}}function _nonIterableRest(){throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}function _nonIterableSpread(){throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}function _slicedToArray(r,e){return _arrayWithHoles(r)||_iterableToArrayLimit(r,e)||_unsupportedIterableToArray(r,e)||_nonIterableRest();}function _toConsumableArray(r){return _arrayWithoutHoles(r)||_iterableToArray(r)||_unsupportedIterableToArray(r)||_nonIterableSpread();}function _toPrimitive(t,r){if(\"object\"!=typeof t||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e.call(t,r||\"default\");if(\"object\"!=typeof i)return i;throw new TypeError(\"@@toPrimitive must return a primitive value.\");}return(\"string\"===r?String:Number)(t);}function _toPropertyKey(t){var i=_toPrimitive(t,\"string\");return\"symbol\"==typeof i?i:i+\"\";}function _typeof(o){\"@babel/helpers - typeof\";return _typeof=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(o){return typeof o;}:function(o){return o&&\"function\"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol.prototype?\"symbol\":typeof o;},_typeof(o);}function _unsupportedIterableToArray(r,a){if(r){if(\"string\"==typeof r)return _arrayLikeToArray(r,a);var t={}.toString.call(r).slice(8,-1);return\"Object\"===t&&r.constructor&&(t=r.constructor.name),\"Map\"===t||\"Set\"===t?Array.from(r):\"Arguments\"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?_arrayLikeToArray(r,a):void 0;}}// We don't use global-this-polyfill [1], because it modifies\n// the globals scope by default. QUnit must not affect the host context\n// as developers may test their project may be such a polyfill, and/or\n// they may intentionally test their project with and without certain\n// polyfills and we must not affect that. It also uses an obscure\n// mechanism that seems to sometimes causes a runtime error in older\n// browsers (specifically Safari and IE versions that support\n// Object.defineProperty but then report _T_ as undefined).\n// [1] https://github.com/ungap/global-this/blob/v0.4.4/esm/index.js\n//\n// Another way is `Function('return this')()`, but doing so relies\n// on eval which will cause a CSP error on some servers.\n//\n// Instead, simply check the four options that already exist\n// in all supported environments.\nfunction getGlobalThis(){if(typeof globalThis!=='undefined'){// For SpiderMonkey, modern browsers, and recent Node.js\n// eslint-disable-next-line no-undef\nreturn globalThis;}if(typeof self!=='undefined'){// For web workers\n// eslint-disable-next-line no-undef\nreturn self;}if(typeof window$1!=='undefined'){// For document context in browsers\nreturn window$1;}if(typeof global!=='undefined'){// For Node.js\n// eslint-disable-next-line no-undef\nreturn global;}throw new Error('Unable to locate global object');}// This avoids a simple `export const` assignment as that would lead Rollup\n// to change getGlobalThis and use the same (generated) variable name there.\nvar g=getGlobalThis();// These optional globals are undefined in one or more environments:\n// modern browser, old browser, Node.js, SpiderMonkey.\n// Calling code must check these for truthy-ness before use.\nvar console$1=g.console;var setTimeout$1=g.setTimeout;var clearTimeout=g.clearTimeout;var process$1=g.process;var window$1=g.window;var document=window$1&&window$1.document;var navigator=window$1&&window$1.navigator;var localSessionStorage=function(){var x='qunit-test-string';try{g.sessionStorage.setItem(x,x);g.sessionStorage.removeItem(x);return g.sessionStorage;}catch(e){return undefined;}}();// Basic fallback for ES6 Map\n// Support: IE 9-10, Safari 7, PhantomJS; Map is undefined\n// Support: iOS 8; `new Map(iterable)` is not supported\n//\n// Fallback for ES7 Map#keys\n// Support: IE 11; Map#keys is undefined\nvar StringMap=typeof g.Map==='function'&&typeof g.Map.prototype.keys==='function'&&typeof g.Symbol==='function'&&_typeof(g.Symbol.iterator)==='symbol'?g.Map:function StringMap(input){var _this=this;var store=Object.create(null);var hasOwn=Object.prototype.hasOwnProperty;this.has=function(strKey){return hasOwn.call(store,strKey);};this.get=function(strKey){return store[strKey];};this.set=function(strKey,val){if(!hasOwn.call(store,strKey)){this.size++;}store[strKey]=val;return this;};this.delete=function(strKey){if(hasOwn.call(store,strKey)){delete store[strKey];this.size--;}};this.forEach=function(callback){for(var strKey in store){callback(store[strKey],strKey);}};this.keys=function(){return Object.keys(store);};this.clear=function(){store=Object.create(null);this.size=0;};this.size=0;if(input){input.forEach(function(val,strKey){_this.set(strKey,val);});}};// Basic fallback for ES6 Set\n// Support: IE 11, `new Set(iterable)` parameter not yet implemented\n// Test for Set#values() which came after Set(iterable).\nvar StringSet=typeof g.Set==='function'&&typeof g.Set.prototype.values==='function'?g.Set:function(input){var set=Object.create(null);if(Array.isArray(input)){input.forEach(function(item){set[item]=true;});}return{add:function add(value){set[value]=true;},has:function has(value){return value in set;},get size(){return Object.keys(set).length;}};};var toString=Object.prototype.toString;var hasOwn$2=Object.prototype.hasOwnProperty;var performance={// eslint-disable-next-line compat/compat -- Checked\nnow:window$1&&window$1.performance&&window$1.performance.now?window$1.performance.now.bind(window$1.performance):Date.now};// Returns a new Array with the elements that are in a but not in b\nfunction diff$1(a,b){return a.filter(function(a){return b.indexOf(a)===-1;});}/**\n   * Determines whether an element exists in a given array or not.\n   *\n   * @method inArray\n   * @param {any} elem\n   * @param {Array} array\n   * @return {boolean}\n   */var inArray=Array.prototype.includes?function(elem,array){return array.includes(elem);}:function(elem,array){return array.indexOf(elem)!==-1;};/**\n   * Recursively clone an object into a plain array or object, taking only the\n   * own enumerable properties.\n   *\n   * @param {any} obj\n   * @param {bool} [allowArray=true]\n   * @return {Object|Array}\n   */function objectValues(obj){var allowArray=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;var vals=allowArray&&is('array',obj)?[]:{};for(var key in obj){if(hasOwn$2.call(obj,key)){var val=obj[key];vals[key]=val===Object(val)?objectValues(val,allowArray):val;}}return vals;}/**\n   * Recursively clone an object into a plain object, taking only the\n   * subset of own enumerable properties that exist a given model.\n   *\n   * @param {any} obj\n   * @param {any} model\n   * @return {Object}\n   */function objectValuesSubset(obj,model){// Return primitive values unchanged to avoid false positives or confusing\n// results from assert.propContains().\n// E.g. an actual null or false wrongly equaling an empty object,\n// or an actual string being reported as object not matching a partial object.\nif(obj!==Object(obj)){return obj;}// Unlike objectValues(), subset arrays to a plain objects as well.\n// This enables subsetting [20, 30] with {1: 30}.\nvar subset={};for(var key in model){if(hasOwn$2.call(model,key)&&hasOwn$2.call(obj,key)){subset[key]=objectValuesSubset(obj[key],model[key]);}}return subset;}function extend(a,b,undefOnly){for(var prop in b){if(hasOwn$2.call(b,prop)){if(b[prop]===undefined){delete a[prop];}else if(!(undefOnly&&typeof a[prop]!=='undefined')){a[prop]=b[prop];}}}return a;}function objectType(obj){if(typeof obj==='undefined'){return'undefined';}// Consider: typeof null === object\nif(obj===null){return'null';}var match=toString.call(obj).match(/^\\[object\\s(.*)\\]$/);var type=match&&match[1];switch(type){case'Number':if(isNaN(obj)){return'nan';}return'number';case'String':case'Boolean':case'Array':case'Set':case'Map':case'Date':case'RegExp':case'Function':case'Symbol':return type.toLowerCase();default:return _typeof(obj);}}// Safe object type checking\nfunction is(type,obj){return objectType(obj)===type;}// Based on Java's String.hashCode, a simple but not\n// rigorously collision resistant hashing function\nfunction generateHash(module,testName){var str=module+'\\x1C'+testName;var hash=0;for(var i=0;i<str.length;i++){hash=(hash<<5)-hash+str.charCodeAt(i);hash|=0;}// Convert the possibly negative integer hash code into an 8 character hex string, which isn't\n// strictly necessary but increases user understanding that the id is a SHA-like hash\nvar hex=(0x100000000+hash).toString(16);if(hex.length<8){hex='0000000'+hex;}return hex.slice(-8);}/**\n   * Converts an error into a simple string for comparisons.\n   *\n   * @param {Error|any} error\n   * @return {string}\n   */function errorString(error){// Use String() instead of toString() to handle non-object values like undefined or null.\nvar resultErrorString=String(error);// If the error wasn't a subclass of Error but something like\n// an object literal with name and message properties...\nif(resultErrorString.slice(0,7)==='[object'){// Based on https://es5.github.io/#x15.11.4.4\nreturn(error.name||'Error')+(error.message?\": \".concat(error.message):'');}else{return resultErrorString;}}function escapeText(str){if(!str){return'';}// Both single quotes and double quotes (for attributes)\nreturn(''+str).replace(/['\"<>&]/g,function(s){switch(s){case\"'\":return'&#039;';case'\"':return'&quot;';case'<':return'&lt;';case'>':return'&gt;';case'&':return'&amp;';}});}var BOXABLE_TYPES=new StringSet(['boolean','number','string']);// Memory for previously seen containers (object, array, map, set).\n// Used for recursion detection, and to avoid repeated comparison.\n//\n// Elements are { a: val, b: val }.\nvar memory=[];function useStrictEquality(a,b){return a===b;}function useObjectValueEquality(a,b){return a===b||a.valueOf()===b.valueOf();}function compareConstructors(a,b){// Comparing constructors is more strict than using `instanceof`\nreturn getConstructor(a)===getConstructor(b);}function getConstructor(obj){var proto=Object.getPrototypeOf(obj);// If the obj prototype descends from a null constructor, treat it\n// as a null prototype.\n// Ref https://github.com/qunitjs/qunit/issues/851\n//\n// Allow objects with no prototype, from Object.create(null), to be equivalent to\n// plain objects that have Object as their constructor.\nreturn!proto||proto.constructor===null?Object:obj.constructor;}function getRegExpFlags(regexp){return'flags'in regexp?regexp.flags:regexp.toString().match(/[gimuy]*$/)[0];}// Specialised comparisons after entryTypeCallbacks.object, based on `objectType()`\nvar objTypeCallbacks={undefined:useStrictEquality,null:useStrictEquality,// Handle boxed boolean\nboolean:useObjectValueEquality,number:function number(a,b){// Handle NaN and boxed number\nreturn a===b||a.valueOf()===b.valueOf()||isNaN(a.valueOf())&&isNaN(b.valueOf());},// Handle boxed string\nstring:useObjectValueEquality,symbol:useStrictEquality,date:useObjectValueEquality,nan:function nan(){return true;},regexp:function regexp(a,b){return a.source===b.source&&// Include flags in the comparison\ngetRegExpFlags(a)===getRegExpFlags(b);},// identical reference only\nfunction:useStrictEquality,array:function array(a,b){if(a.length!==b.length){// Safe and faster\nreturn false;}for(var i=0;i<a.length;i++){if(!typeEquiv(a[i],b[i])){return false;}}return true;},// Define sets a and b to be equivalent if for each element aVal in a, there\n// is some element bVal in b such that aVal and bVal are equivalent. Element\n// repetitions are not counted, so these are equivalent:\n// a = new Set( [ X={}, Y=[], Y ] );\n// b = new Set( [ Y, X, X ] );\nset:function set(a,b){if(a.size!==b.size){// This optimization has certain quirks because of the lack of\n// repetition counting. For instance, adding the same\n// (reference-identical) element to two equivalent sets can\n// make them non-equivalent.\nreturn false;}var outerEq=true;a.forEach(function(aVal){// Short-circuit if the result is already known. (Using for...of\n// with a break clause would be cleaner here, but it would cause\n// a syntax error on older JavaScript implementations even if\n// Set is unused)\nif(!outerEq){return;}var innerEq=false;b.forEach(function(bVal){// Likewise, short-circuit if the result is already known\nif(innerEq){return;}// Swap out the global memory, as nested typeEquiv() would clobber it\nvar originalMemory=memory;memory=[];if(typeEquiv(bVal,aVal)){innerEq=true;}// Restore\nmemory=originalMemory;});if(!innerEq){outerEq=false;}});return outerEq;},// Define maps a and b to be equivalent if for each key-value pair (aKey, aVal)\n// in a, there is some key-value pair (bKey, bVal) in b such that\n// [ aKey, aVal ] and [ bKey, bVal ] are equivalent. Key repetitions are not\n// counted, so these are equivalent:\n// a = new Map( [ [ {}, 1 ], [ {}, 1 ], [ [], 1 ] ] );\n// b = new Map( [ [ {}, 1 ], [ [], 1 ], [ [], 1 ] ] );\nmap:function map(a,b){if(a.size!==b.size){// This optimization has certain quirks because of the lack of\n// repetition counting. For instance, adding the same\n// (reference-identical) key-value pair to two equivalent maps\n// can make them non-equivalent.\nreturn false;}var outerEq=true;a.forEach(function(aVal,aKey){// Short-circuit if the result is already known. (Using for...of\n// with a break clause would be cleaner here, but it would cause\n// a syntax error on older JavaScript implementations even if\n// Map is unused)\nif(!outerEq){return;}var innerEq=false;b.forEach(function(bVal,bKey){// Likewise, short-circuit if the result is already known\nif(innerEq){return;}// Swap out the global memory, as nested typeEquiv() would clobber it\nvar originalMemory=memory;memory=[];if(objTypeCallbacks.array([bVal,bKey],[aVal,aKey])){innerEq=true;}// Restore\nmemory=originalMemory;});if(!innerEq){outerEq=false;}});return outerEq;}};// Entry points from typeEquiv, based on `typeof`\nvar entryTypeCallbacks={undefined:useStrictEquality,null:useStrictEquality,boolean:useStrictEquality,number:function number(a,b){// Handle NaN\nreturn a===b||isNaN(a)&&isNaN(b);},string:useStrictEquality,symbol:useStrictEquality,function:useStrictEquality,object:function object(a,b){// Handle memory (skip recursion)\nif(memory.some(function(pair){return pair.a===a&&pair.b===b;})){return true;}memory.push({a:a,b:b});var aObjType=objectType(a);var bObjType=objectType(b);if(aObjType!=='object'||bObjType!=='object'){// Handle literal `null`\n// Handle: Array, Map/Set, Date, Regxp/Function, boxed primitives\nreturn aObjType===bObjType&&objTypeCallbacks[aObjType](a,b);}// NOTE: Literal null must not make it here as it would throw\nif(compareConstructors(a,b)===false){return false;}var aProperties=[];var bProperties=[];// Be strict and go deep, no filtering with hasOwnProperty.\nfor(var i in a){// Collect a's properties\naProperties.push(i);// Skip OOP methods that look the same\nif(a.constructor!==Object&&typeof a.constructor!=='undefined'&&typeof a[i]==='function'&&typeof b[i]==='function'&&a[i].toString()===b[i].toString()){continue;}if(!typeEquiv(a[i],b[i])){return false;}}for(var _i in b){// Collect b's properties\nbProperties.push(_i);}return objTypeCallbacks.array(aProperties.sort(),bProperties.sort());}};function typeEquiv(a,b){// Optimization: Only perform type-specific comparison when pairs are not strictly equal.\nif(a===b){return true;}var aType=_typeof(a);var bType=_typeof(b);if(aType!==bType){// Support comparing primitive to boxed primitives\n// Try again after possibly unwrapping one\nreturn(aType==='object'&&BOXABLE_TYPES.has(objectType(a))?a.valueOf():a)===(bType==='object'&&BOXABLE_TYPES.has(objectType(b))?b.valueOf():b);}return entryTypeCallbacks[aType](a,b);}function innerEquiv(a,b){var res=typeEquiv(a,b);// Release any retained objects and reset recursion detection for next call\nmemory=[];return res;}/**\n   * Test any two types of JavaScript values for equality.\n   *\n   * @author Philippe Rathé <prathe@gmail.com>\n   * @author David Chan <david@troi.org>\n   */function equiv(a,b){if(arguments.length===2){return a===b||innerEquiv(a,b);}// Given 0 or 1 arguments, just return true (nothing to compare).\n// Given (A,B,C,D) compare C,D then B,C then A,B.\nvar i=arguments.length-1;while(i>0){if(!innerEquiv(arguments[i-1],arguments[i])){return false;}i--;}return true;}/**\n   * Config object: Maintain internal state\n   * Later exposed as QUnit.config\n   * `config` initialized at top of scope\n   */var config={// HTML Reporter: Modify document.title when suite is done\naltertitle:true,// TODO: Move here from /src/core.js in QUnit 3.\n// autostart: true,\n// HTML Reporter: collapse every test except the first failing test\n// If false, all failing tests will be expanded\ncollapse:true,countStepsAsOne:false,// TODO: Make explicit in QUnit 3.\n// current: undefined,\n// whether or not to fail when there are zero tests\n// defaults to `true`\nfailOnZeroTests:true,// Select by pattern or case-insensitive substring match against \"moduleName: testName\"\nfilter:undefined,// TODO: Make explicit in QUnit 3.\n// fixture: undefined,\n// Depth up-to which object will be dumped\nmaxDepth:5,// Select case-insensitive match of the module name\nmodule:undefined,// HTML Reporter: Select module/test by array of internal IDs\nmoduleId:undefined,// By default, run previously failed tests first\n// very useful in combination with \"Hide passed tests\" checked\nreorder:true,// When enabled, all tests must call expect()\nrequireExpects:false,// By default, scroll to top of the page when suite is done\nscrolltop:true,// TODO: Make explicit in QUnit 3.\n// seed: undefined,\n// The storage module to use for reordering tests\nstorage:localSessionStorage,testId:undefined,// The updateRate controls how often QUnit will yield the main thread\n// between tests. This is mainly for the benefit of the HTML Reporter,\n// so that the browser can visually paint DOM changes with test results.\n// This also helps avoid causing browsers to prompt a warning about\n// long-running scripts.\n// TODO: Move here from /src/core.js in QUnit 3.\n// updateRate: 1000,\n// HTML Reporter: List of URL parameters that are given visual controls\nurlConfig:[],// Internal: The first unnamed module\n//\n// By being defined as the intial value for currentModule, it is the\n// receptacle and implied parent for any global tests. It is as if we\n// called `QUnit.module( \"\" );` before any other tests were defined.\n//\n// If we reach begin() and no tests were put in it, we dequeue it as if it\n// never existed, and in that case never expose it to the events and\n// callbacks API.\n//\n// When global tests are defined, then this unnamed module will execute\n// as any other module, including moduleStart/moduleDone events etc.\n//\n// Since this module isn't explicitly created by the user, they have no\n// access to add hooks for it. The hooks object is defined to comply\n// with internal expectations of test.js, but they will be empty.\n// To apply hooks, place tests explicitly in a QUnit.module(), and use\n// its hooks accordingly.\n//\n// For global hooks that apply to all tests and all modules, use QUnit.hooks.\n//\n// NOTE: This is *not* a \"global module\". It is not an ancestor of all modules\n// and tests. It is merely the parent for any tests defined globally,\n// before the first QUnit.module(). As such, the events for this unnamed\n// module will fire as normal, right after its last test, and *not* at\n// the end of the test run.\n//\n// NOTE: This also should probably also not become a global module, unless\n// we keep it out of the public API. For example, it would likely not\n// improve the user interface and plugin behaviour if all modules became\n// wrapped between the start and end events of this module, and thus\n// needlessly add indentation, indirection, or other visible noise.\n// Unit tests for the callbacks API would detect that as a regression.\ncurrentModule:{name:'',tests:[],childModules:[],testsRun:0,testsIgnored:0,hooks:{before:[],beforeEach:[],afterEach:[],after:[]}},// Internal: Exposed to make resets easier\n// Ref https://github.com/qunitjs/qunit/pull/1598\nglobalHooks:{},// Internal: ProcessingQueue singleton, created in /src/core.js\npq:null,// Internal: Created in /src/core.js\n// TODO: Move definitions here in QUnit 3.0.\n// started: 0,\n// Internal state\n_deprecated_timeout_shown:false,_deprecated_countEachStep_shown:false,blocking:true,callbacks:{},modules:[],queue:[],stats:{all:0,bad:0,testCount:0}};function readFlatPreconfigBoolean(val,dest){if(typeof val==='boolean'||typeof val==='string'&&val!==''){config[dest]=val===true||val==='true';}}function readFlatPreconfigNumber(val,dest){if(typeof val==='number'||typeof val==='string'&&/^[0-9]+$/.test(val)){config[dest]=+val;}}function readFlatPreconfigString(val,dest){if(typeof val==='string'&&val!==''){config[dest]=val;}}function readFlatPreconfigStringArray(val,dest){if(typeof val==='string'&&val!==''){config[dest]=[val];}}function readFlatPreconfig(obj){readFlatPreconfigBoolean(obj.qunit_config_altertitle,'altertitle');readFlatPreconfigBoolean(obj.qunit_config_autostart,'autostart');readFlatPreconfigBoolean(obj.qunit_config_collapse,'collapse');readFlatPreconfigBoolean(obj.qunit_config_failonzerotests,'failOnZeroTests');readFlatPreconfigString(obj.qunit_config_filter,'filter');readFlatPreconfigString(obj.qunit_config_fixture,'fixture');readFlatPreconfigBoolean(obj.qunit_config_hidepassed,'hidepassed');readFlatPreconfigNumber(obj.qunit_config_maxdepth,'maxDepth');readFlatPreconfigString(obj.qunit_config_module,'module');readFlatPreconfigStringArray(obj.qunit_config_moduleid,'moduleId');readFlatPreconfigBoolean(obj.qunit_config_noglobals,'noglobals');readFlatPreconfigBoolean(obj.qunit_config_notrycatch,'notrycatch');readFlatPreconfigBoolean(obj.qunit_config_reorder,'reorder');readFlatPreconfigBoolean(obj.qunit_config_requireexpects,'requireExpects');readFlatPreconfigBoolean(obj.qunit_config_scrolltop,'scrolltop');readFlatPreconfigString(obj.qunit_config_seed,'seed');readFlatPreconfigStringArray(obj.qunit_config_testid,'testId');readFlatPreconfigNumber(obj.qunit_config_testtimeout,'testTimeout');}if(process$1&&'env'in process$1){readFlatPreconfig(process$1.env);}readFlatPreconfig(g);// Apply a predefined QUnit.config object\n//\n// Ignore QUnit.config if it is a QUnit distribution instead of preconfig.\n// That means QUnit was loaded twice! (Use the same approach as export.js)\nvar preConfig=g&&g.QUnit&&!g.QUnit.version&&g.QUnit.config;if(preConfig){extend(config,preConfig);}// Push a loose unnamed module to the modules collection\nconfig.modules.push(config.currentModule);var dump=function(){function quote(str){return'\"'+str.toString().replace(/\\\\/g,'\\\\\\\\').replace(/\"/g,'\\\\\"')+'\"';}function literal(o){return o+'';}function join(pre,arr,post){var s=dump.separator();var inner=dump.indent(1);if(arr.join){arr=arr.join(','+s+inner);}if(!arr){return pre+post;}var base=dump.indent();return[pre,inner+arr,base+post].join(s);}function array(arr,stack){if(dump.maxDepth&&dump.depth>dump.maxDepth){return'[object Array]';}this.up();var i=arr.length;var ret=new Array(i);while(i--){ret[i]=this.parse(arr[i],undefined,stack);}this.down();return join('[',ret,']');}function isArray(obj){return(// Native Arrays\ntoString.call(obj)==='[object Array]'||// NodeList objects\ntypeof obj.length==='number'&&obj.item!==undefined&&(obj.length?obj.item(0)===obj[0]:obj.item(0)===null&&obj[0]===undefined));}var reName=/^function (\\w+)/;var dump={// The objType is used mostly internally, you can fix a (custom) type in advance\nparse:function parse(obj,objType,stack){stack=stack||[];var objIndex=stack.indexOf(obj);if(objIndex!==-1){return\"recursion(\".concat(objIndex-stack.length,\")\");}objType=objType||this.typeOf(obj);var parser=this.parsers[objType];var parserType=_typeof(parser);if(parserType==='function'){stack.push(obj);var res=parser.call(this,obj,stack);stack.pop();return res;}if(parserType==='string'){return parser;}return'[ERROR: Missing QUnit.dump formatter for type '+objType+']';},typeOf:function typeOf(obj){var type;if(obj===null){type='null';}else if(typeof obj==='undefined'){type='undefined';}else if(is('regexp',obj)){type='regexp';}else if(is('date',obj)){type='date';}else if(is('function',obj)){type='function';}else if(obj.setInterval!==undefined&&obj.document!==undefined&&obj.nodeType===undefined){type='window';}else if(obj.nodeType===9){type='document';}else if(obj.nodeType){type='node';}else if(isArray(obj)){type='array';}else if(obj.constructor===Error.prototype.constructor){type='error';}else{type=_typeof(obj);}return type;},separator:function separator(){if(this.multiline){return this.HTML?'<br />':'\\n';}else{return this.HTML?'&#160;':' ';}},// Extra can be a number, shortcut for increasing-calling-decreasing\nindent:function indent(extra){if(!this.multiline){return'';}var chr=this.indentChar;if(this.HTML){chr=chr.replace(/\\t/g,'   ').replace(/ /g,'&#160;');}return new Array(this.depth+(extra||0)).join(chr);},up:function up(a){this.depth+=a||1;},down:function down(a){this.depth-=a||1;},setParser:function setParser(name,parser){this.parsers[name]=parser;},// The next 3 are exposed so you can use them\nquote:quote,literal:literal,join:join,depth:1,maxDepth:config.maxDepth,// This is the list of parsers, to modify them, use dump.setParser\nparsers:{window:'[Window]',document:'[Document]',error:function error(_error){return'Error(\"'+_error.message+'\")';},// This has been unused since QUnit 1.0.0.\n// @todo Deprecate and remove.\nunknown:'[Unknown]',null:'null',undefined:'undefined',function:function _function(fn){var ret='function';// Functions never have name in IE\nvar name='name'in fn?fn.name:(reName.exec(fn)||[])[1];if(name){ret+=' '+name;}ret+='(';ret=[ret,dump.parse(fn,'functionArgs'),'){'].join('');return join(ret,dump.parse(fn,'functionCode'),'}');},array:array,nodelist:array,arguments:array,object:function object(map,stack){var ret=[];if(dump.maxDepth&&dump.depth>dump.maxDepth){return'[object Object]';}dump.up();var keys=[];for(var key in map){keys.push(key);}// Some properties are not always enumerable on Error objects.\nvar nonEnumerableProperties=['message','name'];for(var i in nonEnumerableProperties){var _key=nonEnumerableProperties[i];if(_key in map&&!inArray(_key,keys)){keys.push(_key);}}keys.sort();for(var _i=0;_i<keys.length;_i++){var _key2=keys[_i];var val=map[_key2];ret.push(dump.parse(_key2,'key')+': '+dump.parse(val,undefined,stack));}dump.down();return join('{',ret,'}');},node:function node(_node){var open=dump.HTML?'&lt;':'<';var close=dump.HTML?'&gt;':'>';var tag=_node.nodeName.toLowerCase();var ret=open+tag;var attrs=_node.attributes;if(attrs){for(var i=0;i<attrs.length;i++){var val=attrs[i].nodeValue;// IE6 includes all attributes in .attributes, even ones not explicitly\n// set. Those have values like undefined, null, 0, false, \"\" or\n// \"inherit\".\nif(val&&val!=='inherit'){ret+=' '+attrs[i].nodeName+'='+dump.parse(val,'attribute');}}}ret+=close;// Show content of TextNode or CDATASection\nif(_node.nodeType===3||_node.nodeType===4){ret+=_node.nodeValue;}return ret+open+'/'+tag+close;},// Function calls it internally, it's the arguments part of the function\nfunctionArgs:function functionArgs(fn){var l=fn.length;if(!l){return'';}var args=new Array(l);while(l--){// 97 is 'a'\nargs[l]=String.fromCharCode(97+l);}return' '+args.join(', ')+' ';},// Object calls it internally, the key part of an item in a map\nkey:quote,// Function calls it internally, it's the content of the function\nfunctionCode:'[code]',// Node calls it internally, it's a html attribute value\nattribute:quote,string:quote,date:quote,regexp:literal,number:literal,boolean:literal,symbol:function symbol(sym){return sym.toString();}},// If true, entities are escaped ( <, >, \\t, space and \\n )\nHTML:false,// Indentation unit\nindentChar:'  ',// If true, items in a collection, are separated by a \\n, else just a space.\nmultiline:true};return dump;}();// Support: IE 9\n// Detect if the console object exists and no-op otherwise.\n// This allows support for IE 9, which doesn't have a console\n// object if the developer tools are not open.\n// Support: IE 9\n// Function#bind is supported, but no console.log.bind().\n// Support: SpiderMonkey (mozjs 68+)\n// The console object has a log method, but no warn method.\nvar Logger={warn:console$1?Function.prototype.bind.call(console$1.warn||console$1.log,console$1):function(){}};var SuiteReport=/*#__PURE__*/function(){function SuiteReport(name,parentSuite){_classCallCheck(this,SuiteReport);this.name=name;this.fullName=parentSuite?parentSuite.fullName.concat(name):[];// When an \"error\" event is emitted from onUncaughtException(), the\n// \"runEnd\" event should report the status as failed. The \"runEnd\" event data\n// is tracked through this property (via the \"runSuite\" instance).\nthis.globalFailureCount=0;this.tests=[];this.childSuites=[];if(parentSuite){parentSuite.pushChildSuite(this);}}return _createClass(SuiteReport,[{key:\"start\",value:function start(recordTime){if(recordTime){this._startTime=performance.now();}return{name:this.name,fullName:this.fullName.slice(),tests:this.tests.map(function(test){return test.start();}),childSuites:this.childSuites.map(function(suite){return suite.start();}),testCounts:{total:this.getTestCounts().total}};}},{key:\"end\",value:function end(recordTime){if(recordTime){this._endTime=performance.now();}return{name:this.name,fullName:this.fullName.slice(),tests:this.tests.map(function(test){return test.end();}),childSuites:this.childSuites.map(function(suite){return suite.end();}),testCounts:this.getTestCounts(),runtime:this.getRuntime(),status:this.getStatus()};}},{key:\"pushChildSuite\",value:function pushChildSuite(suite){this.childSuites.push(suite);}},{key:\"pushTest\",value:function pushTest(test){this.tests.push(test);}},{key:\"getRuntime\",value:function getRuntime(){return Math.round(this._endTime-this._startTime);}},{key:\"getTestCounts\",value:function getTestCounts(){var counts=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{passed:0,failed:0,skipped:0,todo:0,total:0};counts.failed+=this.globalFailureCount;counts.total+=this.globalFailureCount;counts=this.tests.reduce(function(counts,test){if(test.valid){counts[test.getStatus()]++;counts.total++;}return counts;},counts);return this.childSuites.reduce(function(counts,suite){return suite.getTestCounts(counts);},counts);}},{key:\"getStatus\",value:function getStatus(){var _this$getTestCounts=this.getTestCounts(),total=_this$getTestCounts.total,failed=_this$getTestCounts.failed,skipped=_this$getTestCounts.skipped,todo=_this$getTestCounts.todo;if(failed){return'failed';}else{if(skipped===total){return'skipped';}else if(todo===total){return'todo';}else{return'passed';}}}}]);}();var moduleStack=[];var runSuite=new SuiteReport();function isParentModuleInQueue(){var modulesInQueue=config.modules.filter(function(module){return!module.ignored;}).map(function(module){return module.moduleId;});return moduleStack.some(function(module){return modulesInQueue.includes(module.moduleId);});}function createModule(name,testEnvironment,modifiers){var parentModule=moduleStack.length?moduleStack.slice(-1)[0]:null;var moduleName=parentModule!==null?[parentModule.name,name].join(' > '):name;var parentSuite=parentModule?parentModule.suiteReport:runSuite;var skip=parentModule!==null&&parentModule.skip||modifiers.skip;var todo=parentModule!==null&&parentModule.todo||modifiers.todo;var env={};if(parentModule){extend(env,parentModule.testEnvironment);}extend(env,testEnvironment);var module={name:moduleName,parentModule:parentModule,hooks:{before:[],beforeEach:[],afterEach:[],after:[]},testEnvironment:env,tests:[],moduleId:generateHash(moduleName),testsRun:0,testsIgnored:0,childModules:[],suiteReport:new SuiteReport(name,parentSuite),// Initialised by test.js when the module start executing,\n// i.e. before the first test in this module (or a child).\nstats:null,// Pass along `skip` and `todo` properties from parent module, in case\n// there is one, to childs. And use own otherwise.\n// This property will be used to mark own tests and tests of child suites\n// as either `skipped` or `todo`.\nskip:skip,todo:skip?false:todo,ignored:modifiers.ignored||false};if(parentModule){parentModule.childModules.push(module);}config.modules.push(module);return module;}function setHookFromEnvironment(hooks,environment,name){var potentialHook=environment[name];if(typeof potentialHook==='function'){hooks[name].push(potentialHook);}delete environment[name];}function makeSetHook(module,hookName){return function setHook(callback){if(config.currentModule!==module){Logger.warn('The `'+hookName+'` hook was called inside the wrong module (`'+config.currentModule.name+'`). '+'Instead, use hooks provided by the callback to the containing module (`'+module.name+'`). '+'This will become an error in QUnit 3.0.');}module.hooks[hookName].push(callback);};}function processModule(name,options,scope){var modifiers=arguments.length>3&&arguments[3]!==undefined?arguments[3]:{};if(typeof options==='function'){scope=options;options=undefined;}var module=createModule(name,options,modifiers);// Transfer any initial hooks from the options object to the 'hooks' object\nvar testEnvironment=module.testEnvironment;var hooks=module.hooks;setHookFromEnvironment(hooks,testEnvironment,'before');setHookFromEnvironment(hooks,testEnvironment,'beforeEach');setHookFromEnvironment(hooks,testEnvironment,'afterEach');setHookFromEnvironment(hooks,testEnvironment,'after');var moduleFns={before:makeSetHook(module,'before'),beforeEach:makeSetHook(module,'beforeEach'),afterEach:makeSetHook(module,'afterEach'),after:makeSetHook(module,'after')};var prevModule=config.currentModule;config.currentModule=module;if(typeof scope==='function'){moduleStack.push(module);try{var cbReturnValue=scope.call(module.testEnvironment,moduleFns);if(cbReturnValue&&typeof cbReturnValue.then==='function'){Logger.warn('Returning a promise from a module callback is not supported. '+'Instead, use hooks for async behavior. '+'This will become an error in QUnit 3.0.');}}finally{// If the module closure threw an uncaught error during the load phase,\n// we let this bubble up to global error handlers. But, not until after\n// we teardown internal state to ensure correct module nesting.\n// Ref https://github.com/qunitjs/qunit/issues/1478.\nmoduleStack.pop();config.currentModule=module.parentModule||prevModule;}}}var focused$1=false;// indicates that the \"only\" filter was used\nfunction module$1(name,options,scope){var ignored=focused$1&&!isParentModuleInQueue();processModule(name,options,scope,{ignored:ignored});}module$1.only=function(){if(!focused$1){// Upon the first module.only() call,\n// delete any and all previously registered modules and tests.\nconfig.modules.length=0;config.queue.length=0;// Ignore any tests declared after this block within the same\n// module parent. https://github.com/qunitjs/qunit/issues/1645\nconfig.currentModule.ignored=true;}focused$1=true;processModule.apply(void 0,arguments);};module$1.skip=function(name,options,scope){if(focused$1){return;}processModule(name,options,scope,{skip:true});};module$1.if=function(name,condition,options,scope){if(focused$1){return;}processModule(name,options,scope,{skip:!condition});};module$1.todo=function(name,options,scope){if(focused$1){return;}processModule(name,options,scope,{todo:true});};// Stacktrace cleaner to focus on the path from error source to test suite.\n//\n// This should reduce a raw stack trace like this:\n//\n// > foo.broken()@/src/foo.js\n// > Bar@/src/bar.js\n// > @/test/bar.test.js\n// > @/lib/qunit.js:500:12\n// > @/lib/qunit.js:100:28\n// > @/lib/qunit.js:200:56\n// > setTimeout@\n// > @/dist/vendor.js\n//\n// and shorten it to show up until the end of the user's bar.test.js code.\n//\n// > foo.broken()@/src/foo.js\n// > Bar@/src/bar.js\n// > @/test/bar.test.js\n//\n// QUnit will obtain one example trace (once per process/pageload suffices),\n// strip off any :<line> and :<line>:<column>, and use that as match needle,\n// to the first QUnit-internal frames, and then stop at that point.\n// Any later frames, including those that are outside QUnit again, will be ommitted\n// as being uninteresting to the test, since QUnit will have either started or\n// resumed the test. This we also clean away browser built-ins, or other\n// vendor/bundler that may be higher up the stack.\n//\n// Stripping :<line>:<column> is not for prettyness, it is essential for the\n// match needle to work, since this sample trace will by definitin not be the\n// same line as e.g. the QUnit.test() call we're trying to identify.\n//\n// See also:\n// - https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error/Stack\n//\nvar fileName=(sourceFromStacktrace(0)||''// Global replace, because a frame like localhost:4000/lib/qunit.js:1234:50,\n// would otherwise (harmlessly, but uselessly) remove only the port (first match).\n// https://github.com/qunitjs/qunit/issues/1769\n).replace(/(:\\d+)+\\)?/g,'')// Remove anything prior to the last slash (Unix/Windows) from the last frame,\n// leaving only \"qunit.js\".\n.replace(/.+[/\\\\]/,'');function extractStacktrace(e,offset){offset=offset===undefined?4:offset;// Support: IE9, e.stack is not supported, we will return undefined\nif(e&&e.stack){var stack=e.stack.split('\\n');if(/^error$/i.test(stack[0])){stack.shift();}if(fileName){var include=[];for(var i=offset;i<stack.length;i++){if(stack[i].indexOf(fileName)!==-1){break;}include.push(stack[i]);}if(include.length){return include.join('\\n');}}return stack[offset];}}function sourceFromStacktrace(offset){var error=new Error();// Support: Safari <=7 only, IE <=10 - 11 only\n// Not all browsers generate the `stack` property for `new Error()`, see also #636\nif(!error.stack){try{throw error;}catch(err){error=err;}}return extractStacktrace(error,offset);}var Assert=/*#__PURE__*/function(){function Assert(testContext){_classCallCheck(this,Assert);this.test=testContext;}return _createClass(Assert,[{key:\"timeout\",value:function timeout(duration){if(typeof duration!=='number'){throw new Error('You must pass a number as the duration to assert.timeout');}this.test.timeout=duration;// If a timeout has been set, clear it and reset with the new duration\nif(config.timeout){clearTimeout(config.timeout);config.timeout=null;if(config.timeoutHandler&&this.test.timeout>0){this.test.internalResetTimeout(this.test.timeout);}}}// Documents a \"step\", which is a string value, in a test as a passing assertion\n},{key:\"step\",value:function step(message){var assertionMessage=message;var result=!!message;this.test.steps.push(message);if(typeof message==='undefined'||message===''){assertionMessage='You must provide a message to assert.step';}else if(typeof message!=='string'){assertionMessage='You must provide a string value to assert.step';result=false;}this.pushResult({result:result,message:assertionMessage});}// Verifies the steps in a test match a given array of string values\n},{key:\"verifySteps\",value:function verifySteps(steps,message){// Since the steps array is just string values, we can clone with slice\nvar actualStepsClone=this.test.steps.slice();this.deepEqual(actualStepsClone,steps,message);this.test.stepsCount+=this.test.steps.length;this.test.steps.length=0;}},{key:\"expect\",value:function expect(asserts){if(arguments.length===1){this.test.expected=asserts;}else{return this.test.expected;}}// Create a new async pause and return a new function that can release the pause.\n},{key:\"async\",value:function async(count){if(count===undefined){count=1;}else if(typeof count!=='number'){throw new TypeError('async takes number as an input');}var requiredCalls=count;return this.test.internalStop(requiredCalls);}},{key:\"closeTo\",value:function closeTo(actual,expected,delta,message){if(typeof delta!=='number'){throw new TypeError('closeTo() requires a delta argument');}this.pushResult({result:Math.abs(actual-expected)<=delta,actual:actual,expected:expected,message:message||\"value should be within \".concat(delta,\" inclusive\")});}// Alias of pushResult.\n},{key:\"push\",value:function push(result,actual,expected,message,negative){var currentAssert=this instanceof Assert?this:config.current.assert;return currentAssert.pushResult({result:result,actual:actual,expected:expected,message:message,negative:negative});}// Public API to internal test.pushResult()\n},{key:\"pushResult\",value:function pushResult(resultInfo){// Destructure of resultInfo = { result, actual, expected, message, negative }\nvar assert=this;var currentTest=assert instanceof Assert&&assert.test||config.current;// Backwards compatibility fix.\n// Allows the direct use of global exported assertions and QUnit.assert.*\n// Although, it's use is not recommended as it can leak assertions\n// to other tests from async tests, because we only get a reference to the current test,\n// not exactly the test where assertion were intended to be called.\nif(!currentTest){throw new Error('assertion outside test context, in '+sourceFromStacktrace(2));}if(!(assert instanceof Assert)){assert=currentTest.assert;}return assert.test.pushResult(resultInfo);}},{key:\"ok\",value:function ok(result,message){if(!message){message=result?'okay':\"failed, expected argument to be truthy, was: \".concat(dump.parse(result));}this.pushResult({result:!!result,actual:result,expected:true,message:message});}},{key:\"notOk\",value:function notOk(result,message){if(!message){message=!result?'okay':\"failed, expected argument to be falsy, was: \".concat(dump.parse(result));}this.pushResult({result:!result,actual:result,expected:false,message:message});}},{key:\"true\",value:function _true(result,message){this.pushResult({result:result===true,actual:result,expected:true,message:message});}},{key:\"false\",value:function _false(result,message){this.pushResult({result:result===false,actual:result,expected:false,message:message});}},{key:\"equal\",value:function equal(actual,expected,message){this.pushResult({// eslint-disable-next-line eqeqeq\nresult:expected==actual,actual:actual,expected:expected,message:message});}},{key:\"notEqual\",value:function notEqual(actual,expected,message){this.pushResult({// eslint-disable-next-line eqeqeq\nresult:expected!=actual,actual:actual,expected:expected,message:message,negative:true});}},{key:\"propEqual\",value:function propEqual(actual,expected,message){actual=objectValues(actual);expected=objectValues(expected);this.pushResult({result:equiv(actual,expected),actual:actual,expected:expected,message:message});}},{key:\"notPropEqual\",value:function notPropEqual(actual,expected,message){actual=objectValues(actual);expected=objectValues(expected);this.pushResult({result:!equiv(actual,expected),actual:actual,expected:expected,message:message,negative:true});}},{key:\"propContains\",value:function propContains(actual,expected,message){actual=objectValuesSubset(actual,expected);// The expected parameter is usually a plain object, but clone it for\n// consistency with propEqual(), and to make it easy to explain that\n// inheritence is not considered (on either side), and to support\n// recursively checking subsets of nested objects.\nexpected=objectValues(expected,false);this.pushResult({result:equiv(actual,expected),actual:actual,expected:expected,message:message});}},{key:\"notPropContains\",value:function notPropContains(actual,expected,message){actual=objectValuesSubset(actual,expected);expected=objectValues(expected);this.pushResult({result:!equiv(actual,expected),actual:actual,expected:expected,message:message,negative:true});}},{key:\"deepEqual\",value:function deepEqual(actual,expected,message){this.pushResult({result:equiv(actual,expected),actual:actual,expected:expected,message:message});}},{key:\"notDeepEqual\",value:function notDeepEqual(actual,expected,message){this.pushResult({result:!equiv(actual,expected),actual:actual,expected:expected,message:message,negative:true});}},{key:\"strictEqual\",value:function strictEqual(actual,expected,message){this.pushResult({result:expected===actual,actual:actual,expected:expected,message:message});}},{key:\"notStrictEqual\",value:function notStrictEqual(actual,expected,message){this.pushResult({result:expected!==actual,actual:actual,expected:expected,message:message,negative:true});}},{key:'throws',value:function throws(block,expected,message){var _validateExpectedExce=validateExpectedExceptionArgs(expected,message,'throws');var _validateExpectedExce2=_slicedToArray(_validateExpectedExce,2);expected=_validateExpectedExce2[0];message=_validateExpectedExce2[1];var currentTest=this instanceof Assert&&this.test||config.current;if(typeof block!=='function'){currentTest.assert.pushResult({result:false,actual:block,message:'The value provided to `assert.throws` in '+'\"'+currentTest.testName+'\" was not a function.'});return;}var actual;var result=false;currentTest.ignoreGlobalErrors=true;try{block.call(currentTest.testEnvironment);}catch(e){actual=e;}currentTest.ignoreGlobalErrors=false;if(actual){var _validateException=validateException(actual,expected,message);var _validateException2=_slicedToArray(_validateException,3);result=_validateException2[0];expected=_validateException2[1];message=_validateException2[2];}currentTest.assert.pushResult({result:result,// undefined if it didn't throw\nactual:actual&&errorString(actual),expected:expected,message:message});}},{key:\"rejects\",value:function rejects(promise,expected,message){var _validateExpectedExce3=validateExpectedExceptionArgs(expected,message,'rejects');var _validateExpectedExce4=_slicedToArray(_validateExpectedExce3,2);expected=_validateExpectedExce4[0];message=_validateExpectedExce4[1];var currentTest=this instanceof Assert&&this.test||config.current;var then=promise&&promise.then;if(typeof then!=='function'){currentTest.assert.pushResult({result:false,message:'The value provided to `assert.rejects` in '+'\"'+currentTest.testName+'\" was not a promise.',actual:promise});return;}var done=this.async();return then.call(promise,function handleFulfillment(){currentTest.assert.pushResult({result:false,message:'The promise returned by the `assert.rejects` callback in '+'\"'+currentTest.testName+'\" did not reject.',actual:promise});done();},function handleRejection(actual){var result;var _validateException3=validateException(actual,expected,message);var _validateException4=_slicedToArray(_validateException3,3);result=_validateException4[0];expected=_validateException4[1];message=_validateException4[2];currentTest.assert.pushResult({result:result,// leave rejection value of undefined as-is\nactual:actual&&errorString(actual),expected:expected,message:message});done();});}}]);}();function validateExpectedExceptionArgs(expected,message,assertionMethod){var expectedType=objectType(expected);// 'expected' is optional unless doing string comparison\nif(expectedType==='string'){if(message===undefined){message=expected;expected=undefined;return[expected,message];}else{throw new Error('assert.'+assertionMethod+' does not accept a string value for the expected argument.\\n'+'Use a non-string object value (e.g. RegExp or validator function) '+'instead if necessary.');}}var valid=!expected||// TODO: be more explicit here\nexpectedType==='regexp'||expectedType==='function'||expectedType==='object';if(!valid){throw new Error('Invalid expected value type ('+expectedType+') '+'provided to assert.'+assertionMethod+'.');}return[expected,message];}function validateException(actual,expected,message){var result=false;var expectedType=objectType(expected);// These branches should be exhaustive, based on validation done in validateExpectedException\n// We don't want to validate\nif(!expected){result=true;// Expected is a regexp\n}else if(expectedType==='regexp'){result=expected.test(errorString(actual));// Log the string form of the regexp\nexpected=String(expected);// Expected is a constructor, maybe an Error constructor.\n// Note the extra check on its prototype - this is an implicit\n// requirement of \"instanceof\", else it will throw a TypeError.\n}else if(expectedType==='function'&&expected.prototype!==undefined&&actual instanceof expected){result=true;// Expected is an Error object\n}else if(expectedType==='object'){result=actual instanceof expected.constructor&&actual.name===expected.name&&actual.message===expected.message;// Log the string form of the Error object\nexpected=errorString(expected);// Expected is a validation function which returns true if validation passed\n}else if(expectedType==='function'){// protect against accidental semantics which could hard error in the test\ntry{result=expected.call({},actual)===true;expected=null;}catch(e){// assign the \"expected\" to a nice error string to communicate the local failure to the user\nexpected=errorString(e);}}return[result,expected,message];}// Provide an alternative to assert.throws(), for environments that consider throws a reserved word\n// Known to us are: Closure Compiler, Narwhal\n// eslint-disable-next-line dot-notation\nAssert.prototype.raises=Assert.prototype['throws'];var LISTENERS=Object.create(null);var SUPPORTED_EVENTS=['error','runStart','suiteStart','testStart','assertion','testEnd','suiteEnd','runEnd'];/**\n   * Emits an event with the specified data to all currently registered listeners.\n   * Callbacks will fire in the order in which they are registered (FIFO). This\n   * function is not exposed publicly; it is used by QUnit internals to emit\n   * logging events.\n   *\n   * @private\n   * @method emit\n   * @param {string} eventName\n   * @param {Object} data\n   * @return {void}\n   */function emit(eventName,data){if(typeof eventName!=='string'){throw new TypeError('eventName must be a string when emitting an event');}// Clone the callbacks in case one of them registers a new callback\nvar originalCallbacks=LISTENERS[eventName];var callbacks=originalCallbacks?_toConsumableArray(originalCallbacks):[];for(var i=0;i<callbacks.length;i++){callbacks[i](data);}}/**\n   * Registers a callback as a listener to the specified event.\n   *\n   * @public\n   * @method on\n   * @param {string} eventName\n   * @param {Function} callback\n   * @return {void}\n   */function on(eventName,callback){if(typeof eventName!=='string'){throw new TypeError('eventName must be a string when registering a listener');}else if(!inArray(eventName,SUPPORTED_EVENTS)){var events=SUPPORTED_EVENTS.join(', ');throw new Error(\"\\\"\".concat(eventName,\"\\\" is not a valid event; must be one of: \").concat(events,\".\"));}else if(typeof callback!=='function'){throw new TypeError('callback must be a function when registering a listener');}if(!LISTENERS[eventName]){LISTENERS[eventName]=[];}// Don't register the same callback more than once\nif(!inArray(callback,LISTENERS[eventName])){LISTENERS[eventName].push(callback);}}var commonjsGlobal=typeof globalThis!=='undefined'?globalThis:typeof window!=='undefined'?window:typeof global!=='undefined'?global:typeof self!=='undefined'?self:{};function commonjsRequire(path){throw new Error('Could not dynamically require \"'+path+'\". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');}var promisePolyfill={exports:{}};(function(){/** @suppress {undefinedVars} */var globalNS=function(){// the only reliable means to get the global object is\n// `Function('return this')()`\n// However, this causes CSP violations in Chrome apps.\nif(typeof globalThis!=='undefined'){return globalThis;}if(typeof self!=='undefined'){return self;}if(typeof window!=='undefined'){return window;}if(typeof commonjsGlobal!=='undefined'){return commonjsGlobal;}throw new Error('unable to locate global object');}();// Expose the polyfill if Promise is undefined or set to a\n// non-function value. The latter can be due to a named HTMLElement\n// being exposed by browsers for legacy reasons.\n// https://github.com/taylorhakes/promise-polyfill/issues/114\nif(typeof globalNS['Promise']==='function'){promisePolyfill.exports=globalNS['Promise'];return;}/**\n     * @this {Promise}\n     */function finallyConstructor(callback){var constructor=this.constructor;return this.then(function(value){// @ts-ignore\nreturn constructor.resolve(callback()).then(function(){return value;});},function(reason){// @ts-ignore\nreturn constructor.resolve(callback()).then(function(){// @ts-ignore\nreturn constructor.reject(reason);});});}function allSettled(arr){var P=this;return new P(function(resolve,reject){if(!(arr&&typeof arr.length!=='undefined')){return reject(new TypeError(_typeof(arr)+' '+arr+' is not iterable(cannot read property Symbol(Symbol.iterator))'));}var args=Array.prototype.slice.call(arr);if(args.length===0)return resolve([]);var remaining=args.length;function res(i,val){if(val&&(_typeof(val)==='object'||typeof val==='function')){var then=val.then;if(typeof then==='function'){then.call(val,function(val){res(i,val);},function(e){args[i]={status:'rejected',reason:e};if(--remaining===0){resolve(args);}});return;}}args[i]={status:'fulfilled',value:val};if(--remaining===0){resolve(args);}}for(var i=0;i<args.length;i++){res(i,args[i]);}});}// Store setTimeout reference so promise-polyfill will be unaffected by\n// other code modifying setTimeout (like sinon.useFakeTimers())\nvar setTimeoutFunc=setTimeout;function isArray(x){return Boolean(x&&typeof x.length!=='undefined');}function noop(){}// Polyfill for Function.prototype.bind\nfunction bind(fn,thisArg){return function(){fn.apply(thisArg,arguments);};}/**\n     * @constructor\n     * @param {Function} fn\n     */function Promise(fn){if(!(this instanceof Promise))throw new TypeError('Promises must be constructed via new');if(typeof fn!=='function')throw new TypeError('not a function');/** @type {!number} */this._state=0;/** @type {!boolean} */this._handled=false;/** @type {Promise|undefined} */this._value=undefined;/** @type {!Array<!Function>} */this._deferreds=[];doResolve(fn,this);}function handle(self,deferred){while(self._state===3){self=self._value;}if(self._state===0){self._deferreds.push(deferred);return;}self._handled=true;Promise._immediateFn(function(){var cb=self._state===1?deferred.onFulfilled:deferred.onRejected;if(cb===null){(self._state===1?resolve:reject)(deferred.promise,self._value);return;}var ret;try{ret=cb(self._value);}catch(e){reject(deferred.promise,e);return;}resolve(deferred.promise,ret);});}function resolve(self,newValue){try{// Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\nif(newValue===self)throw new TypeError('A promise cannot be resolved with itself.');if(newValue&&(_typeof(newValue)==='object'||typeof newValue==='function')){var then=newValue.then;if(newValue instanceof Promise){self._state=3;self._value=newValue;finale(self);return;}else if(typeof then==='function'){doResolve(bind(then,newValue),self);return;}}self._state=1;self._value=newValue;finale(self);}catch(e){reject(self,e);}}function reject(self,newValue){self._state=2;self._value=newValue;finale(self);}function finale(self){if(self._state===2&&self._deferreds.length===0){Promise._immediateFn(function(){if(!self._handled){Promise._unhandledRejectionFn(self._value);}});}for(var i=0,len=self._deferreds.length;i<len;i++){handle(self,self._deferreds[i]);}self._deferreds=null;}/**\n     * @constructor\n     */function Handler(onFulfilled,onRejected,promise){this.onFulfilled=typeof onFulfilled==='function'?onFulfilled:null;this.onRejected=typeof onRejected==='function'?onRejected:null;this.promise=promise;}/**\n     * Take a potentially misbehaving resolver function and make sure\n     * onFulfilled and onRejected are only called once.\n     *\n     * Makes no guarantees about asynchrony.\n     */function doResolve(fn,self){var done=false;try{fn(function(value){if(done)return;done=true;resolve(self,value);},function(reason){if(done)return;done=true;reject(self,reason);});}catch(ex){if(done)return;done=true;reject(self,ex);}}Promise.prototype['catch']=function(onRejected){return this.then(null,onRejected);};Promise.prototype.then=function(onFulfilled,onRejected){// @ts-ignore\nvar prom=new this.constructor(noop);handle(this,new Handler(onFulfilled,onRejected,prom));return prom;};Promise.prototype['finally']=finallyConstructor;Promise.all=function(arr){return new Promise(function(resolve,reject){if(!isArray(arr)){return reject(new TypeError('Promise.all accepts an array'));}var args=Array.prototype.slice.call(arr);if(args.length===0)return resolve([]);var remaining=args.length;function res(i,val){try{if(val&&(_typeof(val)==='object'||typeof val==='function')){var then=val.then;if(typeof then==='function'){then.call(val,function(val){res(i,val);},reject);return;}}args[i]=val;if(--remaining===0){resolve(args);}}catch(ex){reject(ex);}}for(var i=0;i<args.length;i++){res(i,args[i]);}});};Promise.allSettled=allSettled;Promise.resolve=function(value){if(value&&_typeof(value)==='object'&&value.constructor===Promise){return value;}return new Promise(function(resolve){resolve(value);});};Promise.reject=function(value){return new Promise(function(resolve,reject){reject(value);});};Promise.race=function(arr){return new Promise(function(resolve,reject){if(!isArray(arr)){return reject(new TypeError('Promise.race accepts an array'));}for(var i=0,len=arr.length;i<len;i++){Promise.resolve(arr[i]).then(resolve,reject);}});};// Use polyfill for setImmediate for performance gains\n// @ts-ignore\nif(typeof setImmediate==='function'){// @ts-ignore\nvar setImmediateFunc=setImmediate;Promise._immediateFn=function(fn){setImmediateFunc(fn);};}else{Promise._immediateFn=function(fn){setTimeoutFunc(fn,0);};}Promise._unhandledRejectionFn=function _unhandledRejectionFn(err){if(typeof console!=='undefined'&&console){console.warn('Possible Unhandled Promise Rejection:',err);// eslint-disable-line no-console\n}};promisePolyfill.exports=Promise;})();var _Promise=promisePolyfill.exports;// Register logging callbacks\nfunction registerLoggingCallbacks(obj){var callbackNames=['begin','done','log','testStart','testDone','moduleStart','moduleDone'];function registerLoggingCallback(key){return function loggingCallback(callback){if(typeof callback!=='function'){throw new Error('Callback parameter must be a function');}config.callbacks[key].push(callback);};}for(var i=0;i<callbackNames.length;i++){var key=callbackNames[i];// Initialize key collection of logging callback\nif(typeof config.callbacks[key]==='undefined'){config.callbacks[key]=[];}obj[key]=registerLoggingCallback(key);}}function runLoggingCallbacks(key,args){var callbacks=config.callbacks[key];// Handling 'log' callbacks separately. Unlike the other callbacks,\n// the log callback is not controlled by the processing queue,\n// but rather used by asserts. Hence to promisfy the 'log' callback\n// would mean promisfying each step of a test\nif(key==='log'){callbacks.map(function(callback){return callback(args);});return;}// ensure that each callback is executed serially\nvar promiseChain=_Promise.resolve();callbacks.forEach(function(callback){promiseChain=promiseChain.then(function(){return _Promise.resolve(callback(args));});});return promiseChain;}var TestReport=/*#__PURE__*/function(){function TestReport(name,suite,options){_classCallCheck(this,TestReport);this.name=name;this.suiteName=suite.name;this.fullName=suite.fullName.concat(name);this.runtime=0;this.assertions=[];this.skipped=!!options.skip;this.todo=!!options.todo;this.valid=options.valid;this._startTime=0;this._endTime=0;suite.pushTest(this);}return _createClass(TestReport,[{key:\"start\",value:function start(recordTime){if(recordTime){this._startTime=performance.now();}return{name:this.name,suiteName:this.suiteName,fullName:this.fullName.slice()};}},{key:\"end\",value:function end(recordTime){if(recordTime){this._endTime=performance.now();}return extend(this.start(),{runtime:this.getRuntime(),status:this.getStatus(),errors:this.getFailedAssertions(),assertions:this.getAssertions()});}},{key:\"pushAssertion\",value:function pushAssertion(assertion){this.assertions.push(assertion);}},{key:\"getRuntime\",value:function getRuntime(){return Math.round(this._endTime-this._startTime);}},{key:\"getStatus\",value:function getStatus(){if(this.skipped){return'skipped';}var testPassed=this.getFailedAssertions().length>0?this.todo:!this.todo;if(!testPassed){return'failed';}else if(this.todo){return'todo';}else{return'passed';}}},{key:\"getFailedAssertions\",value:function getFailedAssertions(){return this.assertions.filter(function(assertion){return!assertion.passed;});}},{key:\"getAssertions\",value:function getAssertions(){return this.assertions.slice();}// Remove actual and expected values from assertions. This is to prevent\n// leaking memory throughout a test suite.\n},{key:\"slimAssertions\",value:function slimAssertions(){this.assertions=this.assertions.map(function(assertion){delete assertion.actual;delete assertion.expected;return assertion;});}}]);}();function Test(settings){this.expected=null;this.assertions=[];this.module=config.currentModule;this.steps=[];// This powers the QUnit.config.countStepsAsOne feature.\n// https://github.com/qunitjs/qunit/pull/1775\nthis.stepsCount=0;this.timeout=undefined;this.data=undefined;this.withData=false;this.pauses=new StringMap();this.nextPauseId=1;// For the most common case, we have:\n// - 0: new Test\n// - 1: addTest\n// - 2: QUnit.test\n// - 3: user file\n//\n// This needs is customised by test.each()\nthis.stackOffset=3;extend(this,settings);// If a module is skipped, all its tests and the tests of the child suites\n// should be treated as skipped even if they are defined as `only` or `todo`.\n// As for `todo` module, all its tests will be treated as `todo` except for\n// tests defined as `skip` which will be left intact.\n//\n// So, if a test is defined as `todo` and is inside a skipped module, we should\n// then treat that test as if was defined as `skip`.\nif(this.module.skip){this.skip=true;this.todo=false;// Skipped tests should be left intact\n}else if(this.module.todo&&!this.skip){this.todo=true;}// Queuing a late test after the run has ended is not allowed.\n// This was once supported for internal use by QUnit.onError().\n// Ref https://github.com/qunitjs/qunit/issues/1377\nif(config.pq.finished){// Using this for anything other than onError(), such as testing in QUnit.done(),\n// is unstable and will likely result in the added tests being ignored by CI.\n// (Meaning the CI passes irregardless of the added tests).\n//\n// TODO: Make this an error in QUnit 3.0\n// throw new Error( \"Unexpected test after runEnd\" );\nLogger.warn('Unexpected test after runEnd. This is unstable and will fail in QUnit 3.0.');return;}if(!this.skip&&typeof this.callback!=='function'){var method=this.todo?'QUnit.todo':'QUnit.test';throw new TypeError(\"You must provide a callback to \".concat(method,\"(\\\"\").concat(this.testName,\"\\\")\"));}// Register unique strings\nfor(var i=0,l=this.module.tests;i<l.length;i++){if(this.module.tests[i].name===this.testName){this.testName+=' ';}}this.testId=generateHash(this.module.name,this.testName);// No validation after this. Beyond this point, failures must be recorded as\n// a completed test with errors, instead of early bail out.\n// Otherwise, internals may be left in an inconsistent state.\n// Ref https://github.com/qunitjs/qunit/issues/1514\n++Test.count;this.errorForStack=new Error();if(this.callback&&this.callback.validTest){// Omit the test-level trace for the internal \"No tests\" test failure,\n// There is already an assertion-level trace, and that's noisy enough\n// as it is.\nthis.errorForStack.stack=undefined;}this.testReport=new TestReport(this.testName,this.module.suiteReport,{todo:this.todo,skip:this.skip,valid:this.valid()});this.module.tests.push({name:this.testName,testId:this.testId,skip:!!this.skip});if(this.skip){// Skipped tests will fully ignore (and dereference for garbage collect) any sent callback\nthis.callback=function(){};this.async=false;this.expected=0;}else{this.assert=new Assert(this);}}Test.count=0;function getNotStartedModules(startModule){var module=startModule;var modules=[];while(module&&module.testsRun===0){modules.push(module);module=module.parentModule;}// The above push modules from the child to the parent\n// return a reversed order with the top being the top most parent module\nreturn modules.reverse();}Test.prototype={// Use a getter to avoid computing a stack trace (which can be expensive),\n// This is displayed by the HTML Reporter, but most other integrations do\n// not access it.\nget stack(){return extractStacktrace(this.errorForStack,this.stackOffset);},before:function before(){var _this=this;var module=this.module;var notStartedModules=getNotStartedModules(module);// ensure the callbacks are executed serially for each module\nvar moduleStartChain=_Promise.resolve();notStartedModules.forEach(function(startModule){moduleStartChain=moduleStartChain.then(function(){startModule.stats={all:0,bad:0,started:performance.now()};emit('suiteStart',startModule.suiteReport.start(true));return runLoggingCallbacks('moduleStart',{name:startModule.name,tests:startModule.tests});});});return moduleStartChain.then(function(){config.current=_this;_this.testEnvironment=extend({},module.testEnvironment);_this.started=performance.now();emit('testStart',_this.testReport.start(true));return runLoggingCallbacks('testStart',{name:_this.testName,module:module.name,testId:_this.testId,previousFailure:_this.previousFailure}).then(function(){if(!config.pollution){saveGlobal();}});});},run:function run(){config.current=this;if(config.notrycatch){runTest(this);return;}try{runTest(this);}catch(e){this.pushFailure('Died on test #'+(this.assertions.length+1)+': '+(e.message||e)+'\\n'+this.stack,extractStacktrace(e,0));// Else next test will carry the responsibility\nsaveGlobal();// Restart the tests if they're blocking\nif(config.blocking){internalRecover(this);}}function runTest(test){var promise;if(test.withData){promise=test.callback.call(test.testEnvironment,test.assert,test.data);}else{promise=test.callback.call(test.testEnvironment,test.assert);}test.resolvePromise(promise);// If the test has an async \"pause\" on it, but the timeout is 0, then we push a\n// failure as the test should be synchronous.\nif(test.timeout===0&&test.pauses.size>0){pushFailure('Test did not finish synchronously even though assert.timeout( 0 ) was used.',sourceFromStacktrace(2));}}},after:function after(){checkPollution();},queueGlobalHook:function queueGlobalHook(hook,hookName){var _this2=this;var runHook=function runHook(){config.current=_this2;var promise;if(config.notrycatch){promise=hook.call(_this2.testEnvironment,_this2.assert);}else{try{promise=hook.call(_this2.testEnvironment,_this2.assert);}catch(error){_this2.pushFailure('Global '+hookName+' failed on '+_this2.testName+': '+errorString(error),extractStacktrace(error,0));return;}}_this2.resolvePromise(promise,hookName);};return runHook;},queueHook:function queueHook(hook,hookName,hookOwner){var _this3=this;var callHook=function callHook(){var promise=hook.call(_this3.testEnvironment,_this3.assert);_this3.resolvePromise(promise,hookName);};var runHook=function runHook(){if(hookName==='before'){if(hookOwner.testsRun!==0){return;}_this3.preserveEnvironment=true;}// The 'after' hook should only execute when there are not tests left and\n// when the 'after' and 'finish' tasks are the only tasks left to process\nif(hookName==='after'&&!lastTestWithinModuleExecuted(hookOwner)&&(config.queue.length>0||config.pq.taskCount()>2)){return;}config.current=_this3;if(config.notrycatch){callHook();return;}try{// This try-block includes the indirect call to resolvePromise, which shouldn't\n// have to be inside try-catch. But, since we support any user-provided thenable\n// object, the thenable might throw in some unexpected way.\n// This subtle behaviour is undocumented. To avoid new failures in minor releases\n// we will not change this until QUnit 3.\n// TODO: In QUnit 3, reduce this try-block to just hook.call(), matching\n// the simplicity of queueGlobalHook.\ncallHook();}catch(error){_this3.pushFailure(hookName+' failed on '+_this3.testName+': '+(error.message||error),extractStacktrace(error,0));}};return runHook;},// Currently only used for module level hooks, can be used to add global level ones\nhooks:function hooks(handler){var hooks=[];function processGlobalhooks(test){if((handler==='beforeEach'||handler==='afterEach')&&config.globalHooks[handler]){for(var i=0;i<config.globalHooks[handler].length;i++){hooks.push(test.queueGlobalHook(config.globalHooks[handler][i],handler));}}}function processHooks(test,module){if(module.parentModule){processHooks(test,module.parentModule);}if(module.hooks[handler].length){for(var i=0;i<module.hooks[handler].length;i++){hooks.push(test.queueHook(module.hooks[handler][i],handler,module));}}}// Hooks are ignored on skipped tests\nif(!this.skip){processGlobalhooks(this);processHooks(this,this.module);}return hooks;},finish:function finish(){config.current=this;// Release the timeout and timeout callback references to be garbage collected.\n// https://github.com/qunitjs/qunit/pull/1708\nif(setTimeout$1){clearTimeout(this.timeout);config.timeoutHandler=null;}// Release the test callback to ensure that anything referenced has been\n// released to be garbage collected.\nthis.callback=undefined;if(this.steps.length){var stepsList=this.steps.join(', ');this.pushFailure('Expected assert.verifySteps() to be called before end of test '+\"after using assert.step(). Unverified steps: \".concat(stepsList),this.stack);}if(!config._deprecated_countEachStep_shown&&!config.countStepsAsOne&&this.expected!==null&&this.stepsCount){config._deprecated_countEachStep_shown=true;if(config.requireExpects){Logger.warn('Counting each assert.step() for assert.expect() is changing in QUnit 3.0. You can enable QUnit.config.countStepsAsOne to prepare for the upgrade. https://qunitjs.com/api/assert/expect/');}else{Logger.warn('Counting each assert.step() for assert.expect() is changing in QUnit 3.0. Omit assert.expect() from tests that use assert.step(), or enable QUnit.config.countStepsAsOne to prepare for the upgrade. https://qunitjs.com/api/assert/expect/');}}var actualCountForExpect=config.countStepsAsOne?this.assertions.length-this.stepsCount:this.assertions.length;if(config.requireExpects&&this.expected===null){this.pushFailure('Expected number of assertions to be defined, but expect() was '+'not called.',this.stack);}else if(this.expected!==null&&this.expected!==actualCountForExpect&&this.stepsCount&&this.expected===this.assertions.length-this.stepsCount&&!config.countStepsAsOne){this.pushFailure('Expected '+this.expected+' assertions, but '+actualCountForExpect+' were run\\nIt looks like you might prefer to enable QUnit.config.countStepsAsOne, which will become the default in QUnit 3.0. https://qunitjs.com/api/assert/expect/',this.stack);}else if(this.expected!==null&&this.expected!==actualCountForExpect&&this.stepsCount&&this.expected===this.assertions.length&&config.countStepsAsOne){this.pushFailure('Expected '+this.expected+' assertions, but '+actualCountForExpect+' were run\\nRemember that with QUnit.config.countStepsAsOne and in QUnit 3.0, steps no longer count as separate assertions. https://qunitjs.com/api/assert/expect/',this.stack);}else if(this.expected!==null&&this.expected!==actualCountForExpect){this.pushFailure('Expected '+this.expected+' assertions, but '+actualCountForExpect+' were run',this.stack);}else if(this.expected===null&&!actualCountForExpect){this.pushFailure('Expected at least one assertion, but none were run - call '+'expect(0) to accept zero assertions.',this.stack);}var module=this.module;var moduleName=module.name;var testName=this.testName;var skipped=!!this.skip;var todo=!!this.todo;var bad=0;var storage=config.storage;this.runtime=Math.round(performance.now()-this.started);config.stats.all+=this.assertions.length;config.stats.testCount+=1;module.stats.all+=this.assertions.length;for(var i=0;i<this.assertions.length;i++){// A failing assertion will counts toward the HTML Reporter's\n// \"X assertions, Y failed\" line even if it was inside a todo.\n// Inverting this would be similarly confusing since all but the last\n// passing assertion inside a todo test should be considered as good.\n// These stats don't decide the outcome of anything, so counting them\n// as failing seems the most intuitive.\nif(!this.assertions[i].result){bad++;config.stats.bad++;module.stats.bad++;}}if(skipped){incrementTestsIgnored(module);}else{incrementTestsRun(module);}// Store result when possible.\n// Note that this also marks todo tests as bad, thus they get hoisted,\n// and always run first on refresh.\nif(storage){if(bad){storage.setItem('qunit-test-'+moduleName+'-'+testName,bad);}else{storage.removeItem('qunit-test-'+moduleName+'-'+testName);}}// After emitting the js-reporters event we cleanup the assertion data to\n// avoid leaking it. It is not used by the legacy testDone callbacks.\nemit('testEnd',this.testReport.end(true));this.testReport.slimAssertions();var test=this;return runLoggingCallbacks('testDone',{name:testName,module:moduleName,skipped:skipped,todo:todo,failed:bad,passed:this.assertions.length-bad,total:this.assertions.length,runtime:skipped?0:this.runtime,// HTML Reporter use\nassertions:this.assertions,testId:this.testId,// Source of Test\n// generating stack trace is expensive, so using a getter will help defer this until we need it\nget source(){return test.stack;}}).then(function(){if(allTestsExecuted(module)){var completedModules=[module];// Check if the parent modules, iteratively, are done. If that the case,\n// we emit the `suiteEnd` event and trigger `moduleDone` callback.\nvar parent=module.parentModule;while(parent&&allTestsExecuted(parent)){completedModules.push(parent);parent=parent.parentModule;}var moduleDoneChain=_Promise.resolve();completedModules.forEach(function(completedModule){moduleDoneChain=moduleDoneChain.then(function(){return logSuiteEnd(completedModule);});});return moduleDoneChain;}}).then(function(){config.current=undefined;});function logSuiteEnd(module){// Reset `module.hooks` to ensure that anything referenced in these hooks\n// has been released to be garbage collected. Descendant modules that were\n// entirely skipped, e.g. due to filtering, will never have this method\n// called for them, but might have hooks with references pinning data in\n// memory (even if the hooks weren't actually executed), so we reset the\n// hooks on all descendant modules here as well. This is safe because we\n// will never call this as long as any descendant modules still have tests\n// to run. This also means that in multi-tiered nesting scenarios we might\n// reset the hooks multiple times on some modules, but that's harmless.\nvar modules=[module];while(modules.length){var nextModule=modules.shift();nextModule.hooks={};modules.push.apply(modules,_toConsumableArray(nextModule.childModules));}emit('suiteEnd',module.suiteReport.end(true));return runLoggingCallbacks('moduleDone',{name:module.name,tests:module.tests,failed:module.stats.bad,passed:module.stats.all-module.stats.bad,total:module.stats.all,runtime:Math.round(performance.now()-module.stats.started)});}},preserveTestEnvironment:function preserveTestEnvironment(){if(this.preserveEnvironment){this.module.testEnvironment=this.testEnvironment;this.testEnvironment=extend({},this.module.testEnvironment);}},queue:function queue(){var test=this;if(!this.valid()){incrementTestsIgnored(this.module);return;}function runTest(){return[function(){return test.before();}].concat(_toConsumableArray(test.hooks('before')),[function(){test.preserveTestEnvironment();}],_toConsumableArray(test.hooks('beforeEach')),[function(){test.run();}],_toConsumableArray(test.hooks('afterEach').reverse()),_toConsumableArray(test.hooks('after').reverse()),[function(){test.after();},function(){return test.finish();}]);}var previousFailCount=config.storage&&+config.storage.getItem('qunit-test-'+this.module.name+'-'+this.testName);// Prioritize previously failed tests, detected from storage\nvar prioritize=config.reorder&&!!previousFailCount;this.previousFailure=!!previousFailCount;config.pq.add(runTest,prioritize);},pushResult:function pushResult(resultInfo){if(this!==config.current){var message=resultInfo&&resultInfo.message||'';var testName=this&&this.testName||'';var error='Assertion occurred after test finished.\\n'+'> Test: '+testName+'\\n'+'> Message: '+message+'\\n';throw new Error(error);}// Destructure of resultInfo = { result, actual, expected, message, negative }\nvar details={module:this.module.name,name:this.testName,result:resultInfo.result,message:resultInfo.message,actual:resultInfo.actual,testId:this.testId,negative:resultInfo.negative||false,runtime:Math.round(performance.now()-this.started),todo:!!this.todo};if(hasOwn$2.call(resultInfo,'expected')){details.expected=resultInfo.expected;}if(!resultInfo.result){var source=resultInfo.source||sourceFromStacktrace();if(source){details.source=source;}}this.logAssertion(details);this.assertions.push({result:!!resultInfo.result,message:resultInfo.message});},pushFailure:function pushFailure(message,source,actual){if(!(this instanceof Test)){throw new Error('pushFailure() assertion outside test context, was '+sourceFromStacktrace(2));}this.pushResult({result:false,message:message||'error',actual:actual||null,source:source});},/**\n     * Log assertion details using both the old QUnit.log interface and\n     * QUnit.on( \"assertion\" ) interface.\n     *\n     * @private\n     */logAssertion:function logAssertion(details){runLoggingCallbacks('log',details);var assertion={passed:details.result,actual:details.actual,expected:details.expected,message:details.message,stack:details.source,todo:details.todo};this.testReport.pushAssertion(assertion);emit('assertion',assertion);},/**\n     * Reset config.timeout with a new timeout duration.\n     *\n     * @param {number} timeoutDuration\n     */internalResetTimeout:function internalResetTimeout(timeoutDuration){clearTimeout(config.timeout);config.timeout=setTimeout$1(config.timeoutHandler(timeoutDuration),timeoutDuration);},/**\n     * Create a new async pause and return a new function that can release the pause.\n     *\n     * This mechanism is internally used by:\n     *\n     * - explicit async pauses, created by calling `assert.async()`,\n     * - implicit async pauses, created when `QUnit.test()` or module hook callbacks\n     *   use async-await or otherwise return a Promise.\n     *\n     * Happy scenario:\n     *\n     * - Pause is created by calling internalStop().\n     *\n     *   Pause is released normally by invoking release() during the same test.\n     *\n     *   The release() callback lets internal processing resume.\n     *\n     * Failure scenarios:\n     *\n     * - The test fails due to an uncaught exception.\n     *\n     *   In this case, Test.run() will call internalRecover() which empties the clears all\n     *   async pauses and sets the cancelled flag, which means we silently ignore any\n     *   late calls to the resume() callback, as we will have moved on to a different\n     *   test by then, and we don't want to cause an extra \"release during a different test\"\n     *   errors that the developer isn't really responsible for. This can happen when a test\n     *   correctly schedules a call to release(), but also causes an uncaught error. The\n     *   uncaught error means we will no longer wait for the release (as it might not arrive).\n     *\n     * - Pause is never released, or called an insufficient number of times.\n     *\n     *   Our timeout handler will kill the pause and resume test processing, basically\n     *   like internalRecover(), but for one pause instead of any/all.\n     *\n     *   Here, too, any late calls to resume() will be silently ignored to avoid\n     *   extra errors. We tolerate this since the original test will have already been\n     *   marked as failure.\n     *\n     *   TODO: QUnit 3 will enable timeouts by default <https://github.com/qunitjs/qunit/issues/1483>,\n     *   but right now a test will hang indefinitely if async pauses are not released,\n     *   unless QUnit.config.testTimeout or assert.timeout() is used.\n     *\n     * - Pause is spontaneously released during a different test,\n     *   or when no test is currently running.\n     *\n     *   This is close to impossible because this error only happens if the original test\n     *   succesfully finished first (since other failure scenarios kill pauses and ignore\n     *   late calls). It can happen if a test ended exactly as expected, but has some\n     *   external or shared state continuing to hold a reference to the release callback,\n     *   and either the same test scheduled another call to it in the future, or a later test\n     *   causes it to be called through some shared state.\n     *\n     * - Pause release() is called too often, during the same test.\n     *\n     *   This simply throws an error, after which uncaught error handling picks it up\n     *   and processing resumes.\n     *\n     * @param {number} [requiredCalls=1]\n     */internalStop:function internalStop(){var requiredCalls=arguments.length>0&&arguments[0]!==undefined?arguments[0]:1;config.blocking=true;var test=this;var pauseId=this.nextPauseId++;var pause={cancelled:false,remaining:requiredCalls};test.pauses.set(pauseId,pause);function release(){if(pause.cancelled){return;}if(config.current===undefined){throw new Error('Unexpected release of async pause after tests finished.\\n'+\"> Test: \".concat(test.testName,\" [async #\").concat(pauseId,\"]\"));}if(config.current!==test){throw new Error('Unexpected release of async pause during a different test.\\n'+\"> Test: \".concat(test.testName,\" [async #\").concat(pauseId,\"]\"));}if(pause.remaining<=0){throw new Error('Tried to release async pause that was already released.\\n'+\"> Test: \".concat(test.testName,\" [async #\").concat(pauseId,\"]\"));}// The `requiredCalls` parameter exists to support `assert.async(count)`\npause.remaining--;if(pause.remaining===0){test.pauses.delete(pauseId);}internalStart(test);}// Set a recovery timeout, if so configured.\nif(setTimeout$1){var timeoutDuration;if(typeof test.timeout==='number'){timeoutDuration=test.timeout;}else if(typeof config.testTimeout==='number'){timeoutDuration=config.testTimeout;}if(typeof timeoutDuration==='number'&&timeoutDuration>0){config.timeoutHandler=function(timeout){return function(){config.timeout=null;pause.cancelled=true;test.pauses.delete(pauseId);test.pushFailure(\"Test took longer than \".concat(timeout,\"ms; test timed out.\"),sourceFromStacktrace(2));internalRecover(test);};};clearTimeout(config.timeout);config.timeout=setTimeout$1(config.timeoutHandler(timeoutDuration),timeoutDuration);}else{clearTimeout(config.timeout);config.timeout=setTimeout$1(function(){config.timeout=null;if(!config._deprecated_timeout_shown){config._deprecated_timeout_shown=true;Logger.warn(\"Test \\\"\".concat(test.testName,\"\\\" took longer than 3000ms, but no timeout was set. Set QUnit.config.testTimeout or call assert.timeout() to avoid a timeout in QUnit 3. https://qunitjs.com/api/config/testTimeout/\"));}},3000);}}return release;},resolvePromise:function resolvePromise(promise,phase){if(promise!=null){var _test=this;var then=promise.then;if(typeof then==='function'){var resume=_test.internalStop();var resolve=function resolve(){resume();};if(config.notrycatch){then.call(promise,resolve);}else{var reject=function reject(error){var message='Promise rejected '+(!phase?'during':phase.replace(/Each$/,''))+' \"'+_test.testName+'\": '+(error&&error.message||error);_test.pushFailure(message,extractStacktrace(error,0));// Else next test will carry the responsibility\nsaveGlobal();// Unblock\ninternalRecover(_test);};then.call(promise,resolve,reject);}}}},valid:function valid(){// Internally-generated tests are always valid\nif(this.callback&&this.callback.validTest){return true;}function moduleChainIdMatch(testModule,selectedId){return(// undefined or empty array\n!selectedId||!selectedId.length||inArray(testModule.moduleId,selectedId)||testModule.parentModule&&moduleChainIdMatch(testModule.parentModule,selectedId));}if(!moduleChainIdMatch(this.module,config.moduleId)){return false;}if(config.testId&&config.testId.length&&!inArray(this.testId,config.testId)){return false;}function moduleChainNameMatch(testModule,selectedModule){if(!selectedModule){// undefined or empty string\nreturn true;}var testModuleName=testModule.name?testModule.name.toLowerCase():null;if(testModuleName===selectedModule){return true;}else if(testModule.parentModule){return moduleChainNameMatch(testModule.parentModule,selectedModule);}else{return false;}}var selectedModule=config.module&&config.module.toLowerCase();if(!moduleChainNameMatch(this.module,selectedModule)){return false;}var filter=config.filter;if(!filter){return true;}var regexFilter=/^(!?)\\/([\\w\\W]*)\\/(i?$)/.exec(filter);var fullName=this.module.name+': '+this.testName;return regexFilter?this.regexFilter(!!regexFilter[1],regexFilter[2],regexFilter[3],fullName):this.stringFilter(filter,fullName);},regexFilter:function regexFilter(exclude,pattern,flags,fullName){var regex=new RegExp(pattern,flags);var match=regex.test(fullName);return match!==exclude;},stringFilter:function stringFilter(filter,fullName){filter=filter.toLowerCase();fullName=fullName.toLowerCase();var include=filter.charAt(0)!=='!';if(!include){filter=filter.slice(1);}// If the filter matches, we need to honour include\nif(fullName.indexOf(filter)!==-1){return include;}// Otherwise, do the opposite\nreturn!include;}};function pushFailure(){if(!config.current){throw new Error('pushFailure() assertion outside test context, in '+sourceFromStacktrace(2));}// Gets current test obj\nvar currentTest=config.current;return currentTest.pushFailure.apply(currentTest,arguments);}function saveGlobal(){config.pollution=[];if(config.noglobals){for(var key in g){if(hasOwn$2.call(g,key)){// In Opera sometimes DOM element ids show up here, ignore them\nif(/^qunit-test-output/.test(key)){continue;}config.pollution.push(key);}}}}function checkPollution(){var old=config.pollution;saveGlobal();var newGlobals=diff$1(config.pollution,old);if(newGlobals.length>0){pushFailure('Introduced global variable(s): '+newGlobals.join(', '));}var deletedGlobals=diff$1(old,config.pollution);if(deletedGlobals.length>0){pushFailure('Deleted global variable(s): '+deletedGlobals.join(', '));}}var focused=false;// indicates that the \"only\" filter was used\nfunction addTest(settings){if(focused||config.currentModule.ignored){return;}var newTest=new Test(settings);newTest.queue();}function addOnlyTest(settings){if(config.currentModule.ignored){return;}if(!focused){config.queue.length=0;focused=true;}var newTest=new Test(settings);newTest.queue();}// Will be exposed as QUnit.test\nfunction test(testName,callback){addTest({testName:testName,callback:callback});}function makeEachTestName(testName,argument){return\"\".concat(testName,\" [\").concat(argument,\"]\");}function runEach(data,eachFn){if(Array.isArray(data)){for(var i=0;i<data.length;i++){eachFn(data[i],i);}}else if(_typeof(data)==='object'&&data!==null){for(var key in data){eachFn(data[key],key);}}else{throw new Error(\"test.each() expects an array or object as input, but\\nfound \".concat(_typeof(data),\" instead.\"));}}extend(test,{todo:function todo(testName,callback){addTest({testName:testName,callback:callback,todo:true});},skip:function skip(testName){addTest({testName:testName,skip:true});},if:function _if(testName,condition,callback){addTest({testName:testName,callback:callback,skip:!condition});},only:function only(testName,callback){addOnlyTest({testName:testName,callback:callback});},each:function each(testName,dataset,callback){runEach(dataset,function(data,testKey){addTest({testName:makeEachTestName(testName,testKey),callback:callback,withData:true,stackOffset:5,data:data});});}});test.todo.each=function(testName,dataset,callback){runEach(dataset,function(data,testKey){addTest({testName:makeEachTestName(testName,testKey),callback:callback,todo:true,withData:true,stackOffset:5,data:data});});};test.skip.each=function(testName,dataset){runEach(dataset,function(_,testKey){addTest({testName:makeEachTestName(testName,testKey),stackOffset:5,skip:true});});};test.if.each=function(testName,condition,dataset,callback){runEach(dataset,function(data,testKey){addTest({testName:makeEachTestName(testName,testKey),callback:callback,withData:true,stackOffset:5,skip:!condition,data:condition?data:undefined});});};test.only.each=function(testName,dataset,callback){runEach(dataset,function(data,testKey){addOnlyTest({testName:makeEachTestName(testName,testKey),callback:callback,withData:true,stackOffset:5,data:data});});};// Forcefully release all processing holds.\nfunction internalRecover(test){test.pauses.forEach(function(pause){pause.cancelled=true;});test.pauses.clear();internalStart(test);}// Release a processing hold, scheduling a resumption attempt if no holds remain.\nfunction internalStart(test){// Ignore if other async pauses still exist.\nif(test.pauses.size>0){return;}// Add a slight delay to allow more assertions etc.\nif(setTimeout$1){clearTimeout(config.timeout);config.timeout=setTimeout$1(function(){if(test.pauses.size>0){return;}clearTimeout(config.timeout);config.timeout=null;config.blocking=false;config.pq.advance();});}else{config.blocking=false;config.pq.advance();}}function collectTests(module){var tests=[].concat(module.tests);var modules=_toConsumableArray(module.childModules);// Do a breadth-first traversal of the child modules\nwhile(modules.length){var nextModule=modules.shift();tests.push.apply(tests,nextModule.tests);modules.push.apply(modules,_toConsumableArray(nextModule.childModules));}return tests;}// This returns true after all executable and skippable tests\n// in a module have been proccessed, and informs 'suiteEnd'\n// and moduleDone().\nfunction allTestsExecuted(module){return module.testsRun+module.testsIgnored===collectTests(module).length;}// This returns true during the last executable non-skipped test\n// within a module, and informs the running of the 'after' hook\n// for a given module. This runs only once for a given module,\n// but must run during the last non-skipped test. When it runs,\n// there may be non-zero skipped tests left.\nfunction lastTestWithinModuleExecuted(module){return module.testsRun===collectTests(module).filter(function(test){return!test.skip;}).length-1;}function incrementTestsRun(module){module.testsRun++;while(module=module.parentModule){module.testsRun++;}}function incrementTestsIgnored(module){module.testsIgnored++;while(module=module.parentModule){module.testsIgnored++;}}/* global module, exports, define */function exportQUnit(QUnit){var exportedModule=false;if(window$1&&document){// QUnit may be defined when it is preconfigured but then only QUnit and QUnit.config may be defined.\nif(window$1.QUnit&&window$1.QUnit.version){throw new Error('QUnit has already been defined.');}window$1.QUnit=QUnit;exportedModule=true;}// For Node.js\nif( true&&module&&module.exports){module.exports=QUnit;// For consistency with CommonJS environments' exports\nmodule.exports.QUnit=QUnit;exportedModule=true;}// For CommonJS with exports, but without module.exports, like Rhino\nif( true&&exports){exports.QUnit=QUnit;exportedModule=true;}// For AMD\nif(true){!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){return QUnit;}).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));QUnit.config.autostart=false;exportedModule=true;}// For other environments, including Web Workers (globalThis === self),\n// SpiderMonkey (mozjs), and other embedded JavaScript engines\nif(!exportedModule){g.QUnit=QUnit;}}var ConsoleReporter=/*#__PURE__*/function(){function ConsoleReporter(runner){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,ConsoleReporter);// Cache references to console methods to ensure we can report failures\n// from tests tests that mock the console object itself.\n// https://github.com/qunitjs/qunit/issues/1340\n// Support IE 9: Function#bind is supported, but no console.log.bind().\nthis.log=options.log||Function.prototype.bind.call(console$1.log,console$1);runner.on('error',this.onError.bind(this));runner.on('runStart',this.onRunStart.bind(this));runner.on('testStart',this.onTestStart.bind(this));runner.on('testEnd',this.onTestEnd.bind(this));runner.on('runEnd',this.onRunEnd.bind(this));}return _createClass(ConsoleReporter,[{key:\"onError\",value:function onError(error){this.log('error',error);}},{key:\"onRunStart\",value:function onRunStart(runStart){this.log('runStart',runStart);}},{key:\"onTestStart\",value:function onTestStart(test){this.log('testStart',test);}},{key:\"onTestEnd\",value:function onTestEnd(test){this.log('testEnd',test);}},{key:\"onRunEnd\",value:function onRunEnd(runEnd){this.log('runEnd',runEnd);}}],[{key:\"init\",value:function init(runner,options){return new ConsoleReporter(runner,options);}}]);}();// TODO: Consider using globalThis instead of window, so that the reporter\n// works for Node.js as well. As this can add overhead, we should make\n// this opt-in before we enable it for CLI.\n//\n// QUnit 3 will switch from `window` to `globalThis` and then make it\n// no longer an implicit feature of the HTML Reporter, but rather let\n// it be opt-in via `QUnit.config.reporters = ['perf']` or something\n// like that.\nvar nativePerf=window$1&&typeof window$1.performance!=='undefined'&&// eslint-disable-next-line compat/compat -- Checked\ntypeof window$1.performance.mark==='function'&&// eslint-disable-next-line compat/compat -- Checked\ntypeof window$1.performance.measure==='function'?window$1.performance:undefined;var perf={measure:nativePerf?function(comment,startMark,endMark){// `performance.measure` may fail if the mark could not be found.\n// reasons a specific mark could not be found include: outside code invoking `performance.clearMarks()`\ntry{nativePerf.measure(comment,startMark,endMark);}catch(ex){Logger.warn('performance.measure could not be executed because of ',ex.message);}}:function(){},mark:nativePerf?nativePerf.mark.bind(nativePerf):function(){}};var PerfReporter=/*#__PURE__*/function(){function PerfReporter(runner){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,PerfReporter);this.perf=options.perf||perf;runner.on('runStart',this.onRunStart.bind(this));runner.on('runEnd',this.onRunEnd.bind(this));runner.on('suiteStart',this.onSuiteStart.bind(this));runner.on('suiteEnd',this.onSuiteEnd.bind(this));runner.on('testStart',this.onTestStart.bind(this));runner.on('testEnd',this.onTestEnd.bind(this));}return _createClass(PerfReporter,[{key:\"onRunStart\",value:function onRunStart(){this.perf.mark('qunit_suite_0_start');}},{key:\"onSuiteStart\",value:function onSuiteStart(suiteStart){var suiteLevel=suiteStart.fullName.length;this.perf.mark(\"qunit_suite_\".concat(suiteLevel,\"_start\"));}},{key:\"onSuiteEnd\",value:function onSuiteEnd(suiteEnd){var suiteLevel=suiteEnd.fullName.length;var suiteName=suiteEnd.fullName.join(' – ');this.perf.mark(\"qunit_suite_\".concat(suiteLevel,\"_end\"));this.perf.measure(\"QUnit Test Suite: \".concat(suiteName),\"qunit_suite_\".concat(suiteLevel,\"_start\"),\"qunit_suite_\".concat(suiteLevel,\"_end\"));}},{key:\"onTestStart\",value:function onTestStart(){this.perf.mark('qunit_test_start');}},{key:\"onTestEnd\",value:function onTestEnd(testEnd){this.perf.mark('qunit_test_end');var testName=testEnd.fullName.join(' – ');this.perf.measure(\"QUnit Test: \".concat(testName),'qunit_test_start','qunit_test_end');}},{key:\"onRunEnd\",value:function onRunEnd(){this.perf.mark('qunit_suite_0_end');this.perf.measure('QUnit Test Run','qunit_suite_0_start','qunit_suite_0_end');}}],[{key:\"init\",value:function init(runner,options){return new PerfReporter(runner,options);}}]);}();var FORCE_COLOR,NODE_DISABLE_COLORS,NO_COLOR,TERM,isTTY=true;if(typeof process!=='undefined'){var _ref=process.env||{};FORCE_COLOR=_ref.FORCE_COLOR;NODE_DISABLE_COLORS=_ref.NODE_DISABLE_COLORS;NO_COLOR=_ref.NO_COLOR;TERM=_ref.TERM;isTTY=process.stdout&&process.stdout.isTTY;}var $={enabled:!NODE_DISABLE_COLORS&&NO_COLOR==null&&TERM!=='dumb'&&(FORCE_COLOR!=null&&FORCE_COLOR!=='0'||isTTY),// modifiers\nreset:init(0,0),bold:init(1,22),dim:init(2,22),italic:init(3,23),underline:init(4,24),inverse:init(7,27),hidden:init(8,28),strikethrough:init(9,29),// colors\nblack:init(30,39),red:init(31,39),green:init(32,39),yellow:init(33,39),blue:init(34,39),magenta:init(35,39),cyan:init(36,39),white:init(37,39),gray:init(90,39),grey:init(90,39),// background colors\nbgBlack:init(40,49),bgRed:init(41,49),bgGreen:init(42,49),bgYellow:init(43,49),bgBlue:init(44,49),bgMagenta:init(45,49),bgCyan:init(46,49),bgWhite:init(47,49)};function run(arr,str){var i=0,tmp,beg='',end='';for(;i<arr.length;i++){tmp=arr[i];beg+=tmp.open;end+=tmp.close;if(!!~str.indexOf(tmp.close)){str=str.replace(tmp.rgx,tmp.close+tmp.open);}}return beg+str+end;}function chain(has,keys){var ctx={has:has,keys:keys};ctx.reset=$.reset.bind(ctx);ctx.bold=$.bold.bind(ctx);ctx.dim=$.dim.bind(ctx);ctx.italic=$.italic.bind(ctx);ctx.underline=$.underline.bind(ctx);ctx.inverse=$.inverse.bind(ctx);ctx.hidden=$.hidden.bind(ctx);ctx.strikethrough=$.strikethrough.bind(ctx);ctx.black=$.black.bind(ctx);ctx.red=$.red.bind(ctx);ctx.green=$.green.bind(ctx);ctx.yellow=$.yellow.bind(ctx);ctx.blue=$.blue.bind(ctx);ctx.magenta=$.magenta.bind(ctx);ctx.cyan=$.cyan.bind(ctx);ctx.white=$.white.bind(ctx);ctx.gray=$.gray.bind(ctx);ctx.grey=$.grey.bind(ctx);ctx.bgBlack=$.bgBlack.bind(ctx);ctx.bgRed=$.bgRed.bind(ctx);ctx.bgGreen=$.bgGreen.bind(ctx);ctx.bgYellow=$.bgYellow.bind(ctx);ctx.bgBlue=$.bgBlue.bind(ctx);ctx.bgMagenta=$.bgMagenta.bind(ctx);ctx.bgCyan=$.bgCyan.bind(ctx);ctx.bgWhite=$.bgWhite.bind(ctx);return ctx;}function init(open,close){var blk={open:\"\\x1B[\".concat(open,\"m\"),close:\"\\x1B[\".concat(close,\"m\"),rgx:new RegExp(\"\\\\x1b\\\\[\".concat(close,\"m\"),'g')};return function(txt){if(this!==void 0&&this.has!==void 0){!!~this.has.indexOf(open)||(this.has.push(open),this.keys.push(blk));return txt===void 0?this:$.enabled?run(this.keys,txt+''):txt+'';}return txt===void 0?chain([open],[blk]):$.enabled?run([blk],txt+''):txt+'';};}var hasOwn$1=Object.prototype.hasOwnProperty;/**\n   * Format a given value into YAML.\n   *\n   * YAML is a superset of JSON that supports all the same data\n   * types and syntax, and more. As such, it is always possible\n   * to fallback to JSON.stringfify, but we generally avoid\n   * that to make output easier to read for humans.\n   *\n   * Supported data types:\n   *\n   * - null\n   * - boolean\n   * - number\n   * - string\n   * - array\n   * - object\n   *\n   * Anything else (including NaN, Infinity, and undefined)\n   * must be described in strings, for display purposes.\n   *\n   * Note that quotes are optional in YAML strings if the\n   * strings are \"simple\", and as such we generally prefer\n   * that for improved readability. We output strings in\n   * one of three ways:\n   *\n   * - bare unquoted text, for simple one-line strings.\n   * - JSON (quoted text), for complex one-line strings.\n   * - YAML Block, for complex multi-line strings.\n   *\n   * Objects with cyclical references will be stringifed as\n   * \"[Circular]\" as they cannot otherwise be represented.\n   */function prettyYamlValue(value){var indent=arguments.length>1&&arguments[1]!==undefined?arguments[1]:4;if(value===undefined){// Not supported in JSON/YAML, turn into string\n// and let the below output it as bare string.\nvalue=String(value);}// Support IE 9-11: Use isFinite instead of ES6 Number.isFinite\nif(typeof value==='number'&&!isFinite(value)){// Turn NaN and Infinity into simple strings.\n// Paranoia: Don't return directly just in case there's\n// a way to add special characters here.\nvalue=String(value);}if(typeof value==='number'){// Simple numbers\nreturn JSON.stringify(value);}if(typeof value==='string'){// If any of these match, then we can't output it\n// as bare unquoted text, because that would either\n// cause data loss or invalid YAML syntax.\n//\n// - Quotes, escapes, line breaks, or JSON-like stuff.\nvar rSpecialJson=/['\"\\\\/[{}\\]\\r\\n]/;// - Characters that are special at the start of a YAML value\nvar rSpecialYaml=/[-?:,[\\]{}#&*!|=>'\"%@`]/;// - Leading or trailing whitespace.\nvar rUntrimmed=/(^\\s|\\s$)/;// - Ambiguous as YAML number, e.g. '2', '-1.2', '.2', or '2_000'\nvar rNumerical=/^[\\d._-]+$/;// - Ambiguous as YAML bool.\n//   Use case-insensitive match, although technically only\n//   fully-lower, fully-upper, or uppercase-first would be ambiguous.\n//   e.g. true/True/TRUE, but not tRUe.\nvar rBool=/^(true|false|y|n|yes|no|on|off)$/i;// Is this a complex string?\nif(value===''||rSpecialJson.test(value)||rSpecialYaml.test(value[0])||rUntrimmed.test(value)||rNumerical.test(value)||rBool.test(value)){if(!/\\n/.test(value)){// Complex one-line string, use JSON (quoted string)\nreturn JSON.stringify(value);}// See also <https://yaml-multiline.info/>\n// Support IE 9-11: Avoid ES6 String#repeat\nvar prefix=new Array(indent+1).join(' ');var trailingLinebreakMatch=value.match(/\\n+$/);var trailingLinebreaks=trailingLinebreakMatch?trailingLinebreakMatch[0].length:0;if(trailingLinebreaks===1){// Use the most straight-forward \"Block\" string in YAML\n// without any \"Chomping\" indicators.\nvar lines=value// Ignore the last new line, since we'll get that one for free\n// with the straight-forward Block syntax.\n.replace(/\\n$/,'').split('\\n').map(function(line){return prefix+line;});return'|\\n'+lines.join('\\n');}else{// This has either no trailing new lines, or more than 1.\n// Use |+ so that YAML parsers will preserve it exactly.\nvar _lines=value.split('\\n').map(function(line){return prefix+line;});return'|+\\n'+_lines.join('\\n');}}else{// Simple string, use bare unquoted text\nreturn value;}}// Handle null, boolean, array, and object\nreturn JSON.stringify(decycledShallowClone(value),null,2);}/**\n   * Creates a shallow clone of an object where cycles have\n   * been replaced with \"[Circular]\".\n   */function decycledShallowClone(object){var ancestors=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];if(ancestors.indexOf(object)!==-1){return'[Circular]';}var type=Object.prototype.toString.call(object).replace(/^\\[.+\\s(.+?)]$/,'$1').toLowerCase();var clone;switch(type){case'array':ancestors.push(object);clone=object.map(function(element){return decycledShallowClone(element,ancestors);});ancestors.pop();break;case'object':ancestors.push(object);clone={};Object.keys(object).forEach(function(key){clone[key]=decycledShallowClone(object[key],ancestors);});ancestors.pop();break;default:clone=object;}return clone;}var TapReporter=/*#__PURE__*/function(){function TapReporter(runner){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,TapReporter);// Cache references to console methods to ensure we can report failures\n// from tests tests that mock the console object itself.\n// https://github.com/qunitjs/qunit/issues/1340\n// Support IE 9: Function#bind is supported, but no console.log.bind().\nthis.log=options.log||Function.prototype.bind.call(console$1.log,console$1);this.testCount=0;this.ended=false;this.bailed=false;runner.on('error',this.onError.bind(this));runner.on('runStart',this.onRunStart.bind(this));runner.on('testEnd',this.onTestEnd.bind(this));runner.on('runEnd',this.onRunEnd.bind(this));}return _createClass(TapReporter,[{key:\"onRunStart\",value:function onRunStart(_runSuite){this.log('TAP version 13');}},{key:\"onError\",value:function onError(error){if(this.bailed){return;}this.bailed=true;// Imitate onTestEnd\n// Skip this if we're past \"runEnd\" as it would look odd\nif(!this.ended){this.testCount=this.testCount+1;this.log($.red(\"not ok \".concat(this.testCount,\" global failure\")));this.logError(error);}this.log('Bail out! '+errorString(error).split('\\n')[0]);if(this.ended){this.logError(error);}}},{key:\"onTestEnd\",value:function onTestEnd(test){var _this=this;this.testCount=this.testCount+1;if(test.status==='passed'){this.log(\"ok \".concat(this.testCount,\" \").concat(test.fullName.join(' > ')));}else if(test.status==='skipped'){this.log($.yellow(\"ok \".concat(this.testCount,\" # SKIP \").concat(test.fullName.join(' > '))));}else if(test.status==='todo'){this.log($.cyan(\"not ok \".concat(this.testCount,\" # TODO \").concat(test.fullName.join(' > '))));test.errors.forEach(function(error){return _this.logAssertion(error,'todo');});}else{this.log($.red(\"not ok \".concat(this.testCount,\" \").concat(test.fullName.join(' > '))));test.errors.forEach(function(error){return _this.logAssertion(error);});}}},{key:\"onRunEnd\",value:function onRunEnd(runSuite){this.ended=true;this.log(\"1..\".concat(runSuite.testCounts.total));this.log(\"# pass \".concat(runSuite.testCounts.passed));this.log($.yellow(\"# skip \".concat(runSuite.testCounts.skipped)));this.log($.cyan(\"# todo \".concat(runSuite.testCounts.todo)));this.log($.red(\"# fail \".concat(runSuite.testCounts.failed)));}},{key:\"logAssertion\",value:function logAssertion(error,severity){var out='  ---';out+=\"\\n  message: \".concat(prettyYamlValue(error.message||'failed'));out+=\"\\n  severity: \".concat(prettyYamlValue(severity||'failed'));if(hasOwn$1.call(error,'actual')){out+=\"\\n  actual  : \".concat(prettyYamlValue(error.actual));}if(hasOwn$1.call(error,'expected')){out+=\"\\n  expected: \".concat(prettyYamlValue(error.expected));}if(error.stack){// Since stacks aren't user generated, take a bit of liberty by\n// adding a trailing new line to allow a straight-forward YAML Blocks.\nout+=\"\\n  stack: \".concat(prettyYamlValue(error.stack+'\\n'));}out+='\\n  ...';this.log(out);}},{key:\"logError\",value:function logError(error){var out='  ---';out+=\"\\n  message: \".concat(prettyYamlValue(errorString(error)));out+=\"\\n  severity: \".concat(prettyYamlValue('failed'));if(error&&error.stack){out+=\"\\n  stack: \".concat(prettyYamlValue(error.stack+'\\n'));}out+='\\n  ...';this.log(out);}}],[{key:\"init\",value:function init(runner,options){return new TapReporter(runner,options);}}]);}();var reporters={console:ConsoleReporter,perf:PerfReporter,tap:TapReporter};function makeAddGlobalHook(hookName){return function addGlobalHook(callback){if(!config.globalHooks[hookName]){config.globalHooks[hookName]=[];}config.globalHooks[hookName].push(callback);};}var hooks={beforeEach:makeAddGlobalHook('beforeEach'),afterEach:makeAddGlobalHook('afterEach')};/**\n   * Creates a seeded \"sample\" generator which is used for randomizing tests.\n   */function unitSamplerGenerator(seed){// 32-bit xorshift, requires only a nonzero seed\n// https://excamera.com/sphinx/article-xorshift.html\nvar sample=parseInt(generateHash(seed),16)||-1;return function(){sample^=sample<<13;sample^=sample>>>17;sample^=sample<<5;// ECMAScript has no unsigned number type\nif(sample<0){sample+=0x100000000;}return sample/0x100000000;};}var ProcessingQueue=/*#__PURE__*/function(){/**\n     * @param {Function} test Reference to the QUnit.test() method\n     */function ProcessingQueue(test){_classCallCheck(this,ProcessingQueue);this.test=test;this.priorityCount=0;this.unitSampler=null;// This is a queue of functions that are tasks within a single test.\n// After tests are dequeued from config.queue they are expanded into\n// a set of tasks in this queue.\nthis.taskQueue=[];this.finished=false;}/**\n     * Advances the taskQueue to the next task. If the taskQueue is empty,\n     * process the testQueue\n     */return _createClass(ProcessingQueue,[{key:\"advance\",value:function advance(){this.advanceTaskQueue();if(!this.taskQueue.length&&!config.blocking&&!config.current){this.advanceTestQueue();}}/**\n       * Advances the taskQueue with an increased depth\n       */},{key:\"advanceTaskQueue\",value:function advanceTaskQueue(){var start=performance.now();config.depth=(config.depth||0)+1;this.processTaskQueue(start);config.depth--;}/**\n       * Process the first task on the taskQueue as a promise.\n       * Each task is a function added by Test#queue() in /src/test.js\n       */},{key:\"processTaskQueue\",value:function processTaskQueue(start){var _this=this;if(this.taskQueue.length&&!config.blocking){var elapsedTime=performance.now()-start;if(!setTimeout$1||config.updateRate<=0||elapsedTime<config.updateRate){var task=this.taskQueue.shift();_Promise.resolve(task()).then(function(){if(!_this.taskQueue.length){_this.advance();}else{_this.processTaskQueue(start);}});}else{setTimeout$1(function(){_this.advance();});}}}/**\n       * Advance the testQueue to the next test to process. Call done() if testQueue completes.\n       */},{key:\"advanceTestQueue\",value:function advanceTestQueue(){if(!config.blocking&&!config.queue.length&&config.depth===0){this.done();return;}var testTasks=config.queue.shift();this.addToTaskQueue(testTasks());if(this.priorityCount>0){this.priorityCount--;}this.advance();}/**\n       * Enqueue the tasks for a test into the task queue.\n       * @param {Array} tasksArray\n       */},{key:\"addToTaskQueue\",value:function addToTaskQueue(tasksArray){var _this$taskQueue;(_this$taskQueue=this.taskQueue).push.apply(_this$taskQueue,_toConsumableArray(tasksArray));}/**\n       * Return the number of tasks remaining in the task queue to be processed.\n       * @return {number}\n       */},{key:\"taskCount\",value:function taskCount(){return this.taskQueue.length;}/**\n       * Adds a test to the TestQueue for execution.\n       * @param {Function} testTasksFunc\n       * @param {boolean} prioritize\n       */},{key:\"add\",value:function add(testTasksFunc,prioritize){if(prioritize){config.queue.splice(this.priorityCount++,0,testTasksFunc);}else if(config.seed){if(!this.unitSampler){this.unitSampler=unitSamplerGenerator(config.seed);}// Insert into a random position after all prioritized items\nvar index=Math.floor(this.unitSampler()*(config.queue.length-this.priorityCount+1));config.queue.splice(this.priorityCount+index,0,testTasksFunc);}else{config.queue.push(testTasksFunc);}}/**\n       * This function is called when the ProcessingQueue is done processing all\n       * items. It handles emitting the final run events.\n       */},{key:\"done\",value:function done(){// We have reached the end of the processing queue and are about to emit the\n// \"runEnd\" event after which reporters typically stop listening and exit\n// the process. First, check if we need to emit one final test.\nif(config.stats.testCount===0&&config.failOnZeroTests===true){var error;if(config.filter&&config.filter.length){error=new Error(\"No tests matched the filter \\\"\".concat(config.filter,\"\\\".\"));}else if(config.module&&config.module.length){error=new Error(\"No tests matched the module \\\"\".concat(config.module,\"\\\".\"));}else if(config.moduleId&&config.moduleId.length){error=new Error(\"No tests matched the moduleId \\\"\".concat(config.moduleId,\"\\\".\"));}else if(config.testId&&config.testId.length){error=new Error(\"No tests matched the testId \\\"\".concat(config.testId,\"\\\".\"));}else{error=new Error('No tests were run.');}this.test('global failure',extend(function(assert){assert.pushResult({result:false,message:error.message,source:error.stack});},{validTest:true}));// We do need to call `advance()` in order to resume the processing queue.\n// Once this new test is finished processing, we'll reach `done` again, and\n// that time the above condition will evaluate to false.\nthis.advance();return;}var storage=config.storage;var runtime=Math.round(performance.now()-config.started);var passed=config.stats.all-config.stats.bad;this.finished=true;emit('runEnd',runSuite.end(true));runLoggingCallbacks('done',{// @deprecated since 2.19.0 Use done() without `details` parameter,\n// or use `QUnit.on('runEnd')` instead. Parameter to be replaced in\n// QUnit 3.0 with test counts.\npassed:passed,failed:config.stats.bad,total:config.stats.all,runtime:runtime}).then(function(){// Clear own storage items if all tests passed\nif(storage&&config.stats.bad===0){for(var i=storage.length-1;i>=0;i--){var key=storage.key(i);if(key.indexOf('qunit-test-')===0){storage.removeItem(key);}}}});}}]);}();/**\n   * Handle a global error that should result in a failed test run.\n   *\n   * Summary:\n   *\n   * - If we're strictly inside a test (or one if its module hooks), the exception\n   *   becomes a failed assertion.\n   *\n   *   This has the important side-effect that uncaught exceptions (such as\n   *   calling an undefined function) during a \"todo\" test do NOT result in\n   *   a failed test run.\n   *\n   * - If we're anywhere outside a test (be it in early event callbacks, or\n   *   internally between tests, or somewhere after \"runEnd\" if the process is\n   *   still alive for some reason), then send an \"error\" event to the reporters.\n   *\n   * @since 2.17.0\n   * @param {Error|any} error\n   */function onUncaughtException(error){if(config.current){config.current.assert.pushResult({result:false,message:\"global failure: \".concat(errorString(error)),// We could let callers specify an offset to subtract a number of frames via\n// sourceFromStacktrace, in case they are a wrapper further away from the error\n// handler, and thus reduce some noise in the stack trace. However, we're not\n// doing this right now because it would almost never be used in practice given\n// the vast majority of error values will be Error objects, and thus have their\n// own stack trace already.\nsource:error&&error.stack||sourceFromStacktrace(2)});}else{// The \"error\" event was added in QUnit 2.17.\n// Increase \"bad assertion\" stats despite no longer pushing an assertion in this case.\n// This ensures \"runEnd\" and \"QUnit.done()\" handlers behave as expected, since the \"bad\"\n// count is typically how reporters decide on the boolean outcome of the test run.\nrunSuite.globalFailureCount++;config.stats.bad++;config.stats.all++;emit('error',error);}}/**\n   * Handle a window.onerror error.\n   *\n   * If there is a current test that sets the internal `ignoreGlobalErrors` field\n   * (such as during `assert.throws()`), then the error is ignored and native\n   * error reporting is suppressed as well. This is because in browsers, an error\n   * can sometimes end up in `window.onerror` instead of in the local try/catch.\n   * This ignoring of errors does not apply to our general onUncaughtException\n   * method, nor to our `unhandledRejection` handlers, as those are not meant\n   * to receive an \"expected\" error during `assert.throws()`.\n   *\n   * @see <https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onerror>\n   * @deprecated since 2.17.0 Use QUnit.onUncaughtException instead.\n   * @param {Object} details\n   * @param {string} details.message\n   * @param {string} details.fileName\n   * @param {number} details.lineNumber\n   * @param {string|undefined} [details.stacktrace]\n   * @return {bool} True if native error reporting should be suppressed.\n   */function onWindowError(details){Logger.warn('QUnit.onError is deprecated and will be removed in QUnit 3.0.'+' Please use QUnit.onUncaughtException instead.');if(config.current&&config.current.ignoreGlobalErrors){return true;}var err=new Error(details.message);err.stack=details.stacktrace||details.fileName+':'+details.lineNumber;onUncaughtException(err);return false;}/* eslint-disable indent *//*\n   * This file is a modified version of google-diff-match-patch's JavaScript implementation\n   * (https://code.google.com/p/google-diff-match-patch/source/browse/trunk/javascript/diff_match_patch_uncompressed.js),\n   * modifications are licensed as more fully set forth in LICENSE.txt.\n   *\n   * The original source of google-diff-match-patch is attributable and licensed as follows:\n   *\n   * Copyright 2006 Google Inc.\n   * https://code.google.com/p/google-diff-match-patch/\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   * https://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *\n   * More Info:\n   *  https://code.google.com/p/google-diff-match-patch/\n   *\n   * Usage: QUnit.diff(expected, actual)\n   *\n   */function DiffMatchPatch(){}//  DIFF FUNCTIONS\n/**\n   * The data structure representing a diff is an array of tuples:\n   * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n   * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n   */var DIFF_DELETE=-1;var DIFF_INSERT=1;var DIFF_EQUAL=0;var hasOwn=Object.prototype.hasOwnProperty;/**\n   * Find the differences between two texts.  Simplifies the problem by stripping\n   * any common prefix or suffix off the texts before diffing.\n   * @param {string} text1 Old string to be diffed.\n   * @param {string} text2 New string to be diffed.\n   * @param {boolean=} optChecklines Optional speedup flag. If present and false,\n   *     then don't run a line-level diff first to identify the changed areas.\n   *     Defaults to true, which does a faster, slightly less optimal diff.\n   * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n   */DiffMatchPatch.prototype.DiffMain=function(text1,text2,optChecklines){// The diff must be complete in up to 1 second.\nvar deadline=Date.now()+1000;// Check for null inputs.\nif(text1===null||text2===null){throw new Error('Cannot diff null input.');}// Check for equality (speedup).\nif(text1===text2){if(text1){return[[DIFF_EQUAL,text1]];}return[];}if(typeof optChecklines==='undefined'){optChecklines=true;}// Trim off common prefix (speedup).\nvar commonlength=this.diffCommonPrefix(text1,text2);var commonprefix=text1.substring(0,commonlength);text1=text1.substring(commonlength);text2=text2.substring(commonlength);// Trim off common suffix (speedup).\ncommonlength=this.diffCommonSuffix(text1,text2);var commonsuffix=text1.substring(text1.length-commonlength);text1=text1.substring(0,text1.length-commonlength);text2=text2.substring(0,text2.length-commonlength);// Compute the diff on the middle block.\nvar diffs=this.diffCompute(text1,text2,optChecklines,deadline);// Restore the prefix and suffix.\nif(commonprefix){diffs.unshift([DIFF_EQUAL,commonprefix]);}if(commonsuffix){diffs.push([DIFF_EQUAL,commonsuffix]);}this.diffCleanupMerge(diffs);return diffs;};/**\n   * Reduce the number of edits by eliminating operationally trivial equalities.\n   * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n   */DiffMatchPatch.prototype.diffCleanupEfficiency=function(diffs){var changes,equalities,equalitiesLength,lastequality,pointer,preIns,preDel,postIns,postDel;changes=false;equalities=[];// Stack of indices where equalities are found.\nequalitiesLength=0;// Keeping our own length var is faster in JS.\n/** @type {?string} */lastequality=null;// Always equal to diffs[equalities[equalitiesLength - 1]][1]\npointer=0;// Index of current position.\n// Is there an insertion operation before the last equality.\npreIns=false;// Is there a deletion operation before the last equality.\npreDel=false;// Is there an insertion operation after the last equality.\npostIns=false;// Is there a deletion operation after the last equality.\npostDel=false;while(pointer<diffs.length){// Equality found.\nif(diffs[pointer][0]===DIFF_EQUAL){if(diffs[pointer][1].length<4&&(postIns||postDel)){// Candidate found.\nequalities[equalitiesLength++]=pointer;preIns=postIns;preDel=postDel;lastequality=diffs[pointer][1];}else{// Not a candidate, and can never become one.\nequalitiesLength=0;lastequality=null;}postIns=postDel=false;// An insertion or deletion.\n}else{if(diffs[pointer][0]===DIFF_DELETE){postDel=true;}else{postIns=true;}/*\n         * Five types to be split:\n         * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n         * <ins>A</ins>X<ins>C</ins><del>D</del>\n         * <ins>A</ins><del>B</del>X<ins>C</ins>\n         * <ins>A</del>X<ins>C</ins><del>D</del>\n         * <ins>A</ins><del>B</del>X<del>C</del>\n         */if(lastequality&&(preIns&&preDel&&postIns&&postDel||lastequality.length<2&&preIns+preDel+postIns+postDel===3)){// Duplicate record.\ndiffs.splice(equalities[equalitiesLength-1],0,[DIFF_DELETE,lastequality]);// Change second copy to insert.\ndiffs[equalities[equalitiesLength-1]+1][0]=DIFF_INSERT;equalitiesLength--;// Throw away the equality we just deleted;\nlastequality=null;if(preIns&&preDel){// No changes made which could affect previous entry, keep going.\npostIns=postDel=true;equalitiesLength=0;}else{equalitiesLength--;// Throw away the previous equality.\npointer=equalitiesLength>0?equalities[equalitiesLength-1]:-1;postIns=postDel=false;}changes=true;}}pointer++;}if(changes){this.diffCleanupMerge(diffs);}};/**\n   * Convert a diff array into a pretty HTML report.\n   * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n   * @param {integer} string to be beautified.\n   * @return {string} HTML representation.\n   */DiffMatchPatch.prototype.diffPrettyHtml=function(diffs){var html=[];for(var x=0;x<diffs.length;x++){var op=diffs[x][0];// Operation (insert, delete, equal)\nvar data=diffs[x][1];// Text of change.\nswitch(op){case DIFF_INSERT:html[x]='<ins>'+escapeText(data)+'</ins>';break;case DIFF_DELETE:html[x]='<del>'+escapeText(data)+'</del>';break;case DIFF_EQUAL:html[x]='<span>'+escapeText(data)+'</span>';break;}}return html.join('');};/**\n   * Determine the common prefix of two strings.\n   * @param {string} text1 First string.\n   * @param {string} text2 Second string.\n   * @return {number} The number of characters common to the start of each\n   *     string.\n   */DiffMatchPatch.prototype.diffCommonPrefix=function(text1,text2){var pointermid,pointermax,pointermin,pointerstart;// Quick check for common null cases.\nif(!text1||!text2||text1.charAt(0)!==text2.charAt(0)){return 0;}// Binary search.\n// Performance analysis: https://neil.fraser.name/news/2007/10/09/\npointermin=0;pointermax=Math.min(text1.length,text2.length);pointermid=pointermax;pointerstart=0;while(pointermin<pointermid){if(text1.substring(pointerstart,pointermid)===text2.substring(pointerstart,pointermid)){pointermin=pointermid;pointerstart=pointermin;}else{pointermax=pointermid;}pointermid=Math.floor((pointermax-pointermin)/2+pointermin);}return pointermid;};/**\n   * Determine the common suffix of two strings.\n   * @param {string} text1 First string.\n   * @param {string} text2 Second string.\n   * @return {number} The number of characters common to the end of each string.\n   */DiffMatchPatch.prototype.diffCommonSuffix=function(text1,text2){var pointermid,pointermax,pointermin,pointerend;// Quick check for common null cases.\nif(!text1||!text2||text1.charAt(text1.length-1)!==text2.charAt(text2.length-1)){return 0;}// Binary search.\n// Performance analysis: https://neil.fraser.name/news/2007/10/09/\npointermin=0;pointermax=Math.min(text1.length,text2.length);pointermid=pointermax;pointerend=0;while(pointermin<pointermid){if(text1.substring(text1.length-pointermid,text1.length-pointerend)===text2.substring(text2.length-pointermid,text2.length-pointerend)){pointermin=pointermid;pointerend=pointermin;}else{pointermax=pointermid;}pointermid=Math.floor((pointermax-pointermin)/2+pointermin);}return pointermid;};/**\n   * Find the differences between two texts.  Assumes that the texts do not\n   * have any common prefix or suffix.\n   * @param {string} text1 Old string to be diffed.\n   * @param {string} text2 New string to be diffed.\n   * @param {boolean} checklines Speedup flag.  If false, then don't run a\n   *     line-level diff first to identify the changed areas.\n   *     If true, then run a faster, slightly less optimal diff.\n   * @param {number} deadline Time when the diff should be complete by.\n   * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n   * @private\n   */DiffMatchPatch.prototype.diffCompute=function(text1,text2,checklines,deadline){var diffs,longtext,shorttext,i,hm,text1A,text2A,text1B,text2B,midCommon,diffsA,diffsB;if(!text1){// Just add some text (speedup).\nreturn[[DIFF_INSERT,text2]];}if(!text2){// Just delete some text (speedup).\nreturn[[DIFF_DELETE,text1]];}longtext=text1.length>text2.length?text1:text2;shorttext=text1.length>text2.length?text2:text1;i=longtext.indexOf(shorttext);if(i!==-1){// Shorter text is inside the longer text (speedup).\ndiffs=[[DIFF_INSERT,longtext.substring(0,i)],[DIFF_EQUAL,shorttext],[DIFF_INSERT,longtext.substring(i+shorttext.length)]];// Swap insertions for deletions if diff is reversed.\nif(text1.length>text2.length){diffs[0][0]=diffs[2][0]=DIFF_DELETE;}return diffs;}if(shorttext.length===1){// Single character string.\n// After the previous speedup, the character can't be an equality.\nreturn[[DIFF_DELETE,text1],[DIFF_INSERT,text2]];}// Check to see if the problem can be split in two.\nhm=this.diffHalfMatch(text1,text2);if(hm){// A half-match was found, sort out the return data.\ntext1A=hm[0];text1B=hm[1];text2A=hm[2];text2B=hm[3];midCommon=hm[4];// Send both pairs off for separate processing.\ndiffsA=this.DiffMain(text1A,text2A,checklines,deadline);diffsB=this.DiffMain(text1B,text2B,checklines,deadline);// Merge the results.\nreturn diffsA.concat([[DIFF_EQUAL,midCommon]],diffsB);}if(checklines&&text1.length>100&&text2.length>100){return this.diffLineMode(text1,text2,deadline);}return this.diffBisect(text1,text2,deadline);};/**\n   * Do the two texts share a substring which is at least half the length of the\n   * longer text?\n   * This speedup can produce non-minimal diffs.\n   * @param {string} text1 First string.\n   * @param {string} text2 Second string.\n   * @return {Array.<string>} Five element Array, containing the prefix of\n   *     text1, the suffix of text1, the prefix of text2, the suffix of\n   *     text2 and the common middle.  Or null if there was no match.\n   * @private\n   */DiffMatchPatch.prototype.diffHalfMatch=function(text1,text2){var longtext,shorttext,dmp,text1A,text2B,text2A,text1B,midCommon,hm1,hm2,hm;longtext=text1.length>text2.length?text1:text2;shorttext=text1.length>text2.length?text2:text1;if(longtext.length<4||shorttext.length*2<longtext.length){return null;// Pointless.\n}dmp=this;// 'this' becomes 'window' in a closure.\n/**\n     * Does a substring of shorttext exist within longtext such that the substring\n     * is at least half the length of longtext?\n     * Closure, but does not reference any external variables.\n     * @param {string} longtext Longer string.\n     * @param {string} shorttext Shorter string.\n     * @param {number} i Start index of quarter length substring within longtext.\n     * @return {Array.<string>} Five element Array, containing the prefix of\n     *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n     *     of shorttext and the common middle.  Or null if there was no match.\n     * @private\n     */function diffHalfMatchI(longtext,shorttext,i){var seed,j,bestCommon,prefixLength,suffixLength,bestLongtextA,bestLongtextB,bestShorttextA,bestShorttextB;// Start with a 1/4 length substring at position i as a seed.\nseed=longtext.substring(i,i+Math.floor(longtext.length/4));j=-1;bestCommon='';while((j=shorttext.indexOf(seed,j+1))!==-1){prefixLength=dmp.diffCommonPrefix(longtext.substring(i),shorttext.substring(j));suffixLength=dmp.diffCommonSuffix(longtext.substring(0,i),shorttext.substring(0,j));if(bestCommon.length<suffixLength+prefixLength){bestCommon=shorttext.substring(j-suffixLength,j)+shorttext.substring(j,j+prefixLength);bestLongtextA=longtext.substring(0,i-suffixLength);bestLongtextB=longtext.substring(i+prefixLength);bestShorttextA=shorttext.substring(0,j-suffixLength);bestShorttextB=shorttext.substring(j+prefixLength);}}if(bestCommon.length*2>=longtext.length){return[bestLongtextA,bestLongtextB,bestShorttextA,bestShorttextB,bestCommon];}else{return null;}}// First check if the second quarter is the seed for a half-match.\nhm1=diffHalfMatchI(longtext,shorttext,Math.ceil(longtext.length/4));// Check again based on the third quarter.\nhm2=diffHalfMatchI(longtext,shorttext,Math.ceil(longtext.length/2));if(!hm1&&!hm2){return null;}else if(!hm2){hm=hm1;}else if(!hm1){hm=hm2;}else{// Both matched.  Select the longest.\nhm=hm1[4].length>hm2[4].length?hm1:hm2;}// A half-match was found, sort out the return data.\nif(text1.length>text2.length){text1A=hm[0];text1B=hm[1];text2A=hm[2];text2B=hm[3];}else{text2A=hm[0];text2B=hm[1];text1A=hm[2];text1B=hm[3];}midCommon=hm[4];return[text1A,text1B,text2A,text2B,midCommon];};/**\n   * Do a quick line-level diff on both strings, then rediff the parts for\n   * greater accuracy.\n   * This speedup can produce non-minimal diffs.\n   * @param {string} text1 Old string to be diffed.\n   * @param {string} text2 New string to be diffed.\n   * @param {number} deadline Time when the diff should be complete by.\n   * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n   * @private\n   */DiffMatchPatch.prototype.diffLineMode=function(text1,text2,deadline){var a,diffs,linearray,pointer,countInsert,countDelete,textInsert,textDelete,j;// Scan the text on a line-by-line basis first.\na=this.diffLinesToChars(text1,text2);text1=a.chars1;text2=a.chars2;linearray=a.lineArray;diffs=this.DiffMain(text1,text2,false,deadline);// Convert the diff back to original text.\nthis.diffCharsToLines(diffs,linearray);// Eliminate freak matches (e.g. blank lines)\nthis.diffCleanupSemantic(diffs);// Rediff any replacement blocks, this time character-by-character.\n// Add a dummy entry at the end.\ndiffs.push([DIFF_EQUAL,'']);pointer=0;countDelete=0;countInsert=0;textDelete='';textInsert='';while(pointer<diffs.length){switch(diffs[pointer][0]){case DIFF_INSERT:countInsert++;textInsert+=diffs[pointer][1];break;case DIFF_DELETE:countDelete++;textDelete+=diffs[pointer][1];break;case DIFF_EQUAL:// Upon reaching an equality, check for prior redundancies.\nif(countDelete>=1&&countInsert>=1){// Delete the offending records and add the merged ones.\ndiffs.splice(pointer-countDelete-countInsert,countDelete+countInsert);pointer=pointer-countDelete-countInsert;a=this.DiffMain(textDelete,textInsert,false,deadline);for(j=a.length-1;j>=0;j--){diffs.splice(pointer,0,a[j]);}pointer=pointer+a.length;}countInsert=0;countDelete=0;textDelete='';textInsert='';break;}pointer++;}diffs.pop();// Remove the dummy entry at the end.\nreturn diffs;};/**\n   * Find the 'middle snake' of a diff, split the problem in two\n   * and return the recursively constructed diff.\n   * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n   * @param {string} text1 Old string to be diffed.\n   * @param {string} text2 New string to be diffed.\n   * @param {number} deadline Time at which to bail if not yet complete.\n   * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n   * @private\n   */DiffMatchPatch.prototype.diffBisect=function(text1,text2,deadline){var text1Length,text2Length,maxD,vOffset,vLength,v1,v2,x,delta,front,k1start,k1end,k2start,k2end,k2Offset,k1Offset,x1,x2,y1,y2,d,k1,k2;// Cache the text lengths to prevent multiple calls.\ntext1Length=text1.length;text2Length=text2.length;maxD=Math.ceil((text1Length+text2Length)/2);vOffset=maxD;vLength=2*maxD;v1=new Array(vLength);v2=new Array(vLength);// Setting all elements to -1 is faster in Chrome & Firefox than mixing\n// integers and undefined.\nfor(x=0;x<vLength;x++){v1[x]=-1;v2[x]=-1;}v1[vOffset+1]=0;v2[vOffset+1]=0;delta=text1Length-text2Length;// If the total number of characters is odd, then the front path will collide\n// with the reverse path.\nfront=delta%2!==0;// Offsets for start and end of k loop.\n// Prevents mapping of space beyond the grid.\nk1start=0;k1end=0;k2start=0;k2end=0;for(d=0;d<maxD;d++){// Bail out if deadline is reached.\nif(Date.now()>deadline){break;}// Walk the front path one step.\nfor(k1=-d+k1start;k1<=d-k1end;k1+=2){k1Offset=vOffset+k1;if(k1===-d||k1!==d&&v1[k1Offset-1]<v1[k1Offset+1]){x1=v1[k1Offset+1];}else{x1=v1[k1Offset-1]+1;}y1=x1-k1;while(x1<text1Length&&y1<text2Length&&text1.charAt(x1)===text2.charAt(y1)){x1++;y1++;}v1[k1Offset]=x1;if(x1>text1Length){// Ran off the right of the graph.\nk1end+=2;}else if(y1>text2Length){// Ran off the bottom of the graph.\nk1start+=2;}else if(front){k2Offset=vOffset+delta-k1;if(k2Offset>=0&&k2Offset<vLength&&v2[k2Offset]!==-1){// Mirror x2 onto top-left coordinate system.\nx2=text1Length-v2[k2Offset];if(x1>=x2){// Overlap detected.\nreturn this.diffBisectSplit(text1,text2,x1,y1,deadline);}}}}// Walk the reverse path one step.\nfor(k2=-d+k2start;k2<=d-k2end;k2+=2){k2Offset=vOffset+k2;if(k2===-d||k2!==d&&v2[k2Offset-1]<v2[k2Offset+1]){x2=v2[k2Offset+1];}else{x2=v2[k2Offset-1]+1;}y2=x2-k2;while(x2<text1Length&&y2<text2Length&&text1.charAt(text1Length-x2-1)===text2.charAt(text2Length-y2-1)){x2++;y2++;}v2[k2Offset]=x2;if(x2>text1Length){// Ran off the left of the graph.\nk2end+=2;}else if(y2>text2Length){// Ran off the top of the graph.\nk2start+=2;}else if(!front){k1Offset=vOffset+delta-k2;if(k1Offset>=0&&k1Offset<vLength&&v1[k1Offset]!==-1){x1=v1[k1Offset];y1=vOffset+x1-k1Offset;// Mirror x2 onto top-left coordinate system.\nx2=text1Length-x2;if(x1>=x2){// Overlap detected.\nreturn this.diffBisectSplit(text1,text2,x1,y1,deadline);}}}}}// Diff took too long and hit the deadline or\n// number of diffs equals number of characters, no commonality at all.\nreturn[[DIFF_DELETE,text1],[DIFF_INSERT,text2]];};/**\n   * Given the location of the 'middle snake', split the diff in two parts\n   * and recurse.\n   * @param {string} text1 Old string to be diffed.\n   * @param {string} text2 New string to be diffed.\n   * @param {number} x Index of split point in text1.\n   * @param {number} y Index of split point in text2.\n   * @param {number} deadline Time at which to bail if not yet complete.\n   * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n   * @private\n   */DiffMatchPatch.prototype.diffBisectSplit=function(text1,text2,x,y,deadline){var text1a,text1b,text2a,text2b,diffs,diffsb;text1a=text1.substring(0,x);text2a=text2.substring(0,y);text1b=text1.substring(x);text2b=text2.substring(y);// Compute both diffs serially.\ndiffs=this.DiffMain(text1a,text2a,false,deadline);diffsb=this.DiffMain(text1b,text2b,false,deadline);return diffs.concat(diffsb);};/**\n   * Reduce the number of edits by eliminating semantically trivial equalities.\n   * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n   */DiffMatchPatch.prototype.diffCleanupSemantic=function(diffs){var changes=false;var equalities=[];// Stack of indices where equalities are found.\nvar equalitiesLength=0;// Keeping our own length var is faster in JS.\n/** @type {?string} */var lastequality=null;// Always equal to diffs[equalities[equalitiesLength - 1]][1]\nvar pointer=0;// Index of current position.\n// Number of characters that changed prior to the equality.\nvar lengthInsertions1=0;var lengthDeletions1=0;// Number of characters that changed after the equality.\nvar lengthInsertions2=0;var lengthDeletions2=0;while(pointer<diffs.length){if(diffs[pointer][0]===DIFF_EQUAL){// Equality found.\nequalities[equalitiesLength++]=pointer;lengthInsertions1=lengthInsertions2;lengthDeletions1=lengthDeletions2;lengthInsertions2=0;lengthDeletions2=0;lastequality=diffs[pointer][1];}else{// An insertion or deletion.\nif(diffs[pointer][0]===DIFF_INSERT){lengthInsertions2+=diffs[pointer][1].length;}else{lengthDeletions2+=diffs[pointer][1].length;}// Eliminate an equality that is smaller or equal to the edits on both\n// sides of it.\nif(lastequality&&lastequality.length<=Math.max(lengthInsertions1,lengthDeletions1)&&lastequality.length<=Math.max(lengthInsertions2,lengthDeletions2)){// Duplicate record.\ndiffs.splice(equalities[equalitiesLength-1],0,[DIFF_DELETE,lastequality]);// Change second copy to insert.\ndiffs[equalities[equalitiesLength-1]+1][0]=DIFF_INSERT;// Throw away the equality we just deleted.\nequalitiesLength--;// Throw away the previous equality (it needs to be reevaluated).\nequalitiesLength--;pointer=equalitiesLength>0?equalities[equalitiesLength-1]:-1;// Reset the counters.\nlengthInsertions1=0;lengthDeletions1=0;lengthInsertions2=0;lengthDeletions2=0;lastequality=null;changes=true;}}pointer++;}// Normalize the diff.\nif(changes){this.diffCleanupMerge(diffs);}var deletion,insertion,overlapLength1,overlapLength2;// Find any overlaps between deletions and insertions.\n// e.g: <del>abcxxx</del><ins>xxxdef</ins>\n//   -> <del>abc</del>xxx<ins>def</ins>\n// e.g: <del>xxxabc</del><ins>defxxx</ins>\n//   -> <ins>def</ins>xxx<del>abc</del>\n// Only extract an overlap if it is as big as the edit ahead or behind it.\npointer=1;while(pointer<diffs.length){if(diffs[pointer-1][0]===DIFF_DELETE&&diffs[pointer][0]===DIFF_INSERT){deletion=diffs[pointer-1][1];insertion=diffs[pointer][1];overlapLength1=this.diffCommonOverlap(deletion,insertion);overlapLength2=this.diffCommonOverlap(insertion,deletion);if(overlapLength1>=overlapLength2){if(overlapLength1>=deletion.length/2||overlapLength1>=insertion.length/2){// Overlap found.  Insert an equality and trim the surrounding edits.\ndiffs.splice(pointer,0,[DIFF_EQUAL,insertion.substring(0,overlapLength1)]);diffs[pointer-1][1]=deletion.substring(0,deletion.length-overlapLength1);diffs[pointer+1][1]=insertion.substring(overlapLength1);pointer++;}}else{if(overlapLength2>=deletion.length/2||overlapLength2>=insertion.length/2){// Reverse overlap found.\n// Insert an equality and swap and trim the surrounding edits.\ndiffs.splice(pointer,0,[DIFF_EQUAL,deletion.substring(0,overlapLength2)]);diffs[pointer-1][0]=DIFF_INSERT;diffs[pointer-1][1]=insertion.substring(0,insertion.length-overlapLength2);diffs[pointer+1][0]=DIFF_DELETE;diffs[pointer+1][1]=deletion.substring(overlapLength2);pointer++;}}pointer++;}pointer++;}};/**\n   * Determine if the suffix of one string is the prefix of another.\n   * @param {string} text1 First string.\n   * @param {string} text2 Second string.\n   * @return {number} The number of characters common to the end of the first\n   *     string and the start of the second string.\n   * @private\n   */DiffMatchPatch.prototype.diffCommonOverlap=function(text1,text2){// Cache the text lengths to prevent multiple calls.\nvar text1Length=text1.length;var text2Length=text2.length;// Eliminate the null case.\nif(text1Length===0||text2Length===0){return 0;}// Truncate the longer string.\nif(text1Length>text2Length){text1=text1.substring(text1Length-text2Length);}else if(text1Length<text2Length){text2=text2.substring(0,text1Length);}var textLength=Math.min(text1Length,text2Length);// Quick check for the worst case.\nif(text1===text2){return textLength;}// Start by looking for a single character match\n// and increase length until no match is found.\n// Performance analysis: https://neil.fraser.name/news/2010/11/04/\nvar best=0;var length=1;while(true){var pattern=text1.substring(textLength-length);var found=text2.indexOf(pattern);if(found===-1){return best;}length+=found;if(found===0||text1.substring(textLength-length)===text2.substring(0,length)){best=length;length++;}}};/**\n   * Split two texts into an array of strings.  Reduce the texts to a string of\n   * hashes where each Unicode character represents one line.\n   * @param {string} text1 First string.\n   * @param {string} text2 Second string.\n   * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n   *     An object containing the encoded text1, the encoded text2 and\n   *     the array of unique strings.\n   *     The zeroth element of the array of unique strings is intentionally blank.\n   * @private\n   */DiffMatchPatch.prototype.diffLinesToChars=function(text1,text2){var lineArray=[];// E.g. lineArray[4] === 'Hello\\n'\nvar lineHash={};// E.g. lineHash['Hello\\n'] === 4\n// '\\x00' is a valid character, but various debuggers don't like it.\n// So we'll insert a junk entry to avoid generating a null character.\nlineArray[0]='';/**\n     * Split a text into an array of strings.  Reduce the texts to a string of\n     * hashes where each Unicode character represents one line.\n     * Modifies linearray and linehash through being a closure.\n     * @param {string} text String to encode.\n     * @return {string} Encoded string.\n     * @private\n     */function diffLinesToCharsMunge(text){var chars='';// Walk the text, pulling out a substring for each line.\n// text.split('\\n') would would temporarily double our memory footprint.\n// Modifying text would create many large strings to garbage collect.\nvar lineStart=0;var lineEnd=-1;// Keeping our own length variable is faster than looking it up.\nvar lineArrayLength=lineArray.length;while(lineEnd<text.length-1){lineEnd=text.indexOf('\\n',lineStart);if(lineEnd===-1){lineEnd=text.length-1;}var line=text.substring(lineStart,lineEnd+1);lineStart=lineEnd+1;if(hasOwn.call(lineHash,line)){chars+=String.fromCharCode(lineHash[line]);}else{chars+=String.fromCharCode(lineArrayLength);lineHash[line]=lineArrayLength;lineArray[lineArrayLength++]=line;}}return chars;}var chars1=diffLinesToCharsMunge(text1);var chars2=diffLinesToCharsMunge(text2);return{chars1:chars1,chars2:chars2,lineArray:lineArray};};/**\n   * Rehydrate the text in a diff from a string of line hashes to real lines of\n   * text.\n   * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n   * @param {!Array.<string>} lineArray Array of unique strings.\n   * @private\n   */DiffMatchPatch.prototype.diffCharsToLines=function(diffs,lineArray){for(var x=0;x<diffs.length;x++){var chars=diffs[x][1];var text=[];for(var y=0;y<chars.length;y++){text[y]=lineArray[chars.charCodeAt(y)];}diffs[x][1]=text.join('');}};/**\n   * Reorder and merge like edit sections.  Merge equalities.\n   * Any edit section can move as long as it doesn't cross an equality.\n   * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n   */DiffMatchPatch.prototype.diffCleanupMerge=function(diffs){diffs.push([DIFF_EQUAL,'']);// Add a dummy entry at the end.\nvar pointer=0;var countDelete=0;var countInsert=0;var textDelete='';var textInsert='';while(pointer<diffs.length){switch(diffs[pointer][0]){case DIFF_INSERT:countInsert++;textInsert+=diffs[pointer][1];pointer++;break;case DIFF_DELETE:countDelete++;textDelete+=diffs[pointer][1];pointer++;break;case DIFF_EQUAL:// Upon reaching an equality, check for prior redundancies.\nif(countDelete+countInsert>1){if(countDelete!==0&&countInsert!==0){// Factor out any common prefixes.\nvar commonlength=this.diffCommonPrefix(textInsert,textDelete);if(commonlength!==0){if(pointer-countDelete-countInsert>0&&diffs[pointer-countDelete-countInsert-1][0]===DIFF_EQUAL){diffs[pointer-countDelete-countInsert-1][1]+=textInsert.substring(0,commonlength);}else{diffs.splice(0,0,[DIFF_EQUAL,textInsert.substring(0,commonlength)]);pointer++;}textInsert=textInsert.substring(commonlength);textDelete=textDelete.substring(commonlength);}// Factor out any common suffixies.\ncommonlength=this.diffCommonSuffix(textInsert,textDelete);if(commonlength!==0){diffs[pointer][1]=textInsert.substring(textInsert.length-commonlength)+diffs[pointer][1];textInsert=textInsert.substring(0,textInsert.length-commonlength);textDelete=textDelete.substring(0,textDelete.length-commonlength);}}// Delete the offending records and add the merged ones.\nif(countDelete===0){diffs.splice(pointer-countInsert,countDelete+countInsert,[DIFF_INSERT,textInsert]);}else if(countInsert===0){diffs.splice(pointer-countDelete,countDelete+countInsert,[DIFF_DELETE,textDelete]);}else{diffs.splice(pointer-countDelete-countInsert,countDelete+countInsert,[DIFF_DELETE,textDelete],[DIFF_INSERT,textInsert]);}pointer=pointer-countDelete-countInsert+(countDelete?1:0)+(countInsert?1:0)+1;}else if(pointer!==0&&diffs[pointer-1][0]===DIFF_EQUAL){// Merge this equality with the previous one.\ndiffs[pointer-1][1]+=diffs[pointer][1];diffs.splice(pointer,1);}else{pointer++;}countInsert=0;countDelete=0;textDelete='';textInsert='';break;}}if(diffs[diffs.length-1][1]===''){diffs.pop();// Remove the dummy entry at the end.\n}// Second pass: look for single edits surrounded on both sides by equalities\n// which can be shifted sideways to eliminate an equality.\n// e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\nvar changes=false;pointer=1;// Intentionally ignore the first and last element (don't need checking).\nwhile(pointer<diffs.length-1){if(diffs[pointer-1][0]===DIFF_EQUAL&&diffs[pointer+1][0]===DIFF_EQUAL){var diffPointer=diffs[pointer][1];var position=diffPointer.substring(diffPointer.length-diffs[pointer-1][1].length);// This is a single edit surrounded by equalities.\nif(position===diffs[pointer-1][1]){// Shift the edit over the previous equality.\ndiffs[pointer][1]=diffs[pointer-1][1]+diffs[pointer][1].substring(0,diffs[pointer][1].length-diffs[pointer-1][1].length);diffs[pointer+1][1]=diffs[pointer-1][1]+diffs[pointer+1][1];diffs.splice(pointer-1,1);changes=true;}else if(diffPointer.substring(0,diffs[pointer+1][1].length)===diffs[pointer+1][1]){// Shift the edit over the next equality.\ndiffs[pointer-1][1]+=diffs[pointer+1][1];diffs[pointer][1]=diffs[pointer][1].substring(diffs[pointer+1][1].length)+diffs[pointer+1][1];diffs.splice(pointer+1,1);changes=true;}}pointer++;}// If shifts were made, the diff needs reordering and another shift sweep.\nif(changes){this.diffCleanupMerge(diffs);}};function diff(o,n){var diff,output,text;diff=new DiffMatchPatch();output=diff.DiffMain(o,n);diff.diffCleanupEfficiency(output);text=diff.diffPrettyHtml(output);return text;}var QUnit={};// The \"currentModule\" object would ideally be defined using the createModule()\n// function. Since it isn't, add the missing suiteReport property to it now that\n// we have loaded all source code required to do so.\n//\n// TODO: Consider defining currentModule in core.js or module.js in its entirely\n// rather than partly in config.js and partly here.\nconfig.currentModule.suiteReport=runSuite;config.pq=new ProcessingQueue(test);var globalStartCalled=false;var runStarted=false;// Figure out if we're running the tests from a server or not\nQUnit.isLocal=window$1&&window$1.location&&window$1.location.protocol==='file:';// Expose the current QUnit version\nQUnit.version='2.22.0';extend(QUnit,{config:config,diff:diff,dump:dump,equiv:equiv,reporters:reporters,hooks:hooks,is:is,objectType:objectType,on:on,onError:onWindowError,onUncaughtException:onUncaughtException,pushFailure:pushFailure,assert:Assert.prototype,module:module$1,test:test,// alias other test flavors for easy access\ntodo:test.todo,skip:test.skip,only:test.only,start:function start(count){if(config.current){throw new Error('QUnit.start cannot be called inside a test context.');}var globalStartAlreadyCalled=globalStartCalled;globalStartCalled=true;if(runStarted){throw new Error('Called start() while test already started running');}if(globalStartAlreadyCalled||count>1){throw new Error('Called start() outside of a test context too many times');}if(config.autostart){throw new Error('Called start() outside of a test context when '+'QUnit.config.autostart was true');}// Until we remove QUnit.load() in QUnit 3, we keep `pageLoaded`.\n// It no longer serves any purpose other than to support old test runners\n// that still call only QUnit.load(), or that call both it and QUnit.start().\nif(!config.pageLoaded){// If the test runner used `autostart = false` and is calling QUnit.start()\n// to tell is their resources are ready, but the browser isn't ready yet,\n// then enable autostart now, and we'll let the tests really start after\n// the browser's \"load\" event handler calls autostart().\nconfig.autostart=true;// If we're in Node or another non-browser environment, we start now as there\n// won't be any \"load\" event. We return early either way since autostart\n// is responsible for calling scheduleBegin (avoid \"beginning\" twice).\nif(!document){QUnit.autostart();}return;}scheduleBegin();},onUnhandledRejection:function onUnhandledRejection(reason){Logger.warn('QUnit.onUnhandledRejection is deprecated and will be removed in QUnit 3.0.'+' Please use QUnit.onUncaughtException instead.');onUncaughtException(reason);},extend:function extend$1(){Logger.warn('QUnit.extend is deprecated and will be removed in QUnit 3.0.'+' Please use Object.assign instead.');// delegate to utility implementation, which does not warn and can be used elsewhere internally\nfor(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}return extend.apply(this,args);},load:function load(){Logger.warn('QUnit.load is deprecated and will be removed in QUnit 3.0.'+' https://qunitjs.com/api/QUnit/load/');QUnit.autostart();},/**\n     * @internal\n     */autostart:function autostart(){config.pageLoaded=true;// Initialize the configuration options\n// TODO: Move this to config.js in QUnit 3.\nextend(config,{started:0,updateRate:1000,autostart:true,filter:''},true);if(!runStarted){config.blocking=false;if(config.autostart){scheduleBegin();}}},stack:function stack(offset){offset=(offset||0)+2;// Support Safari: Use temp variable to avoid TCO for consistent cross-browser result\n// https://bugs.webkit.org/show_bug.cgi?id=276187\nvar source=sourceFromStacktrace(offset);return source;}});registerLoggingCallbacks(QUnit);function scheduleBegin(){runStarted=true;// Add a slight delay to allow definition of more modules and tests.\nif(setTimeout$1){setTimeout$1(function(){begin();});}else{begin();}}function unblockAndAdvanceQueue(){config.blocking=false;config.pq.advance();}function begin(){if(config.started){unblockAndAdvanceQueue();return;}// The test run hasn't officially begun yet\n// Record the time of the test run's beginning\nconfig.started=performance.now();// Delete the loose unnamed module if unused.\nif(config.modules[0].name===''&&config.modules[0].tests.length===0){config.modules.shift();}var modulesLog=[];for(var i=0;i<config.modules.length;i++){// Don't expose the unnamed global test module to plugins.\nif(config.modules[i].name!==''){modulesLog.push({name:config.modules[i].name,moduleId:config.modules[i].moduleId,// Added in QUnit 1.16.0 for internal use by html-reporter,\n// but no longer used since QUnit 2.7.0.\n// @deprecated Kept unofficially to be removed in QUnit 3.0.\ntests:config.modules[i].tests});}}// The test run is officially beginning now\nemit('runStart',runSuite.start(true));runLoggingCallbacks('begin',{totalTests:Test.count,modules:modulesLog}).then(unblockAndAdvanceQueue);}exportQUnit(QUnit);(function(){if(!window$1||!document){return;}var config=QUnit.config;var hasOwn=Object.prototype.hasOwnProperty;// Stores fixture HTML for resetting later\nfunction storeFixture(){// Avoid overwriting user-defined values\n// TODO: Change to negative null/undefined check once declared in /src/config.js\nif(hasOwn.call(config,'fixture')){return;}var fixture=document.getElementById('qunit-fixture');if(fixture){config.fixture=fixture.cloneNode(true);}}QUnit.begin(storeFixture);// Resets the fixture DOM element if available.\nfunction resetFixture(){if(config.fixture==null){return;}var fixture=document.getElementById('qunit-fixture');var resetFixtureType=_typeof(config.fixture);if(resetFixtureType==='string'){// support user defined values for `config.fixture`\nvar newFixture=document.createElement('div');newFixture.setAttribute('id','qunit-fixture');newFixture.innerHTML=config.fixture;fixture.parentNode.replaceChild(newFixture,fixture);}else{var clonedFixture=config.fixture.cloneNode(true);fixture.parentNode.replaceChild(clonedFixture,fixture);}}QUnit.testStart(resetFixture);})();(function(){// Only interact with URLs via window.location\nvar location=typeof window$1!=='undefined'&&window$1.location;if(!location){return;}var urlParams=getUrlParams();// TODO: Move to /src/core/ in QUnit 3\n// TODO: Document this as public API (read-only)\nQUnit.urlParams=urlParams;// TODO: Move to /src/core/config.js in QUnit 3,\n// in accordance with /docs/api/config.index.md#order\nQUnit.config.filter=urlParams.filter;QUnit.config.module=urlParams.module;QUnit.config.moduleId=[].concat(urlParams.moduleId||[]);QUnit.config.testId=[].concat(urlParams.testId||[]);// Test order randomization\nif(urlParams.seed===true){// Generate a random seed if the option is specified without a value\nQUnit.config.seed=Math.random().toString(36).slice(2);}else if(urlParams.seed){QUnit.config.seed=urlParams.seed;}// Add URL-parameter-mapped config values with UI form rendering data\nQUnit.config.urlConfig.push({id:'hidepassed',label:'Hide passed tests',tooltip:'Only show tests and assertions that fail. Stored as query-strings.'},{id:'noglobals',label:'Check for Globals',tooltip:'Enabling this will test if any test introduces new properties on the '+'global object (`window` in Browsers). Stored as query-strings.'},{id:'notrycatch',label:'No try-catch',tooltip:'Enabling this will run tests outside of a try-catch block. Makes debugging '+'exceptions in IE reasonable. Stored as query-strings.'});QUnit.begin(function(){var urlConfig=QUnit.config.urlConfig;for(var i=0;i<urlConfig.length;i++){// Options can be either strings or objects with nonempty \"id\" properties\nvar option=QUnit.config.urlConfig[i];if(typeof option!=='string'){option=option.id;}if(QUnit.config[option]===undefined){QUnit.config[option]=urlParams[option];}}});function getUrlParams(){var urlParams=Object.create(null);var params=location.search.slice(1).split('&');var length=params.length;for(var i=0;i<length;i++){if(params[i]){var param=params[i].split('=');var name=decodeQueryParam(param[0]);// Allow just a key to turn on a flag, e.g., test.html?noglobals\nvar value=param.length===1||decodeQueryParam(param.slice(1).join('='));if(name in urlParams){urlParams[name]=[].concat(urlParams[name],value);}else{urlParams[name]=value;}}}return urlParams;}function decodeQueryParam(param){return decodeURIComponent(param.replace(/\\+/g,'%20'));}})();var fuzzysort$1={exports:{}};(function(module){(function(root,UMD){if(module.exports)module.exports=UMD();else root.fuzzysort=UMD();})(commonjsGlobal,function UMD(){function fuzzysortNew(instanceOptions){var fuzzysort={single:function single(search,target,options){if(search=='farzher')return{target:\"farzher was here (^-^*)/\",score:0,indexes:[0,1,2,3,4,5,6]};if(!search)return null;if(!isObj(search))search=fuzzysort.getPreparedSearch(search);if(!target)return null;if(!isObj(target))target=fuzzysort.getPrepared(target);var allowTypo=options&&options.allowTypo!==undefined?options.allowTypo:instanceOptions&&instanceOptions.allowTypo!==undefined?instanceOptions.allowTypo:true;var algorithm=allowTypo?fuzzysort.algorithm:fuzzysort.algorithmNoTypo;return algorithm(search,target,search[0]);},go:function go(search,targets,options){if(search=='farzher')return[{target:\"farzher was here (^-^*)/\",score:0,indexes:[0,1,2,3,4,5,6],obj:targets?targets[0]:null}];if(!search)return noResults;search=fuzzysort.prepareSearch(search);var searchLowerCode=search[0];var threshold=options&&options.threshold||instanceOptions&&instanceOptions.threshold||-9007199254740991;var limit=options&&options.limit||instanceOptions&&instanceOptions.limit||9007199254740991;var allowTypo=options&&options.allowTypo!==undefined?options.allowTypo:instanceOptions&&instanceOptions.allowTypo!==undefined?instanceOptions.allowTypo:true;var algorithm=allowTypo?fuzzysort.algorithm:fuzzysort.algorithmNoTypo;var resultsLen=0;var limitedCount=0;var targetsLen=targets.length;// This code is copy/pasted 3 times for performance reasons [options.keys, options.key, no keys]\n// options.keys\nif(options&&options.keys){var scoreFn=options.scoreFn||defaultScoreFn;var keys=options.keys;var keysLen=keys.length;for(var i=targetsLen-1;i>=0;--i){var obj=targets[i];var objResults=new Array(keysLen);for(var keyI=keysLen-1;keyI>=0;--keyI){var key=keys[keyI];var target=getValue(obj,key);if(!target){objResults[keyI]=null;continue;}if(!isObj(target))target=fuzzysort.getPrepared(target);objResults[keyI]=algorithm(search,target,searchLowerCode);}objResults.obj=obj;// before scoreFn so scoreFn can use it\nvar score=scoreFn(objResults);if(score===null)continue;if(score<threshold)continue;objResults.score=score;if(resultsLen<limit){q.add(objResults);++resultsLen;}else{++limitedCount;if(score>q.peek().score)q.replaceTop(objResults);}}// options.key\n}else if(options&&options.key){var key=options.key;for(var i=targetsLen-1;i>=0;--i){var obj=targets[i];var target=getValue(obj,key);if(!target)continue;if(!isObj(target))target=fuzzysort.getPrepared(target);var result=algorithm(search,target,searchLowerCode);if(result===null)continue;if(result.score<threshold)continue;// have to clone result so duplicate targets from different obj can each reference the correct obj\nresult={target:result.target,_targetLowerCodes:null,_nextBeginningIndexes:null,score:result.score,indexes:result.indexes,obj:obj};// hidden\nif(resultsLen<limit){q.add(result);++resultsLen;}else{++limitedCount;if(result.score>q.peek().score)q.replaceTop(result);}}// no keys\n}else{for(var i=targetsLen-1;i>=0;--i){var target=targets[i];if(!target)continue;if(!isObj(target))target=fuzzysort.getPrepared(target);var result=algorithm(search,target,searchLowerCode);if(result===null)continue;if(result.score<threshold)continue;if(resultsLen<limit){q.add(result);++resultsLen;}else{++limitedCount;if(result.score>q.peek().score)q.replaceTop(result);}}}if(resultsLen===0)return noResults;var results=new Array(resultsLen);for(var i=resultsLen-1;i>=0;--i)results[i]=q.poll();results.total=resultsLen+limitedCount;return results;},goAsync:function goAsync(search,targets,options){var canceled=false;var p=new Promise(function(resolve,reject){if(search=='farzher')return resolve([{target:\"farzher was here (^-^*)/\",score:0,indexes:[0,1,2,3,4,5,6],obj:targets?targets[0]:null}]);if(!search)return resolve(noResults);search=fuzzysort.prepareSearch(search);var searchLowerCode=search[0];var q=fastpriorityqueue();var iCurrent=targets.length-1;var threshold=options&&options.threshold||instanceOptions&&instanceOptions.threshold||-9007199254740991;var limit=options&&options.limit||instanceOptions&&instanceOptions.limit||9007199254740991;var allowTypo=options&&options.allowTypo!==undefined?options.allowTypo:instanceOptions&&instanceOptions.allowTypo!==undefined?instanceOptions.allowTypo:true;var algorithm=allowTypo?fuzzysort.algorithm:fuzzysort.algorithmNoTypo;var resultsLen=0;var limitedCount=0;function step(){if(canceled)return reject('canceled');var startMs=Date.now();// This code is copy/pasted 3 times for performance reasons [options.keys, options.key, no keys]\n// options.keys\nif(options&&options.keys){var scoreFn=options.scoreFn||defaultScoreFn;var keys=options.keys;var keysLen=keys.length;for(;iCurrent>=0;--iCurrent){if(iCurrent%1000/*itemsPerCheck*/===0){if(Date.now()-startMs>=10/*asyncInterval*/){isNode?setImmediate(step):setTimeout(step);return;}}var obj=targets[iCurrent];var objResults=new Array(keysLen);for(var keyI=keysLen-1;keyI>=0;--keyI){var key=keys[keyI];var target=getValue(obj,key);if(!target){objResults[keyI]=null;continue;}if(!isObj(target))target=fuzzysort.getPrepared(target);objResults[keyI]=algorithm(search,target,searchLowerCode);}objResults.obj=obj;// before scoreFn so scoreFn can use it\nvar score=scoreFn(objResults);if(score===null)continue;if(score<threshold)continue;objResults.score=score;if(resultsLen<limit){q.add(objResults);++resultsLen;}else{++limitedCount;if(score>q.peek().score)q.replaceTop(objResults);}}// options.key\n}else if(options&&options.key){var key=options.key;for(;iCurrent>=0;--iCurrent){if(iCurrent%1000/*itemsPerCheck*/===0){if(Date.now()-startMs>=10/*asyncInterval*/){isNode?setImmediate(step):setTimeout(step);return;}}var obj=targets[iCurrent];var target=getValue(obj,key);if(!target)continue;if(!isObj(target))target=fuzzysort.getPrepared(target);var result=algorithm(search,target,searchLowerCode);if(result===null)continue;if(result.score<threshold)continue;// have to clone result so duplicate targets from different obj can each reference the correct obj\nresult={target:result.target,_targetLowerCodes:null,_nextBeginningIndexes:null,score:result.score,indexes:result.indexes,obj:obj};// hidden\nif(resultsLen<limit){q.add(result);++resultsLen;}else{++limitedCount;if(result.score>q.peek().score)q.replaceTop(result);}}// no keys\n}else{for(;iCurrent>=0;--iCurrent){if(iCurrent%1000/*itemsPerCheck*/===0){if(Date.now()-startMs>=10/*asyncInterval*/){isNode?setImmediate(step):setTimeout(step);return;}}var target=targets[iCurrent];if(!target)continue;if(!isObj(target))target=fuzzysort.getPrepared(target);var result=algorithm(search,target,searchLowerCode);if(result===null)continue;if(result.score<threshold)continue;if(resultsLen<limit){q.add(result);++resultsLen;}else{++limitedCount;if(result.score>q.peek().score)q.replaceTop(result);}}}if(resultsLen===0)return resolve(noResults);var results=new Array(resultsLen);for(var i=resultsLen-1;i>=0;--i)results[i]=q.poll();results.total=resultsLen+limitedCount;resolve(results);}isNode?setImmediate(step):step();//setTimeout here is too slow\n});p.cancel=function(){canceled=true;};return p;},highlight:function highlight(result,hOpen,hClose){if(typeof hOpen=='function')return fuzzysort.highlightCallback(result,hOpen);if(result===null)return null;if(hOpen===undefined)hOpen='<b>';if(hClose===undefined)hClose='</b>';var highlighted='';var matchesIndex=0;var opened=false;var target=result.target;var targetLen=target.length;var matchesBest=result.indexes;for(var i=0;i<targetLen;++i){var char=target[i];if(matchesBest[matchesIndex]===i){++matchesIndex;if(!opened){opened=true;highlighted+=hOpen;}if(matchesIndex===matchesBest.length){highlighted+=char+hClose+target.substr(i+1);break;}}else{if(opened){opened=false;highlighted+=hClose;}}highlighted+=char;}return highlighted;},highlightCallback:function highlightCallback(result,cb){if(result===null)return null;var target=result.target;var targetLen=target.length;var indexes=result.indexes;var highlighted='';var matchI=0;var indexesI=0;var opened=false;var result=[];for(var i=0;i<targetLen;++i){var char=target[i];if(indexes[indexesI]===i){++indexesI;if(!opened){opened=true;result.push(highlighted);highlighted='';}if(indexesI===indexes.length){highlighted+=char;result.push(cb(highlighted,matchI++));highlighted='';result.push(target.substr(i+1));break;}}else{if(opened){opened=false;result.push(cb(highlighted,matchI++));highlighted='';}}highlighted+=char;}return result;},prepare:function prepare(target){if(!target)return{target:'',_targetLowerCodes:[0/*this 0 doesn't make sense. here because an empty array causes the algorithm to deoptimize and run 50% slower!*/],_nextBeginningIndexes:null,score:null,indexes:null,obj:null};// hidden\nreturn{target:target,_targetLowerCodes:fuzzysort.prepareLowerCodes(target),_nextBeginningIndexes:null,score:null,indexes:null,obj:null};// hidden\n},prepareSlow:function prepareSlow(target){if(!target)return{target:'',_targetLowerCodes:[0/*this 0 doesn't make sense. here because an empty array causes the algorithm to deoptimize and run 50% slower!*/],_nextBeginningIndexes:null,score:null,indexes:null,obj:null};// hidden\nreturn{target:target,_targetLowerCodes:fuzzysort.prepareLowerCodes(target),_nextBeginningIndexes:fuzzysort.prepareNextBeginningIndexes(target),score:null,indexes:null,obj:null};// hidden\n},prepareSearch:function prepareSearch(search){if(!search)search='';return fuzzysort.prepareLowerCodes(search);},// Below this point is only internal code\n// Below this point is only internal code\n// Below this point is only internal code\n// Below this point is only internal code\ngetPrepared:function getPrepared(target){if(target.length>999)return fuzzysort.prepare(target);// don't cache huge targets\nvar targetPrepared=preparedCache.get(target);if(targetPrepared!==undefined)return targetPrepared;targetPrepared=fuzzysort.prepare(target);preparedCache.set(target,targetPrepared);return targetPrepared;},getPreparedSearch:function getPreparedSearch(search){if(search.length>999)return fuzzysort.prepareSearch(search);// don't cache huge searches\nvar searchPrepared=preparedSearchCache.get(search);if(searchPrepared!==undefined)return searchPrepared;searchPrepared=fuzzysort.prepareSearch(search);preparedSearchCache.set(search,searchPrepared);return searchPrepared;},algorithm:function algorithm(searchLowerCodes,prepared,searchLowerCode){var targetLowerCodes=prepared._targetLowerCodes;var searchLen=searchLowerCodes.length;var targetLen=targetLowerCodes.length;var searchI=0;// where we at\nvar targetI=0;// where you at\nvar typoSimpleI=0;var matchesSimpleLen=0;// very basic fuzzy match; to remove non-matching targets ASAP!\n// walk through target. find sequential matches.\n// if all chars aren't found then exit\nfor(;;){var isMatch=searchLowerCode===targetLowerCodes[targetI];if(isMatch){matchesSimple[matchesSimpleLen++]=targetI;++searchI;if(searchI===searchLen)break;searchLowerCode=searchLowerCodes[typoSimpleI===0?searchI:typoSimpleI===searchI?searchI+1:typoSimpleI===searchI-1?searchI-1:searchI];}++targetI;if(targetI>=targetLen){// Failed to find searchI\n// Check for typo or exit\n// we go as far as possible before trying to transpose\n// then we transpose backwards until we reach the beginning\nfor(;;){if(searchI<=1)return null;// not allowed to transpose first char\nif(typoSimpleI===0){// we haven't tried to transpose yet\n--searchI;var searchLowerCodeNew=searchLowerCodes[searchI];if(searchLowerCode===searchLowerCodeNew)continue;// doesn't make sense to transpose a repeat char\ntypoSimpleI=searchI;}else{if(typoSimpleI===1)return null;// reached the end of the line for transposing\n--typoSimpleI;searchI=typoSimpleI;searchLowerCode=searchLowerCodes[searchI+1];var searchLowerCodeNew=searchLowerCodes[searchI];if(searchLowerCode===searchLowerCodeNew)continue;// doesn't make sense to transpose a repeat char\n}matchesSimpleLen=searchI;targetI=matchesSimple[matchesSimpleLen-1]+1;break;}}}var searchI=0;var typoStrictI=0;var successStrict=false;var matchesStrictLen=0;var nextBeginningIndexes=prepared._nextBeginningIndexes;if(nextBeginningIndexes===null)nextBeginningIndexes=prepared._nextBeginningIndexes=fuzzysort.prepareNextBeginningIndexes(prepared.target);var firstPossibleI=targetI=matchesSimple[0]===0?0:nextBeginningIndexes[matchesSimple[0]-1];// Our target string successfully matched all characters in sequence!\n// Let's try a more advanced and strict test to improve the score\n// only count it as a match if it's consecutive or a beginning character!\nif(targetI!==targetLen)for(;;){if(targetI>=targetLen){// We failed to find a good spot for this search char, go back to the previous search char and force it forward\nif(searchI<=0){// We failed to push chars forward for a better match\n// transpose, starting from the beginning\n++typoStrictI;if(typoStrictI>searchLen-2)break;if(searchLowerCodes[typoStrictI]===searchLowerCodes[typoStrictI+1])continue;// doesn't make sense to transpose a repeat char\ntargetI=firstPossibleI;continue;}--searchI;var lastMatch=matchesStrict[--matchesStrictLen];targetI=nextBeginningIndexes[lastMatch];}else{var isMatch=searchLowerCodes[typoStrictI===0?searchI:typoStrictI===searchI?searchI+1:typoStrictI===searchI-1?searchI-1:searchI]===targetLowerCodes[targetI];if(isMatch){matchesStrict[matchesStrictLen++]=targetI;++searchI;if(searchI===searchLen){successStrict=true;break;}++targetI;}else{targetI=nextBeginningIndexes[targetI];}}}{// tally up the score & keep track of matches for highlighting later\nif(successStrict){var matchesBest=matchesStrict;var matchesBestLen=matchesStrictLen;}else{var matchesBest=matchesSimple;var matchesBestLen=matchesSimpleLen;}var score=0;var lastTargetI=-1;for(var i=0;i<searchLen;++i){var targetI=matchesBest[i];// score only goes down if they're not consecutive\nif(lastTargetI!==targetI-1)score-=targetI;lastTargetI=targetI;}if(!successStrict){score*=1000;if(typoSimpleI!==0)score+=-20;/*typoPenalty*/}else{if(typoStrictI!==0)score+=-20;/*typoPenalty*/}score-=targetLen-searchLen;prepared.score=score;prepared.indexes=new Array(matchesBestLen);for(var i=matchesBestLen-1;i>=0;--i)prepared.indexes[i]=matchesBest[i];return prepared;}},algorithmNoTypo:function algorithmNoTypo(searchLowerCodes,prepared,searchLowerCode){var targetLowerCodes=prepared._targetLowerCodes;var searchLen=searchLowerCodes.length;var targetLen=targetLowerCodes.length;var searchI=0;// where we at\nvar targetI=0;// where you at\nvar matchesSimpleLen=0;// very basic fuzzy match; to remove non-matching targets ASAP!\n// walk through target. find sequential matches.\n// if all chars aren't found then exit\nfor(;;){var isMatch=searchLowerCode===targetLowerCodes[targetI];if(isMatch){matchesSimple[matchesSimpleLen++]=targetI;++searchI;if(searchI===searchLen)break;searchLowerCode=searchLowerCodes[searchI];}++targetI;if(targetI>=targetLen)return null;// Failed to find searchI\n}var searchI=0;var successStrict=false;var matchesStrictLen=0;var nextBeginningIndexes=prepared._nextBeginningIndexes;if(nextBeginningIndexes===null)nextBeginningIndexes=prepared._nextBeginningIndexes=fuzzysort.prepareNextBeginningIndexes(prepared.target);targetI=matchesSimple[0]===0?0:nextBeginningIndexes[matchesSimple[0]-1];// Our target string successfully matched all characters in sequence!\n// Let's try a more advanced and strict test to improve the score\n// only count it as a match if it's consecutive or a beginning character!\nif(targetI!==targetLen)for(;;){if(targetI>=targetLen){// We failed to find a good spot for this search char, go back to the previous search char and force it forward\nif(searchI<=0)break;// We failed to push chars forward for a better match\n--searchI;var lastMatch=matchesStrict[--matchesStrictLen];targetI=nextBeginningIndexes[lastMatch];}else{var isMatch=searchLowerCodes[searchI]===targetLowerCodes[targetI];if(isMatch){matchesStrict[matchesStrictLen++]=targetI;++searchI;if(searchI===searchLen){successStrict=true;break;}++targetI;}else{targetI=nextBeginningIndexes[targetI];}}}{// tally up the score & keep track of matches for highlighting later\nif(successStrict){var matchesBest=matchesStrict;var matchesBestLen=matchesStrictLen;}else{var matchesBest=matchesSimple;var matchesBestLen=matchesSimpleLen;}var score=0;var lastTargetI=-1;for(var i=0;i<searchLen;++i){var targetI=matchesBest[i];// score only goes down if they're not consecutive\nif(lastTargetI!==targetI-1)score-=targetI;lastTargetI=targetI;}if(!successStrict)score*=1000;score-=targetLen-searchLen;prepared.score=score;prepared.indexes=new Array(matchesBestLen);for(var i=matchesBestLen-1;i>=0;--i)prepared.indexes[i]=matchesBest[i];return prepared;}},prepareLowerCodes:function prepareLowerCodes(str){var strLen=str.length;var lowerCodes=[];// new Array(strLen)    sparse array is too slow\nvar lower=str.toLowerCase();for(var i=0;i<strLen;++i)lowerCodes[i]=lower.charCodeAt(i);return lowerCodes;},prepareBeginningIndexes:function prepareBeginningIndexes(target){var targetLen=target.length;var beginningIndexes=[];var beginningIndexesLen=0;var wasUpper=false;var wasAlphanum=false;for(var i=0;i<targetLen;++i){var targetCode=target.charCodeAt(i);var isUpper=targetCode>=65&&targetCode<=90;var isAlphanum=isUpper||targetCode>=97&&targetCode<=122||targetCode>=48&&targetCode<=57;var isBeginning=isUpper&&!wasUpper||!wasAlphanum||!isAlphanum;wasUpper=isUpper;wasAlphanum=isAlphanum;if(isBeginning)beginningIndexes[beginningIndexesLen++]=i;}return beginningIndexes;},prepareNextBeginningIndexes:function prepareNextBeginningIndexes(target){var targetLen=target.length;var beginningIndexes=fuzzysort.prepareBeginningIndexes(target);var nextBeginningIndexes=[];// new Array(targetLen)     sparse array is too slow\nvar lastIsBeginning=beginningIndexes[0];var lastIsBeginningI=0;for(var i=0;i<targetLen;++i){if(lastIsBeginning>i){nextBeginningIndexes[i]=lastIsBeginning;}else{lastIsBeginning=beginningIndexes[++lastIsBeginningI];nextBeginningIndexes[i]=lastIsBeginning===undefined?targetLen:lastIsBeginning;}}return nextBeginningIndexes;},cleanup:cleanup,new:fuzzysortNew};return fuzzysort;}// fuzzysortNew\n// This stuff is outside fuzzysortNew, because it's shared with instances of fuzzysort.new()\nvar isNode=typeof commonjsRequire!=='undefined'&&typeof window==='undefined';var MyMap=typeof Map==='function'?Map:function(){var s=Object.create(null);this.get=function(k){return s[k];};this.set=function(k,val){s[k]=val;return this;};this.clear=function(){s=Object.create(null);};};var preparedCache=new MyMap();var preparedSearchCache=new MyMap();var noResults=[];noResults.total=0;var matchesSimple=[];var matchesStrict=[];function cleanup(){preparedCache.clear();preparedSearchCache.clear();matchesSimple=[];matchesStrict=[];}function defaultScoreFn(a){var max=-9007199254740991;for(var i=a.length-1;i>=0;--i){var result=a[i];if(result===null)continue;var score=result.score;if(score>max)max=score;}if(max===-9007199254740991)return null;return max;}// prop = 'key'              2.5ms optimized for this case, seems to be about as fast as direct obj[prop]\n// prop = 'key1.key2'        10ms\n// prop = ['key1', 'key2']   27ms\nfunction getValue(obj,prop){var tmp=obj[prop];if(tmp!==undefined)return tmp;var segs=prop;if(!Array.isArray(prop))segs=prop.split('.');var len=segs.length;var i=-1;while(obj&&++i<len)obj=obj[segs[i]];return obj;}function isObj(x){return _typeof(x)==='object';}// faster as a function\n// Hacked version of https://github.com/lemire/FastPriorityQueue.js\nvar fastpriorityqueue=function fastpriorityqueue(){var r=[],o=0,e={};function n(){for(var e=0,n=r[e],c=1;c<o;){var f=c+1;e=c,f<o&&r[f].score<r[c].score&&(e=f),r[e-1>>1]=r[e],c=1+(e<<1);}for(var a=e-1>>1;e>0&&n.score<r[a].score;a=(e=a)-1>>1)r[e]=r[a];r[e]=n;}return e.add=function(e){var n=o;r[o++]=e;for(var c=n-1>>1;n>0&&e.score<r[c].score;c=(n=c)-1>>1)r[n]=r[c];r[n]=e;},e.poll=function(){if(0!==o){var e=r[0];return r[0]=r[--o],n(),e;}},e.peek=function(e){if(0!==o)return r[0];},e.replaceTop=function(o){r[0]=o,n();},e;};var q=fastpriorityqueue();// reuse this, except for async, it needs to make its own\nreturn fuzzysortNew();});// UMD\n// TODO: (performance) wasm version!?\n// TODO: (performance) threads?\n// TODO: (performance) avoid cache misses\n// TODO: (performance) preparedCache is a memory leak\n// TODO: (like sublime) backslash === forwardslash\n// TODO: (like sublime) spaces: \"a b\" should do 2 searches 1 for a and 1 for b\n// TODO: (scoring) garbage in targets that allows most searches to strict match need a penality\n// TODO: (performance) idk if allowTypo is optimized\n})(fuzzysort$1);var fuzzysort=fuzzysort$1.exports;var stats={failedTests:[],defined:0,completed:0};(function(){// Don't load the HTML Reporter on non-browser environments\nif(!window$1||!document){return;}QUnit.reporters.perf.init(QUnit);var config=QUnit.config;var hiddenTests=[];var collapseNext=false;var hasOwn=Object.prototype.hasOwnProperty;var unfilteredUrl=setUrl({filter:undefined,module:undefined,moduleId:undefined,testId:undefined});var dropdownData=null;function trim(string){if(typeof string.trim==='function'){return string.trim();}else{return string.replace(/^\\s+|\\s+$/g,'');}}function addEvent(elem,type,fn){elem.addEventListener(type,fn,false);}function removeEvent(elem,type,fn){elem.removeEventListener(type,fn,false);}function addEvents(elems,type,fn){var i=elems.length;while(i--){addEvent(elems[i],type,fn);}}function hasClass(elem,name){return(' '+elem.className+' ').indexOf(' '+name+' ')>=0;}function addClass(elem,name){if(!hasClass(elem,name)){elem.className+=(elem.className?' ':'')+name;}}function toggleClass(elem,name,force){if(force||typeof force==='undefined'&&!hasClass(elem,name)){addClass(elem,name);}else{removeClass(elem,name);}}function removeClass(elem,name){var set=' '+elem.className+' ';// Class name may appear multiple times\nwhile(set.indexOf(' '+name+' ')>=0){set=set.replace(' '+name+' ',' ');}// Trim for prettiness\nelem.className=trim(set);}function id(name){return document.getElementById&&document.getElementById(name);}function abortTests(){var abortButton=id('qunit-abort-tests-button');if(abortButton){abortButton.disabled=true;abortButton.innerHTML='Aborting...';}QUnit.config.queue.length=0;return false;}function interceptNavigation(ev){// Trim potential accidental whitespace so that QUnit doesn't throw an error about no tests matching the filter.\nvar filterInputElem=id('qunit-filter-input');filterInputElem.value=trim(filterInputElem.value);applyUrlParams();if(ev&&ev.preventDefault){ev.preventDefault();}return false;}function getUrlConfigHtml(){var selection=false;var urlConfig=config.urlConfig;var urlConfigHtml='';for(var i=0;i<urlConfig.length;i++){// Options can be either strings or objects with nonempty \"id\" properties\nvar val=config.urlConfig[i];if(typeof val==='string'){val={id:val,label:val};}var escaped=escapeText(val.id);var escapedTooltip=escapeText(val.tooltip);if(!val.value||typeof val.value==='string'){urlConfigHtml+=\"<label for='qunit-urlconfig-\"+escaped+\"' title='\"+escapedTooltip+\"'><input id='qunit-urlconfig-\"+escaped+\"' name='\"+escaped+\"' type='checkbox'\"+(val.value?\" value='\"+escapeText(val.value)+\"'\":'')+(config[val.id]?\" checked='checked'\":'')+\" title='\"+escapedTooltip+\"' />\"+escapeText(val.label)+'</label>';}else{urlConfigHtml+=\"<label for='qunit-urlconfig-\"+escaped+\"' title='\"+escapedTooltip+\"'>\"+escapeText(val.label)+\": </label><select id='qunit-urlconfig-\"+escaped+\"' name='\"+escaped+\"' title='\"+escapedTooltip+\"'><option></option>\";if(Array.isArray(val.value)){for(var j=0;j<val.value.length;j++){escaped=escapeText(val.value[j]);urlConfigHtml+=\"<option value='\"+escaped+\"'\"+(config[val.id]===val.value[j]?(selection=true)&&\" selected='selected'\":'')+'>'+escaped+'</option>';}}else{for(var _j in val.value){if(hasOwn.call(val.value,_j)){urlConfigHtml+=\"<option value='\"+escapeText(_j)+\"'\"+(config[val.id]===_j?(selection=true)&&\" selected='selected'\":'')+'>'+escapeText(val.value[_j])+'</option>';}}}if(config[val.id]&&!selection){escaped=escapeText(config[val.id]);urlConfigHtml+=\"<option value='\"+escaped+\"' selected='selected' disabled='disabled'>\"+escaped+'</option>';}urlConfigHtml+='</select>';}}return urlConfigHtml;}// Handle \"click\" events on toolbar checkboxes and \"change\" for select menus.\n// Updates the URL with the new state of `config.urlConfig` values.\nfunction toolbarChanged(){var field=this;var params={};// Detect if field is a select menu or a checkbox\nvar value;if('selectedIndex'in field){value=field.options[field.selectedIndex].value||undefined;}else{value=field.checked?field.defaultValue||true:undefined;}params[field.name]=value;var updatedUrl=setUrl(params);// Check if we can apply the change without a page refresh\nif(field.name==='hidepassed'&&'replaceState'in window$1.history){QUnit.urlParams[field.name]=value;config[field.name]=value||false;var tests=id('qunit-tests');if(tests){var length=tests.children.length;var children=tests.children;if(field.checked){for(var i=0;i<length;i++){var test=children[i];var className=test?test.className:'';var classNameHasPass=className.indexOf('pass')>-1;var classNameHasSkipped=className.indexOf('skipped')>-1;if(classNameHasPass||classNameHasSkipped){hiddenTests.push(test);}}var _iterator=_createForOfIteratorHelper(hiddenTests),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var hiddenTest=_step.value;tests.removeChild(hiddenTest);}}catch(err){_iterator.e(err);}finally{_iterator.f();}}else{while(hiddenTests.length){tests.appendChild(hiddenTests.shift());}}}window$1.history.replaceState(null,'',updatedUrl);}else{window$1.location=updatedUrl;}}function setUrl(params){var querystring='?';var location=window$1.location;params=extend(extend({},QUnit.urlParams),params);for(var key in params){// Skip inherited or undefined properties\nif(hasOwn.call(params,key)&&params[key]!==undefined){// Output a parameter for each value of this key\n// (but usually just one)\nvar arrValue=[].concat(params[key]);for(var i=0;i<arrValue.length;i++){querystring+=encodeURIComponent(key);if(arrValue[i]!==true){querystring+='='+encodeURIComponent(arrValue[i]);}querystring+='&';}}}return location.protocol+'//'+location.host+location.pathname+querystring.slice(0,-1);}function applyUrlParams(){var filter=id('qunit-filter-input').value;window$1.location=setUrl({filter:filter===''?undefined:filter,moduleId:_toConsumableArray(dropdownData.selectedMap.keys()),// Remove module and testId filter\nmodule:undefined,testId:undefined});}function toolbarUrlConfigContainer(){var urlConfigContainer=document.createElement('span');urlConfigContainer.innerHTML=getUrlConfigHtml();addClass(urlConfigContainer,'qunit-url-config');addEvents(urlConfigContainer.getElementsByTagName('input'),'change',toolbarChanged);addEvents(urlConfigContainer.getElementsByTagName('select'),'change',toolbarChanged);return urlConfigContainer;}function abortTestsButton(){var button=document.createElement('button');button.id='qunit-abort-tests-button';button.innerHTML='Abort';addEvent(button,'click',abortTests);return button;}function toolbarLooseFilter(){var filter=document.createElement('form');var label=document.createElement('label');var input=document.createElement('input');var button=document.createElement('button');addClass(filter,'qunit-filter');label.innerHTML='Filter: ';input.type='text';input.value=config.filter||'';input.name='filter';input.id='qunit-filter-input';button.innerHTML='Go';label.appendChild(input);filter.appendChild(label);filter.appendChild(document.createTextNode(' '));filter.appendChild(button);addEvent(filter,'submit',interceptNavigation);return filter;}function createModuleListItem(moduleId,name,checked){return'<li><label class=\"clickable'+(checked?' checked':'')+'\"><input type=\"checkbox\" '+'value=\"'+escapeText(moduleId)+'\"'+(checked?' checked=\"checked\"':'')+' />'+escapeText(name)+'</label></li>';}/**\n     * @param {Array} Results from fuzzysort\n     * @return {string} HTML\n     */function moduleListHtml(results){var html='';// Hoist the already selected items, and show them always\n// even if not matched by the current search.\ndropdownData.selectedMap.forEach(function(name,moduleId){html+=createModuleListItem(moduleId,name,true);});for(var i=0;i<results.length;i++){var mod=results[i].obj;if(!dropdownData.selectedMap.has(mod.moduleId)){html+=createModuleListItem(mod.moduleId,mod.name,false);}}return html;}function toolbarModuleFilter(beginDetails){var initialSelected=null;dropdownData={options:beginDetails.modules.slice(),selectedMap:new StringMap(),isDirty:function isDirty(){return _toConsumableArray(dropdownData.selectedMap.keys()).sort().join(',')!==_toConsumableArray(initialSelected.keys()).sort().join(',');}};if(config.moduleId.length){// The module dropdown is seeded with the runtime configuration of the last run.\n//\n// We don't reference `config.moduleId` directly after this and keep our own\n// copy because:\n// 1. This naturally filters out unknown moduleIds.\n// 2. Gives us a place to manage and remember unsubmitted checkbox changes.\n// 3. Gives us an efficient way to map a selected moduleId to module name\n//    during rendering.\nfor(var i=0;i<beginDetails.modules.length;i++){var mod=beginDetails.modules[i];if(config.moduleId.indexOf(mod.moduleId)!==-1){dropdownData.selectedMap.set(mod.moduleId,mod.name);}}}initialSelected=new StringMap(dropdownData.selectedMap);var moduleSearch=document.createElement('input');moduleSearch.id='qunit-modulefilter-search';moduleSearch.autocomplete='off';addEvent(moduleSearch,'input',searchInput);addEvent(moduleSearch,'input',searchFocus);addEvent(moduleSearch,'focus',searchFocus);addEvent(moduleSearch,'click',searchFocus);var label=document.createElement('label');label.htmlFor='qunit-modulefilter-search';label.textContent='Module:';var searchContainer=document.createElement('span');searchContainer.id='qunit-modulefilter-search-container';searchContainer.appendChild(moduleSearch);var applyButton=document.createElement('button');applyButton.textContent='Apply';applyButton.title='Re-run the selected test modules';addEvent(applyButton,'click',applyUrlParams);var resetButton=document.createElement('button');resetButton.textContent='Reset';resetButton.type='reset';resetButton.title='Restore the previous module selection';var clearButton=document.createElement('button');clearButton.textContent='Select none';clearButton.type='button';clearButton.title='Clear the current module selection';addEvent(clearButton,'click',function(){dropdownData.selectedMap.clear();selectionChange();searchInput();});var actions=document.createElement('span');actions.id='qunit-modulefilter-actions';actions.appendChild(applyButton);actions.appendChild(resetButton);if(initialSelected.size){// Only show clear button if functionally different from reset\nactions.appendChild(clearButton);}var dropDownList=document.createElement('ul');dropDownList.id='qunit-modulefilter-dropdown-list';var dropDown=document.createElement('div');dropDown.id='qunit-modulefilter-dropdown';dropDown.style.display='none';dropDown.appendChild(actions);dropDown.appendChild(dropDownList);addEvent(dropDown,'change',selectionChange);searchContainer.appendChild(dropDown);// Set initial moduleSearch.placeholder and clearButton/resetButton.\nselectionChange();var moduleFilter=document.createElement('form');moduleFilter.id='qunit-modulefilter';moduleFilter.appendChild(label);moduleFilter.appendChild(document.createTextNode(' '));moduleFilter.appendChild(searchContainer);addEvent(moduleFilter,'submit',interceptNavigation);addEvent(moduleFilter,'reset',function(){dropdownData.selectedMap=new StringMap(initialSelected);// Set moduleSearch.placeholder and reflect non-dirty state\nselectionChange();searchInput();});// Enables show/hide for the dropdown\nfunction searchFocus(){if(dropDown.style.display!=='none'){return;}// Optimization: Defer rendering options until focussed.\n// https://github.com/qunitjs/qunit/issues/1664\nsearchInput();dropDown.style.display='block';// Hide on Escape keydown or on click outside the container\naddEvent(document,'click',hideHandler);addEvent(document,'keydown',hideHandler);function hideHandler(e){var inContainer=moduleFilter.contains(e.target);if(e.keyCode===27||!inContainer){if(e.keyCode===27&&inContainer){moduleSearch.focus();}dropDown.style.display='none';removeEvent(document,'click',hideHandler);removeEvent(document,'keydown',hideHandler);moduleSearch.value='';searchInput();}}}/**\n       * @param {string} searchText\n       * @return {string} HTML\n       */function filterModules(searchText){var results;if(searchText===''){// Improve on-boarding experience by having an immediate display of\n// module names, indicating how the interface works. This also makes\n// for a quicker interaction in the common case of small projects.\n// Don't mandate typing just to get the menu.\nresults=dropdownData.options.slice(0,20).map(function(obj){// Fake empty results. https://github.com/farzher/fuzzysort/issues/41\nreturn{obj:obj};});}else{results=fuzzysort.go(searchText,dropdownData.options,{limit:20,key:'name',allowTypo:true});}return moduleListHtml(results);}// Processes module search box input\nvar searchInputTimeout;function searchInput(){// Use a debounce with a ~0ms timeout. This is effectively instantaneous,\n// but is better than undebounced because it avoids an ever-growing\n// backlog of unprocessed now-outdated input events if fuzzysearch or\n// drodown DOM is slow (e.g. very large test suite).\nwindow$1.clearTimeout(searchInputTimeout);searchInputTimeout=window$1.setTimeout(function(){dropDownList.innerHTML=filterModules(moduleSearch.value);});}// Processes checkbox change, or a generic render (initial render, or after reset event)\n// Avoid any dropdown rendering here as this is used by toolbarModuleFilter()\n// during the initial render, which should not delay test execution.\nfunction selectionChange(evt){var checkbox=evt&&evt.target||null;if(checkbox){// Update internal state\nif(checkbox.checked){dropdownData.selectedMap.set(checkbox.value,checkbox.parentNode.textContent);}else{dropdownData.selectedMap.delete(checkbox.value);}// Update UI state\ntoggleClass(checkbox.parentNode,'checked',checkbox.checked);}var textForm=dropdownData.selectedMap.size?dropdownData.selectedMap.size+' '+(dropdownData.selectedMap.size===1?'module':'modules'):'All modules';moduleSearch.placeholder=textForm;moduleSearch.title='Type to search through and reduce the list.';resetButton.disabled=!dropdownData.isDirty();clearButton.style.display=dropdownData.selectedMap.size?'':'none';}return moduleFilter;}function appendToolbar(beginDetails){var toolbar=id('qunit-testrunner-toolbar');if(toolbar){toolbar.appendChild(toolbarUrlConfigContainer());var toolbarFilters=document.createElement('span');toolbarFilters.id='qunit-toolbar-filters';toolbarFilters.appendChild(toolbarLooseFilter());toolbarFilters.appendChild(toolbarModuleFilter(beginDetails));var clearfix=document.createElement('div');clearfix.className='clearfix';toolbar.appendChild(toolbarFilters);toolbar.appendChild(clearfix);}}function appendHeader(){var header=id('qunit-header');if(header){header.innerHTML=\"<a href='\"+escapeText(unfilteredUrl)+\"'>\"+header.innerHTML+'</a> ';}}function appendBanner(){var banner=id('qunit-banner');if(banner){banner.className='';}}function appendTestResults(){var tests=id('qunit-tests');var result=id('qunit-testresult');var controls;if(result){result.parentNode.removeChild(result);}if(tests){tests.innerHTML='';result=document.createElement('p');result.id='qunit-testresult';result.className='result';tests.parentNode.insertBefore(result,tests);result.innerHTML='<div id=\"qunit-testresult-display\">Running...<br />&#160;</div>'+'<div id=\"qunit-testresult-controls\"></div>'+'<div class=\"clearfix\"></div>';controls=id('qunit-testresult-controls');}if(controls){controls.appendChild(abortTestsButton());}}function appendFilteredTest(){var testId=QUnit.config.testId;if(!testId||testId.length<=0){return'';}return\"<div id='qunit-filteredTest'>Rerunning selected tests: \"+escapeText(testId.join(', '))+\" <a id='qunit-clearFilter' href='\"+escapeText(unfilteredUrl)+\"'>Run all tests</a></div>\";}function appendUserAgent(){var userAgent=id('qunit-userAgent');if(userAgent){userAgent.innerHTML='';userAgent.appendChild(document.createTextNode('QUnit '+QUnit.version+'; '+navigator.userAgent));}}function appendInterface(beginDetails){var qunit=id('qunit');// For compat with QUnit 1.2, and to support fully custom theme HTML,\n// we will use any existing elements if no id=\"qunit\" element exists.\n//\n// Note that we don't fail or fallback to creating it ourselves,\n// because not having id=\"qunit\" (and not having the below elements)\n// simply means QUnit acts headless, allowing users to use their own\n// reporters, or for a test runner to listen for events directly without\n// having the HTML reporter actively render anything.\nif(qunit){qunit.setAttribute('role','main');// Since QUnit 1.3, these are created automatically if the page\n// contains id=\"qunit\".\nqunit.innerHTML=\"<h1 id='qunit-header'>\"+escapeText(document.title)+'</h1>'+\"<h2 id='qunit-banner'></h2>\"+\"<div id='qunit-testrunner-toolbar' role='navigation'></div>\"+appendFilteredTest()+\"<h2 id='qunit-userAgent'></h2>\"+\"<ol id='qunit-tests'></ol>\";}appendHeader();appendBanner();appendTestResults();appendUserAgent();appendToolbar(beginDetails);}function appendTest(name,testId,moduleName){var tests=id('qunit-tests');if(!tests){return;}var title=document.createElement('strong');title.innerHTML=getNameHtml(name,moduleName);var testBlock=document.createElement('li');testBlock.appendChild(title);// No ID or rerun link for \"global failure\" blocks\nif(testId!==undefined){var rerunTrigger=document.createElement('a');rerunTrigger.innerHTML='Rerun';rerunTrigger.href=setUrl({testId:testId});testBlock.id='qunit-test-output-'+testId;testBlock.appendChild(rerunTrigger);}var assertList=document.createElement('ol');assertList.className='qunit-assert-list';testBlock.appendChild(assertList);tests.appendChild(testBlock);return testBlock;}// HTML Reporter initialization and load\nQUnit.on('runStart',function(runStart){stats.defined=runStart.testCounts.total;});QUnit.begin(function(beginDetails){// Initialize QUnit elements\n// This is done from begin() instead of runStart, because\n// urlparams.js uses begin(), which we need to wait for.\n// urlparams.js in turn uses begin() to allow plugins to\n// add entries to QUnit.config.urlConfig, which may be done\n// asynchronously.\n// <https://github.com/qunitjs/qunit/issues/1657>\nappendInterface(beginDetails);});function getRerunFailedHtml(failedTests){if(failedTests.length===0){return'';}var href=setUrl({testId:failedTests});return[\"<br /><a href='\"+escapeText(href)+\"'>\",failedTests.length===1?'Rerun 1 failed test':'Rerun '+failedTests.length+' failed tests','</a>'].join('');}QUnit.on('runEnd',function(runEnd){var banner=id('qunit-banner');var tests=id('qunit-tests');var abortButton=id('qunit-abort-tests-button');var assertPassed=config.stats.all-config.stats.bad;var html=[runEnd.testCounts.total,' tests completed in ',runEnd.runtime,' milliseconds, with ',runEnd.testCounts.failed,' failed, ',runEnd.testCounts.skipped,' skipped, and ',runEnd.testCounts.todo,' todo.<br />',\"<span class='passed'>\",assertPassed,\"</span> assertions of <span class='total'>\",config.stats.all,\"</span> passed, <span class='failed'>\",config.stats.bad,'</span> failed.',getRerunFailedHtml(stats.failedTests)].join('');var test;var assertLi;var assertList;// Update remaining tests to aborted\nif(abortButton&&abortButton.disabled){html='Tests aborted after '+runEnd.runtime+' milliseconds.';for(var i=0;i<tests.children.length;i++){test=tests.children[i];if(test.className===''||test.className==='running'){test.className='aborted';assertList=test.getElementsByTagName('ol')[0];assertLi=document.createElement('li');assertLi.className='fail';assertLi.innerHTML='Test aborted.';assertList.appendChild(assertLi);}}}if(banner&&(!abortButton||abortButton.disabled===false)){banner.className=runEnd.status==='failed'?'qunit-fail':'qunit-pass';}if(abortButton){abortButton.parentNode.removeChild(abortButton);}if(tests){id('qunit-testresult-display').innerHTML=html;}if(config.altertitle&&document.title){// Show ✖ for good, ✔ for bad suite result in title\n// use escape sequences in case file gets loaded with non-utf-8\n// charset\ndocument.title=[runEnd.status==='failed'?\"\\u2716\":\"\\u2714\",document.title.replace(/^[\\u2714\\u2716] /i,'')].join(' ');}// Scroll back to top to show results\nif(config.scrolltop&&window$1.scrollTo){window$1.scrollTo(0,0);}});function getNameHtml(name,module){var nameHtml='';if(module){nameHtml=\"<span class='module-name'>\"+escapeText(module)+'</span>: ';}nameHtml+=\"<span class='test-name'>\"+escapeText(name)+'</span>';return nameHtml;}function getProgressHtml(stats){return[stats.completed,' / ',stats.defined,' tests completed.<br />'].join('');}QUnit.testStart(function(details){var running,bad;appendTest(details.name,details.testId,details.module);running=id('qunit-testresult-display');if(running){addClass(running,'running');bad=QUnit.config.reorder&&details.previousFailure;running.innerHTML=[getProgressHtml(stats),bad?'Rerunning previously failed test: <br />':'Running: ',getNameHtml(details.name,details.module),getRerunFailedHtml(stats.failedTests)].join('');}});function stripHtml(string){// Strip tags, html entity and whitespaces\nreturn string.replace(/<\\/?[^>]+(>|$)/g,'').replace(/&quot;/g,'').replace(/\\s+/g,'');}QUnit.log(function(details){var testItem=id('qunit-test-output-'+details.testId);if(!testItem){return;}var message=escapeText(details.message)||(details.result?'okay':'failed');message=\"<span class='test-message'>\"+message+'</span>';message+=\"<span class='runtime'>@ \"+details.runtime+' ms</span>';var expected;var actual;var diff;var showDiff=false;// The pushFailure doesn't provide details.expected\n// when it calls, it's implicit to also not show expected and diff stuff\n// Also, we need to check details.expected existence, as it can exist and be undefined\nif(!details.result&&hasOwn.call(details,'expected')){if(details.negative){expected='NOT '+QUnit.dump.parse(details.expected);}else{expected=QUnit.dump.parse(details.expected);}actual=QUnit.dump.parse(details.actual);message+=\"<table><tr class='test-expected'><th>Expected: </th><td><pre>\"+escapeText(expected)+'</pre></td></tr>';if(actual!==expected){message+=\"<tr class='test-actual'><th>Result: </th><td><pre>\"+escapeText(actual)+'</pre></td></tr>';if(typeof details.actual==='number'&&typeof details.expected==='number'){if(!isNaN(details.actual)&&!isNaN(details.expected)){showDiff=true;diff=details.actual-details.expected;diff=(diff>0?'+':'')+diff;}}else if(typeof details.actual!=='boolean'&&typeof details.expected!=='boolean'){diff=QUnit.diff(expected,actual);// don't show diff if there is zero overlap\nshowDiff=stripHtml(diff).length!==stripHtml(expected).length+stripHtml(actual).length;}if(showDiff){message+=\"<tr class='test-diff'><th>Diff: </th><td><pre>\"+diff+'</pre></td></tr>';}}else if(expected.indexOf('[object Array]')!==-1||expected.indexOf('[object Object]')!==-1){message+=\"<tr class='test-message'><th>Message: </th><td>\"+'Diff suppressed as the depth of object is more than current max depth ('+QUnit.config.maxDepth+').<p>Hint: Use <code>QUnit.dump.maxDepth</code> to '+\" run with a higher max depth or <a href='\"+escapeText(setUrl({maxDepth:-1}))+\"'>\"+'Rerun</a> without max depth.</p></td></tr>';}else{message+=\"<tr class='test-message'><th>Message: </th><td>\"+'Diff suppressed as the expected and actual results have an equivalent'+' serialization</td></tr>';}if(details.source){message+=\"<tr class='test-source'><th>Source: </th><td><pre>\"+escapeText(details.source)+'</pre></td></tr>';}message+='</table>';// This occurs when pushFailure is set and we have an extracted stack trace\n}else if(!details.result&&details.source){message+='<table>'+\"<tr class='test-source'><th>Source: </th><td><pre>\"+escapeText(details.source)+'</pre></td></tr>'+'</table>';}var assertList=testItem.getElementsByTagName('ol')[0];var assertLi=document.createElement('li');assertLi.className=details.result?'pass':'fail';assertLi.innerHTML=message;assertList.appendChild(assertLi);});QUnit.testDone(function(details){var tests=id('qunit-tests');var testItem=id('qunit-test-output-'+details.testId);if(!tests||!testItem){return;}removeClass(testItem,'running');var status;if(details.failed>0){status='failed';}else if(details.todo){status='todo';}else{status=details.skipped?'skipped':'passed';}var assertList=testItem.getElementsByTagName('ol')[0];var good=details.passed;var bad=details.failed;// This test passed if it has no unexpected failed assertions\nvar testPassed=details.failed>0?details.todo:!details.todo;if(testPassed){// Collapse the passing tests\naddClass(assertList,'qunit-collapsed');}else{stats.failedTests.push(details.testId);if(config.collapse){if(!collapseNext){// Skip collapsing the first failing test\ncollapseNext=true;}else{// Collapse remaining tests\naddClass(assertList,'qunit-collapsed');}}}// The testItem.firstChild is the test name\nvar testTitle=testItem.firstChild;var testCounts=bad?\"<b class='failed'>\"+bad+'</b>, '+\"<b class='passed'>\"+good+'</b>, ':'';testTitle.innerHTML+=\" <b class='counts'>(\"+testCounts+details.assertions.length+')</b>';stats.completed++;if(details.skipped){testItem.className='skipped';var skipped=document.createElement('em');skipped.className='qunit-skipped-label';skipped.innerHTML='skipped';testItem.insertBefore(skipped,testTitle);}else{addEvent(testTitle,'click',function(){toggleClass(assertList,'qunit-collapsed');});testItem.className=testPassed?'pass':'fail';if(details.todo){var todoLabel=document.createElement('em');todoLabel.className='qunit-todo-label';todoLabel.innerHTML='todo';testItem.className+=' todo';testItem.insertBefore(todoLabel,testTitle);}var time=document.createElement('span');time.className='runtime';time.innerHTML=details.runtime+' ms';testItem.insertBefore(time,assertList);}// Show the source of the test when showing assertions\nif(details.source){var sourceName=document.createElement('p');sourceName.innerHTML='<strong>Source: </strong>'+escapeText(details.source);addClass(sourceName,'qunit-source');if(testPassed){addClass(sourceName,'qunit-collapsed');}addEvent(testTitle,'click',function(){toggleClass(sourceName,'qunit-collapsed');});testItem.appendChild(sourceName);}if(config.hidepassed&&(status==='passed'||details.skipped)){// use removeChild instead of remove because of support\nhiddenTests.push(testItem);tests.removeChild(testItem);}});QUnit.on('error',function(error){var testItem=appendTest('global failure');if(!testItem){// HTML Reporter is probably disabled or not yet initialized.\nreturn;}// Render similar to a failed assertion (see above QUnit.log callback)\nvar message=escapeText(errorString(error));message=\"<span class='test-message'>\"+message+'</span>';if(error&&error.stack){message+='<table>'+\"<tr class='test-source'><th>Source: </th><td><pre>\"+escapeText(error.stack)+'</pre></td></tr>'+'</table>';}var assertList=testItem.getElementsByTagName('ol')[0];var assertLi=document.createElement('li');assertLi.className='fail';assertLi.innerHTML=message;assertList.appendChild(assertLi);// Make it visible\ntestItem.className='fail';});// Avoid readyState issue with phantomjs\n// Ref: #818\nvar usingPhantom=function(p){return p&&p.version&&p.version.major>0;}(window$1.phantom);if(usingPhantom){console$1.warn('Support for PhantomJS is deprecated and will be removed in QUnit 3.0.');}if(!usingPhantom&&document.readyState==='complete'){QUnit.autostart();}else{addEvent(window$1,'load',QUnit.autostart);}// Wrap window.onerror. We will call the original window.onerror to see if\n// the existing handler fully handles the error; if not, we will call the\n// QUnit.onError function.\nvar originalWindowOnError=window$1.onerror;// Cover uncaught exceptions\n// Returning true will suppress the default browser handler,\n// returning false will let it run.\nwindow$1.onerror=function(message,fileName,lineNumber,columnNumber,errorObj){var ret=false;if(originalWindowOnError){for(var _len=arguments.length,args=new Array(_len>5?_len-5:0),_key=5;_key<_len;_key++){args[_key-5]=arguments[_key];}ret=originalWindowOnError.call.apply(originalWindowOnError,[this,message,fileName,lineNumber,columnNumber,errorObj].concat(args));}// Treat return value as window.onerror itself does,\n// Only do our handling if not suppressed.\nif(ret!==true){// If there is a current test that sets the internal `ignoreGlobalErrors` field\n// (such as during `assert.throws()`), then the error is ignored and native\n// error reporting is suppressed as well. This is because in browsers, an error\n// can sometimes end up in `window.onerror` instead of in the local try/catch.\n// This ignoring of errors does not apply to our general onUncaughtException\n// method, nor to our `unhandledRejection` handlers, as those are not meant\n// to receive an \"expected\" error during `assert.throws()`.\nif(config.current&&config.current.ignoreGlobalErrors){return true;}// According to\n// https://blog.sentry.io/2016/01/04/client-javascript-reporting-window-onerror,\n// most modern browsers support an errorObj argument; use that to\n// get a full stack trace if it's available.\nvar error=errorObj||new Error(message);if(!error.stack&&fileName&&lineNumber){error.stack=\"\".concat(fileName,\":\").concat(lineNumber);}QUnit.onUncaughtException(error);}return ret;};window$1.addEventListener('unhandledrejection',function(event){QUnit.onUncaughtException(event.reason);});})();})();\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/qunit/qunit/qunit.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/ember-welcome-page/dist/components/welcome-page.css":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/ember-welcome-page/dist/components/welcome-page.css ***!
  \****************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"body {\\n  color: rgb(28, 30, 36);\\n  background: rgb(244, 246, 248);\\n  font-family: \\\"Inter var\\\",\\\"Inter web\\\",-apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji;\\n  font-size: 18px;\\n  font-weight: 200;\\n  line-height: 1.5;\\n  margin: 0 auto;\\n  padding: 0;\\n}\\n#ember-welcome-page-id-selector {\\n  height: 100vh;\\n  padding: 2em;\\n}\\n#ember-welcome-page-id-selector img {\\n  max-width: 100%;\\n}\\n#ember-welcome-page-id-selector p {\\n  font-size: 1.25em;\\n  margin: 0 0 .75em;\\n}\\n#ember-welcome-page-id-selector h1 {\\n  font-size: 2.5em;\\n  font-weight: 200;\\n  line-height: 1.2;\\n  margin-top: 0;\\n}\\n#ember-welcome-page-id-selector a:link,\\n#ember-welcome-page-id-selector a:visited {\\n  color:rgb(255, 92, 68);\\n}\\n#ember-welcome-page-id-selector a:hover,\\n#ember-welcome-page-id-selector a:active {\\n  color: rgb(255, 92, 68);\\n}\\n#ember-welcome-page-id-selector .tomster {\\n  flex: 2;\\n}\\n#ember-welcome-page-id-selector .welcome {\\n  flex: 3;\\n}\\n#ember-welcome-page-id-selector .columns {\\n  display: flex;\\n  margin: 0 auto;\\n  max-width: 960px;\\n}\\n#ember-welcome-page-id-selector .welcome > ul > li {\\n  padding-bottom: 0.5em;\\n  font-size: 1.1em;\\n}\\n#ember-welcome-page-id-selector .welcome > ul > li > a {\\n  font-weight: bold;\\n}\\n#ember-welcome-page-id-selector .postscript {\\n  color: rgb(28, 30, 36);\\n  background: rgb(244, 246, 248);\\n  font-style: italic;\\n  line-height: 2;\\n  margin: 0 auto;\\n  max-width: 960px;\\n  padding-top: 3em;\\n  text-align: center;\\n}\\n#ember-welcome-page-id-selector .postscript code {\\n  color: rgb(244, 246, 248);\\n  border-radius: 3px;\\n  background-color: rgb(28, 30, 36);\\n  display: inline-block;\\n  font-family: Menlo, Courier, monospace;\\n  font-size: 0.9em;\\n  margin: 0 0.1em;\\n  padding: 0 0.5em;\\n}\\n@media (max-width: 700px) {\\n  #ember-welcome-page-id-selector {\\n    padding: 1em;\\n  }\\n  #ember-welcome-page-id-selector .columns {\\n    flex-direction: column;\\n  }\\n  #ember-welcome-page-id-selector .tomster img {\\n    display: block;\\n    margin: auto;\\n    width: 50%;\\n  }\\n  #ember-welcome-page-id-selector h2 {\\n    text-align: center;\\n  }\\n}\\n@media (max-width: 400px) {\\n  #ember-welcome-page-id-selector .tomster img {\\n    width: 60%;\\n  }\\n  #ember-welcome-page-id-selector .welcome,\\n  #ember-welcome-page-id-selector .tomster {\\n    float: none;\\n    margin: auto;\\n    width: 100%;\\n  }\\n}\\n\", \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/ember-welcome-page/dist/components/welcome-page.css?./node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/ember-welcome-page/dist/components/welcome-page.css":
/*!**************************************************************************!*\
  !*** ./node_modules/ember-welcome-page/dist/components/welcome-page.css ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _css_loader_dist_cjs_js_welcome_page_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../css-loader/dist/cjs.js!./welcome-page.css */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/ember-welcome-page/dist/components/welcome-page.css\");\n\n            \n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_welcome_page_css__WEBPACK_IMPORTED_MODULE_1__[\"default\"], options);\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_welcome_page_css__WEBPACK_IMPORTED_MODULE_1__[\"default\"].locals || {});\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/ember-welcome-page/dist/components/welcome-page.css?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar isOldIE = function isOldIE() {\n  var memo;\n  return function memorize() {\n    if (typeof memo === 'undefined') {\n      // Test for IE <= 9 as proposed by Browserhacks\n      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n      // Tests for existence of standard globals is to allow style-loader\n      // to operate correctly into non-standard environments\n      // @see https://github.com/webpack-contrib/style-loader/issues/177\n      memo = Boolean(window && document && document.all && !window.atob);\n    }\n\n    return memo;\n  };\n}();\n\nvar getTarget = function getTarget() {\n  var memo = {};\n  return function memorize(target) {\n    if (typeof memo[target] === 'undefined') {\n      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n        try {\n          // This will throw an exception if access to iframe is blocked\n          // due to cross-origin restrictions\n          styleTarget = styleTarget.contentDocument.head;\n        } catch (e) {\n          // istanbul ignore next\n          styleTarget = null;\n        }\n      }\n\n      memo[target] = styleTarget;\n    }\n\n    return memo[target];\n  };\n}();\n\nvar stylesInDom = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDom.length; i++) {\n    if (stylesInDom[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var index = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3]\n    };\n\n    if (index !== -1) {\n      stylesInDom[index].references++;\n      stylesInDom[index].updater(obj);\n    } else {\n      stylesInDom.push({\n        identifier: identifier,\n        updater: addStyle(obj, options),\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction insertStyleElement(options) {\n  var style = document.createElement('style');\n  var attributes = options.attributes || {};\n\n  if (typeof attributes.nonce === 'undefined') {\n    var nonce =  true ? __webpack_require__.nc : 0;\n\n    if (nonce) {\n      attributes.nonce = nonce;\n    }\n  }\n\n  Object.keys(attributes).forEach(function (key) {\n    style.setAttribute(key, attributes[key]);\n  });\n\n  if (typeof options.insert === 'function') {\n    options.insert(style);\n  } else {\n    var target = getTarget(options.insert || 'head');\n\n    if (!target) {\n      throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n    }\n\n    target.appendChild(style);\n  }\n\n  return style;\n}\n\nfunction removeStyleElement(style) {\n  // istanbul ignore if\n  if (style.parentNode === null) {\n    return false;\n  }\n\n  style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */\n\n\nvar replaceText = function replaceText() {\n  var textStore = [];\n  return function replace(index, replacement) {\n    textStore[index] = replacement;\n    return textStore.filter(Boolean).join('\\n');\n  };\n}();\n\nfunction applyToSingletonTag(style, index, remove, obj) {\n  var css = remove ? '' : obj.media ? \"@media \".concat(obj.media, \" {\").concat(obj.css, \"}\") : obj.css; // For old IE\n\n  /* istanbul ignore if  */\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = replaceText(index, css);\n  } else {\n    var cssNode = document.createTextNode(css);\n    var childNodes = style.childNodes;\n\n    if (childNodes[index]) {\n      style.removeChild(childNodes[index]);\n    }\n\n    if (childNodes.length) {\n      style.insertBefore(cssNode, childNodes[index]);\n    } else {\n      style.appendChild(cssNode);\n    }\n  }\n}\n\nfunction applyToTag(style, options, obj) {\n  var css = obj.css;\n  var media = obj.media;\n  var sourceMap = obj.sourceMap;\n\n  if (media) {\n    style.setAttribute('media', media);\n  } else {\n    style.removeAttribute('media');\n  }\n\n  if (sourceMap && typeof btoa !== 'undefined') {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    while (style.firstChild) {\n      style.removeChild(style.firstChild);\n    }\n\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar singleton = null;\nvar singletonCounter = 0;\n\nfunction addStyle(obj, options) {\n  var style;\n  var update;\n  var remove;\n\n  if (options.singleton) {\n    var styleIndex = singletonCounter++;\n    style = singleton || (singleton = insertStyleElement(options));\n    update = applyToSingletonTag.bind(null, style, styleIndex, false);\n    remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n  } else {\n    style = insertStyleElement(options);\n    update = applyToTag.bind(null, style, options);\n\n    remove = function remove() {\n      removeStyleElement(style);\n    };\n  }\n\n  update(obj);\n  return function updateStyle(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n        return;\n      }\n\n      update(obj = newObj);\n    } else {\n      remove();\n    }\n  };\n}\n\nmodule.exports = function (list, options) {\n  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n  // tags it will allow on a page\n\n  if (!options.singleton && typeof options.singleton !== 'boolean') {\n    options.singleton = isOldIE();\n  }\n\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    if (Object.prototype.toString.call(newList) !== '[object Array]') {\n      return;\n    }\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDom[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDom[_index].references === 0) {\n        stylesInDom[_index].updater();\n\n        stylesInDom.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://__ember_auto_import__/./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ })

}]);